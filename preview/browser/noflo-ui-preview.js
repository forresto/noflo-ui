
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module._resolving && !module.exports) {
    var mod = {};
    mod.exports = {};
    mod.client = mod.component = true;
    module._resolving = true;
    module.call(this, mod.exports, require.relative(resolved), mod);
    delete module._resolving;
    module.exports = mod.exports;
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("component-emitter/index.js", function(exports, require, module){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

});
require.register("component-underscore/index.js", function(exports, require, module){
//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = Math.floor(Math.random() * ++index);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = lookupIterator(obj, val);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(obj, val) {
    return _.isFunction(val) ? val : function(obj) { return obj[val]; };
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, val, behavior) {
    var result = {};
    var iterator = lookupIterator(obj, val);
    each(obj, function(value, index) {
      var key = iterator(value, index);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    return group(obj, val, function(result, key, value) {
      (result[key] || (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, val) {
    return group(obj, val, function(result, key, value) {
      result[key] || (result[key] = 0);
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var value = iterator(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    _.reduce(initial, function(memo, value, index) {
      if (isSorted ? (_.last(memo) !== value || !memo.length) : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, []));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(slice.call(arguments, 1), true, []);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Zip together two arrays -- an array of keys and an array of values -- into
  // a single object.
  _.zipObject = function(keys, values) {
    var result = {};
    for (var i = 0, l = keys.length; i < l; i++) {
      result[keys[i]] = values[i];
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        throttling = true;
        result = func.apply(context, args);
      }
      whenDone();
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(flatten(slice.call(arguments, 1), true, []), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // List of HTML entities for escaping.
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;'
  };

  // Regex containing the keys listed immediately above.
  var htmlEscaper = /[&<>"'\/]/g;

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return ('' + string).replace(htmlEscaper, function(match) {
      return htmlEscapes[match];
    });
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\':   '\\',
    "'":    "'",
    r:      '\r',
    n:      '\n',
    t:      '\t',
    u2028:  '\u2028',
    u2029:  '\u2029'
  };

  for (var key in escapes) escapes[escapes[key]] = key;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n((__t=(" + unescape(code) + "))==null?'':_.escape(__t))+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n((__t=(" + unescape(code) + "))==null?'':__t)+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result(obj, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);

});
require.register("noflo-fbp/lib/fbp.js", function(exports, require, module){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "line": parse_line,
        "LineTerminator": parse_LineTerminator,
        "comment": parse_comment,
        "connection": parse_connection,
        "bridge": parse_bridge,
        "leftlet": parse_leftlet,
        "iip": parse_iip,
        "rightlet": parse_rightlet,
        "node": parse_node,
        "component": parse_component,
        "compMeta": parse_compMeta,
        "port": parse_port,
        "anychar": parse_anychar,
        "iipchar": parse_iipchar,
        "_": parse__,
        "__": parse___
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_line();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_line();
        }
        if (result0 !== null) {
          result0 = (function(offset) { return parser.getResult();  })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_line() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.substr(pos, 7) === "EXPORT=") {
            result1 = "EXPORT=";
            pos += 7;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"EXPORT=\"");
            }
          }
          if (result1 !== null) {
            if (/^[A-Za-z.0-9_]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[A-Za-z.0-9_]");
              }
            }
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                if (/^[A-Za-z.0-9_]/.test(input.charAt(pos))) {
                  result3 = input.charAt(pos);
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[A-Za-z.0-9_]");
                  }
                }
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 58) {
                result3 = ":";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result3 !== null) {
                if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                  result5 = input.charAt(pos);
                  pos++;
                } else {
                  result5 = null;
                  if (reportFailures === 0) {
                    matchFailed("[A-Z0-9_]");
                  }
                }
                if (result5 !== null) {
                  result4 = [];
                  while (result5 !== null) {
                    result4.push(result5);
                    if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                      result5 = input.charAt(pos);
                      pos++;
                    } else {
                      result5 = null;
                      if (reportFailures === 0) {
                        matchFailed("[A-Z0-9_]");
                      }
                    }
                  }
                } else {
                  result4 = null;
                }
                if (result4 !== null) {
                  result5 = parse__();
                  if (result5 !== null) {
                    result6 = parse_LineTerminator();
                    result6 = result6 !== null ? result6 : "";
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, priv, pub) {return parser.registerExports(priv.join(""),pub.join(""))})(pos0, result0[2], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse__();
          if (result0 !== null) {
            if (input.substr(pos, 7) === "INPORT=") {
              result1 = "INPORT=";
              pos += 7;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"INPORT=\"");
              }
            }
            if (result1 !== null) {
              if (/^[A-Za-z0-9_]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[A-Za-z0-9_]");
                }
              }
              if (result3 !== null) {
                result2 = [];
                while (result3 !== null) {
                  result2.push(result3);
                  if (/^[A-Za-z0-9_]/.test(input.charAt(pos))) {
                    result3 = input.charAt(pos);
                    pos++;
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("[A-Za-z0-9_]");
                    }
                  }
                }
              } else {
                result2 = null;
              }
              if (result2 !== null) {
                if (input.charCodeAt(pos) === 46) {
                  result3 = ".";
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result3 !== null) {
                  if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                    result5 = input.charAt(pos);
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("[A-Z0-9_]");
                    }
                  }
                  if (result5 !== null) {
                    result4 = [];
                    while (result5 !== null) {
                      result4.push(result5);
                      if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                        result5 = input.charAt(pos);
                        pos++;
                      } else {
                        result5 = null;
                        if (reportFailures === 0) {
                          matchFailed("[A-Z0-9_]");
                        }
                      }
                    }
                  } else {
                    result4 = null;
                  }
                  if (result4 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      result5 = ":";
                      pos++;
                    } else {
                      result5 = null;
                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }
                    if (result5 !== null) {
                      if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                        result7 = input.charAt(pos);
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("[A-Z0-9_]");
                        }
                      }
                      if (result7 !== null) {
                        result6 = [];
                        while (result7 !== null) {
                          result6.push(result7);
                          if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                            result7 = input.charAt(pos);
                            pos++;
                          } else {
                            result7 = null;
                            if (reportFailures === 0) {
                              matchFailed("[A-Z0-9_]");
                            }
                          }
                        }
                      } else {
                        result6 = null;
                      }
                      if (result6 !== null) {
                        result7 = parse__();
                        if (result7 !== null) {
                          result8 = parse_LineTerminator();
                          result8 = result8 !== null ? result8 : "";
                          if (result8 !== null) {
                            result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, node, port, pub) {return parser.registerInports(node.join(""),port.join(""),pub.join(""))})(pos0, result0[2], result0[4], result0[6]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse__();
            if (result0 !== null) {
              if (input.substr(pos, 8) === "OUTPORT=") {
                result1 = "OUTPORT=";
                pos += 8;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"OUTPORT=\"");
                }
              }
              if (result1 !== null) {
                if (/^[A-Za-z0-9_]/.test(input.charAt(pos))) {
                  result3 = input.charAt(pos);
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[A-Za-z0-9_]");
                  }
                }
                if (result3 !== null) {
                  result2 = [];
                  while (result3 !== null) {
                    result2.push(result3);
                    if (/^[A-Za-z0-9_]/.test(input.charAt(pos))) {
                      result3 = input.charAt(pos);
                      pos++;
                    } else {
                      result3 = null;
                      if (reportFailures === 0) {
                        matchFailed("[A-Za-z0-9_]");
                      }
                    }
                  }
                } else {
                  result2 = null;
                }
                if (result2 !== null) {
                  if (input.charCodeAt(pos) === 46) {
                    result3 = ".";
                    pos++;
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                  if (result3 !== null) {
                    if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                      result5 = input.charAt(pos);
                      pos++;
                    } else {
                      result5 = null;
                      if (reportFailures === 0) {
                        matchFailed("[A-Z0-9_]");
                      }
                    }
                    if (result5 !== null) {
                      result4 = [];
                      while (result5 !== null) {
                        result4.push(result5);
                        if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                          result5 = input.charAt(pos);
                          pos++;
                        } else {
                          result5 = null;
                          if (reportFailures === 0) {
                            matchFailed("[A-Z0-9_]");
                          }
                        }
                      }
                    } else {
                      result4 = null;
                    }
                    if (result4 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result5 = ":";
                        pos++;
                      } else {
                        result5 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result5 !== null) {
                        if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                          result7 = input.charAt(pos);
                          pos++;
                        } else {
                          result7 = null;
                          if (reportFailures === 0) {
                            matchFailed("[A-Z0-9_]");
                          }
                        }
                        if (result7 !== null) {
                          result6 = [];
                          while (result7 !== null) {
                            result6.push(result7);
                            if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                              result7 = input.charAt(pos);
                              pos++;
                            } else {
                              result7 = null;
                              if (reportFailures === 0) {
                                matchFailed("[A-Z0-9_]");
                              }
                            }
                          }
                        } else {
                          result6 = null;
                        }
                        if (result6 !== null) {
                          result7 = parse__();
                          if (result7 !== null) {
                            result8 = parse_LineTerminator();
                            result8 = result8 !== null ? result8 : "";
                            if (result8 !== null) {
                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, node, port, pub) {return parser.registerOutports(node.join(""),port.join(""),pub.join(""))})(pos0, result0[2], result0[4], result0[6]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              result0 = parse_comment();
              if (result0 !== null) {
                if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
                  result1 = input.charAt(pos);
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("[\\n\\r\\u2028\\u2029]");
                  }
                }
                result1 = result1 !== null ? result1 : "";
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                result0 = parse__();
                if (result0 !== null) {
                  if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
                    result1 = input.charAt(pos);
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("[\\n\\r\\u2028\\u2029]");
                    }
                  }
                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }
                if (result0 === null) {
                  pos0 = pos;
                  pos1 = pos;
                  result0 = parse__();
                  if (result0 !== null) {
                    result1 = parse_connection();
                    if (result1 !== null) {
                      result2 = parse__();
                      if (result2 !== null) {
                        result3 = parse_LineTerminator();
                        result3 = result3 !== null ? result3 : "";
                        if (result3 !== null) {
                          result0 = [result0, result1, result2, result3];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                  if (result0 !== null) {
                    result0 = (function(offset, edges) {return parser.registerEdges(edges);})(pos0, result0[1]);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_LineTerminator() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_comment();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\n\\r\\u2028\\u2029]");
                }
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comment() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 35) {
            result1 = "#";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"#\"");
            }
          }
          if (result1 !== null) {
            result2 = [];
            result3 = parse_anychar();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_anychar();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_connection() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_bridge();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            if (input.substr(pos, 2) === "->") {
              result2 = "->";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"->\"");
              }
            }
            if (result2 !== null) {
              result3 = parse__();
              if (result3 !== null) {
                result4 = parse_connection();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, x, y) { return [x,y]; })(pos0, result0[0], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_bridge();
        }
        return result0;
      }
      
      function parse_bridge() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_port();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result2 = parse_node();
            if (result2 !== null) {
              result3 = parse__();
              if (result3 !== null) {
                result4 = parse_port();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, x, proc, y) { return [{"tgt":{process:proc, port:x}},{"src":{process:proc, port:y}}]; })(pos0, result0[0], result0[2], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_iip();
          if (result0 === null) {
            result0 = parse_rightlet();
            if (result0 === null) {
              result0 = parse_leftlet();
            }
          }
        }
        return result0;
      }
      
      function parse_leftlet() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_node();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result2 = parse_port();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, proc, port) { return {"src":{process:proc, port:port}} })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_iip() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 39) {
          result0 = "'";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"'\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_iipchar();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_iipchar();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 39) {
              result2 = "'";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"'\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, iip) { return {"data":iip.join("")} })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rightlet() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_port();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result2 = parse_node();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, port, proc) { return {"tgt":{process:proc, port:port}} })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_node() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[a-zA-Z0-9_]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z0-9_]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z0-9_]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_component();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, node, comp) { if(comp){parser.addNode(node.join(""),comp);}; return node.join("")})(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_component() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 !== null) {
          if (/^[a-zA-Z\/\-0-9_]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[a-zA-Z\\/\\-0-9_]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[a-zA-Z\/\-0-9_]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[a-zA-Z\\/\\-0-9_]");
                }
              }
            }
          } else {
            result1 = null;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_compMeta();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 41) {
                result3 = ")";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\")\"");
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, comp, meta) { var o = {}; comp ? o.comp = comp.join("") : o.comp = ''; meta ? o.meta = meta.join("").split(',') : null; return o; })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_compMeta() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          if (/^[a-zA-Z\/]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[a-zA-Z\\/]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[a-zA-Z\/]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[a-zA-Z\\/]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, meta) {return meta})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_port() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[A-Z.0-9_]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[A-Z.0-9_]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[A-Z.0-9_]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[A-Z.0-9_]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, portname) {return portname.join("").toLowerCase()})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_anychar() {
        var result0;
        
        if (/^[^\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[^\\n\\r\\u2028\\u2029]");
          }
        }
        return result0;
      }
      
      function parse_iipchar() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[\\]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\\\]");
          }
        }
        if (result0 !== null) {
          if (/^[']/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[']");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "'"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          if (/^[^']/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[^']");
            }
          }
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        
        result0 = [];
        if (input.charCodeAt(pos) === 32) {
          result1 = " ";
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (input.charCodeAt(pos) === 32) {
            result1 = " ";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\" \"");
            }
          }
        }
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        if (input.charCodeAt(pos) === 32) {
          result1 = " ";
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (input.charCodeAt(pos) === 32) {
              result1 = " ";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\" \"");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var parser, edges, nodes; 
      
        parser = this;
        delete parser.exports;
        delete parser.inports;
        delete parser.outports;
      
        edges = parser.edges = [];
      
        nodes = {};
      
        parser.addNode = function (nodeName, comp) {
          if (!nodes[nodeName]) {
            nodes[nodeName] = {}
          }
          if (!!comp.comp) {
            nodes[nodeName].component = comp.comp;
          }
          if (!!comp.meta) {
            nodes[nodeName].metadata={routes:comp.meta};
          }
         
        }
      
        parser.getResult = function () {
          return {processes:nodes, connections:parser.processEdges(), exports:parser.exports, inports: parser.inports, outports: parser.outports};
        }  
      
        var flatten = function (array, isShallow) {
          var index = -1,
            length = array ? array.length : 0,
            result = [];
      
          while (++index < length) {
            var value = array[index];
      
            if (value instanceof Array) {
              Array.prototype.push.apply(result, isShallow ? value : flatten(value));
            }
            else {
              result.push(value);
            }
          }
          return result;
        }
        
        parser.registerExports = function (priv, pub) {
          if (!parser.exports) {
            parser.exports = [];
          }
          parser.exports.push({private:priv.toLowerCase(), public:pub.toLowerCase()})
        }
        parser.registerInports = function (node, port, pub) {
          if (!parser.inports) {
            parser.inports = {};
          }
          parser.inports[pub.toLowerCase()] = {process:node, port:port.toLowerCase()}
        }
        parser.registerOutports = function (node, port, pub) {
          if (!parser.outports) {
            parser.outports = {};
          }
          parser.outports[pub.toLowerCase()] = {process:node, port:port.toLowerCase()}
        }
      
        parser.registerEdges = function (edges) {
      
          edges.forEach(function (o, i) {
            parser.edges.push(o);
          });
        }  
      
        parser.processEdges = function () {   
          var flats, grouped;
          flats = flatten(parser.edges);
          grouped = [];
          var current = {};
          flats.forEach(function (o, i) {
            if (i % 2 !== 0) { 
              var pair = grouped[grouped.length - 1];
              pair.tgt = o.tgt;
              return;
            }
            grouped.push(o);
          });
          return grouped;
        }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
});
require.register("noflo-noflo/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo","description":"Flow-Based Programming environment for JavaScript","keywords":["fbp","workflow","flow"],"repo":"noflo/noflo","version":"0.4.1","dependencies":{"component/emitter":"*","component/underscore":"*","noflo/fbp":"*"},"development":{},"license":"MIT","main":"src/lib/NoFlo.js","scripts":["src/lib/Graph.coffee","src/lib/InternalSocket.coffee","src/lib/BasePort.coffee","src/lib/InPort.coffee","src/lib/OutPort.coffee","src/lib/Ports.coffee","src/lib/Port.coffee","src/lib/ArrayPort.coffee","src/lib/Component.coffee","src/lib/AsyncComponent.coffee","src/lib/LoggingComponent.coffee","src/lib/ComponentLoader.coffee","src/lib/NoFlo.coffee","src/lib/Network.coffee","src/lib/Platform.coffee","src/lib/Journal.coffee","src/components/Graph.coffee"],"json":["component.json"],"noflo":{"components":{"Graph":"src/components/Graph.js"}}}');
});
require.register("noflo-noflo/src/lib/Graph.js", function(exports, require, module){
var EventEmitter, Graph,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

Graph = (function(_super) {
  __extends(Graph, _super);

  Graph.prototype.name = '';

  Graph.prototype.properties = {};

  Graph.prototype.nodes = [];

  Graph.prototype.edges = [];

  Graph.prototype.initializers = [];

  Graph.prototype.exports = [];

  Graph.prototype.inports = {};

  Graph.prototype.outports = {};

  Graph.prototype.groups = [];

  function Graph(name) {
    this.name = name != null ? name : '';
    this.properties = {};
    this.nodes = [];
    this.edges = [];
    this.initializers = [];
    this.exports = [];
    this.inports = {};
    this.outports = {};
    this.groups = [];
    this.transaction = {
      id: null,
      depth: 0
    };
  }

  Graph.prototype.startTransaction = function(id, metadata) {
    if (this.transaction.id) {
      throw Error("Nested transactions not supported");
    }
    this.transaction.id = id;
    this.transaction.depth = 1;
    return this.emit('startTransaction', id, metadata);
  };

  Graph.prototype.endTransaction = function(id, metadata) {
    if (!this.transaction.id) {
      throw Error("Attempted to end non-existing transaction");
    }
    this.transaction.id = null;
    this.transaction.depth = 0;
    return this.emit('endTransaction', id, metadata);
  };

  Graph.prototype.checkTransactionStart = function() {
    if (!this.transaction.id) {
      return this.startTransaction('implicit');
    } else if (this.transaction.id === 'implicit') {
      return this.transaction.depth += 1;
    }
  };

  Graph.prototype.checkTransactionEnd = function() {
    if (this.transaction.id === 'implicit') {
      this.transaction.depth -= 1;
    }
    if (this.transaction.depth === 0) {
      return this.endTransaction('implicit');
    }
  };

  Graph.prototype.setProperties = function(properties) {
    var item, val;
    for (item in properties) {
      val = properties[item];
      this.properties[item] = val;
    }
    return this.emit('changeProperties', this.properties);
  };

  Graph.prototype.addExport = function(publicPort, nodeKey, portKey, metadata) {
    var exported;
    if (metadata == null) {
      metadata = {
        x: 0,
        y: 0
      };
    }
    if (!this.getNode(nodeKey)) {
      return;
    }
    this.checkTransactionStart();
    exported = {
      "public": publicPort,
      process: nodeKey,
      port: portKey,
      metadata: metadata
    };
    this.exports.push(exported);
    this.emit('addExport', exported);
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeExport = function(publicPort) {
    var exported, found, idx, _i, _len, _ref;
    publicPort = publicPort.toLowerCase();
    found = null;
    _ref = this.exports;
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      exported = _ref[idx];
      if (exported["public"] === publicPort) {
        found = exported;
      }
    }
    if (!found) {
      return;
    }
    this.checkTransactionStart();
    this.exports.splice(this.exports.indexOf(found), 1);
    this.emit('removeExport', found);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addInport = function(publicPort, nodeKey, portKey, metadata) {
    if (!this.getNode(nodeKey)) {
      return;
    }
    this.checkTransactionStart();
    this.inports[publicPort] = {
      process: nodeKey,
      port: portKey,
      metadata: metadata
    };
    this.emit('addInport', publicPort, this.inports[publicPort]);
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeInport = function(publicPort) {
    var port;
    publicPort = publicPort.toLowerCase();
    if (!this.inports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    port = this.inports[publicPort];
    delete this.inports[publicPort];
    this.emit('removeInport', publicPort, port);
    return this.checkTransactionEnd();
  };

  Graph.prototype.renameInport = function(oldPort, newPort) {
    if (!this.inports[oldPort]) {
      return;
    }
    this.checkTransactionStart();
    this.inports[newPort] = this.inports[oldPort];
    delete this.inports[oldPort];
    this.emit('renameInport', oldPort, newPort);
    return this.checkTransactionEnd();
  };

  Graph.prototype.setInportMetadata = function(publicPort, metadata) {
    var item, val;
    if (!this.inports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    if (!this.inports[publicPort].metadata) {
      this.inports[publicPort].metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      this.inports[publicPort].metadata[item] = val;
    }
    this.emit('changeInport', this.inports[publicPort]);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addOutport = function(publicPort, nodeKey, portKey, metadata) {
    if (!this.getNode(nodeKey)) {
      return;
    }
    this.checkTransactionStart();
    this.outports[publicPort] = {
      process: nodeKey,
      port: portKey,
      metadata: metadata
    };
    return this.emit('addOutport', publicPort, this.outports[publicPort]);
  };

  Graph.prototype.removeOutport = function(publicPort) {
    var port;
    publicPort = publicPort.toLowerCase();
    if (!this.outports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    port = this.outports[publicPort];
    delete this.outports[publicPort];
    this.emit('removeOutport', publicPort, port);
    return this.checkTransactionEnd();
  };

  Graph.prototype.renameOutport = function(oldPort, newPort) {
    if (!this.outports[oldPort]) {
      return;
    }
    this.checkTransactionStart();
    this.outports[newPort] = this.outports[oldPort];
    delete this.outports[oldPort];
    this.emit('renameOutport', oldPort, newPort);
    return this.checkTransactionEnd();
  };

  Graph.prototype.setOutportMetadata = function(publicPort, metadata) {
    var item, val;
    if (!this.outports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    if (!this.outports[publicPort].metadata) {
      this.outports[publicPort].metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      this.outports[publicPort].metadata[item] = val;
    }
    this.emit('changeOutport', this.outports[publicPort]);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addGroup = function(group, nodes, metadata) {
    this.checkTransactionStart();
    this.groups.push({
      name: group,
      nodes: nodes,
      metadata: metadata
    });
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeGroup = function(groupName) {
    var group, _i, _len, _ref;
    this.checkTransactionStart();
    _ref = this.groups;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      if (!group) {
        continue;
      }
      if (group.name !== groupName) {
        continue;
      }
      this.groups.splice(this.groups.indexOf(group), 1);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.setGroupMetadata = function(groupName, metadata) {
    var group, item, val, _i, _len, _ref;
    this.checkTransactionStart();
    _ref = this.groups;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      if (!group) {
        continue;
      }
      if (group.name !== groupName) {
        continue;
      }
      for (item in metadata) {
        val = metadata[item];
        group.metadata[item] = val;
      }
      this.emit('changeGroup', group);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.addNode = function(id, component, metadata) {
    var node;
    this.checkTransactionStart();
    if (!metadata) {
      metadata = {};
    }
    node = {
      id: id,
      component: component,
      metadata: metadata
    };
    this.nodes.push(node);
    this.emit('addNode', node);
    this.checkTransactionEnd();
    return node;
  };

  Graph.prototype.removeNode = function(id) {
    var edge, exported, group, index, initializer, node, priv, pub, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    this.checkTransactionStart();
    node = this.getNode(id);
    _ref = this.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      edge = _ref[_i];
      if (!edge) {
        continue;
      }
      if (edge.from.node === node.id) {
        this.removeEdge(edge.from.node, edge.from.port);
      }
      if (edge.to.node === node.id) {
        this.removeEdge(edge.to.node, edge.to.port);
      }
    }
    _ref1 = this.initializers;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      initializer = _ref1[_j];
      if (!initializer) {
        continue;
      }
      if (initializer.to.node === node.id) {
        this.removeInitial(initializer.to.node, initializer.to.port);
      }
    }
    _ref2 = this.exports;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      exported = _ref2[_k];
      if (id.toLowerCase() === exported.process) {
        this.removeExports(exported["public"]);
      }
    }
    _ref3 = this.inports;
    for (pub in _ref3) {
      priv = _ref3[pub];
      if (priv.process === id) {
        this.removeInport(pub);
      }
    }
    _ref4 = this.outports;
    for (pub in _ref4) {
      priv = _ref4[pub];
      if (priv.process === id) {
        this.removeOutport(pub);
      }
    }
    _ref5 = this.groups;
    for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
      group = _ref5[_l];
      if (!group) {
        continue;
      }
      index = group.nodes.indexOf(id);
      if (index === -1) {
        continue;
      }
      group.nodes.splice(index, 1);
    }
    if (-1 !== this.nodes.indexOf(node)) {
      this.nodes.splice(this.nodes.indexOf(node), 1);
    }
    this.emit('removeNode', node);
    return this.checkTransactionEnd();
  };

  Graph.prototype.getNode = function(id) {
    var node, _i, _len, _ref;
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (!node) {
        continue;
      }
      if (node.id === id) {
        return node;
      }
    }
    return null;
  };

  Graph.prototype.renameNode = function(oldId, newId) {
    var edge, exported, group, iip, index, node, priv, pub, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    this.checkTransactionStart();
    node = this.getNode(oldId);
    if (!node) {
      return;
    }
    node.id = newId;
    _ref = this.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      edge = _ref[_i];
      if (!edge) {
        continue;
      }
      if (edge.from.node === oldId) {
        edge.from.node = newId;
      }
      if (edge.to.node === oldId) {
        edge.to.node = newId;
      }
    }
    _ref1 = this.initializers;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      iip = _ref1[_j];
      if (!iip) {
        continue;
      }
      if (iip.to.node === oldId) {
        iip.to.node = newId;
      }
    }
    _ref2 = this.inports;
    for (pub in _ref2) {
      priv = _ref2[pub];
      if (priv.process === oldId) {
        priv.process = newId;
      }
    }
    _ref3 = this.outports;
    for (pub in _ref3) {
      priv = _ref3[pub];
      if (priv.process === oldId) {
        priv.process = newId;
      }
    }
    _ref4 = this.exports;
    for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
      exported = _ref4[_k];
      if (exported.process === oldId) {
        exported.process = newId;
      }
    }
    _ref5 = this.groups;
    for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
      group = _ref5[_l];
      if (!group) {
        continue;
      }
      index = group.nodes.indexOf(oldId);
      if (index === -1) {
        continue;
      }
      group.nodes[index] = newId;
    }
    this.emit('renameNode', oldId, newId);
    return this.checkTransactionEnd();
  };

  Graph.prototype.setNodeMetadata = function(id, metadata) {
    var item, node, val;
    node = this.getNode(id);
    if (!node) {
      return;
    }
    this.checkTransactionStart();
    if (!node.metadata) {
      node.metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      node.metadata[item] = val;
    }
    this.emit('changeNode', node);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addEdge = function(outNode, outPort, inNode, inPort, metadata) {
    var edge, _i, _len, _ref;
    _ref = this.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      edge = _ref[_i];
      if (edge.from.node === outNode && edge.from.port === outPort && edge.to.node === inNode && edge.to.port === inPort) {
        return;
      }
    }
    if (!this.getNode(outNode)) {
      return;
    }
    if (!this.getNode(inNode)) {
      return;
    }
    if (!metadata) {
      metadata = {};
    }
    this.checkTransactionStart();
    edge = {
      from: {
        node: outNode,
        port: outPort
      },
      to: {
        node: inNode,
        port: inPort
      },
      metadata: metadata
    };
    this.edges.push(edge);
    this.emit('addEdge', edge);
    this.checkTransactionEnd();
    return edge;
  };

  Graph.prototype.removeEdge = function(node, port, node2, port2) {
    var edge, index, _i, _len, _ref;
    this.checkTransactionStart();
    _ref = this.edges;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      edge = _ref[index];
      if (!edge) {
        continue;
      }
      if (edge.from.node === node && edge.from.port === port) {
        if (node2 && port2) {
          if (!(edge.to.node === node2 && edge.to.port === port2)) {
            continue;
          }
        }
        this.emit('removeEdge', edge);
        this.edges.splice(index, 1);
      }
      if (edge.to.node === node && edge.to.port === port) {
        if (node2 && port2) {
          if (!(edge.from.node === node2 && edge.from.port === port2)) {
            continue;
          }
        }
        this.emit('removeEdge', edge);
        this.edges.splice(index, 1);
      }
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.getEdge = function(node, port, node2, port2) {
    var edge, index, _i, _len, _ref;
    _ref = this.edges;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      edge = _ref[index];
      if (!edge) {
        continue;
      }
      if (edge.from.node === node && edge.from.port === port) {
        if (edge.to.node === node2 && edge.to.port === port2) {
          return edge;
        }
      }
    }
    return null;
  };

  Graph.prototype.setEdgeMetadata = function(node, port, node2, port2, metadata) {
    var edge, item, val;
    edge = this.getEdge(node, port, node2, port2);
    if (!edge) {
      return;
    }
    this.checkTransactionStart();
    if (!edge.metadata) {
      edge.metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      edge.metadata[item] = val;
    }
    this.emit('changeEdge', edge);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addInitial = function(data, node, port, metadata) {
    var initializer;
    if (!this.getNode(node)) {
      return;
    }
    this.checkTransactionStart();
    initializer = {
      from: {
        data: data
      },
      to: {
        node: node,
        port: port
      },
      metadata: metadata
    };
    this.initializers.push(initializer);
    this.emit('addInitial', initializer);
    this.checkTransactionEnd();
    return initializer;
  };

  Graph.prototype.removeInitial = function(node, port) {
    var edge, index, _i, _len, _ref;
    this.checkTransactionStart();
    _ref = this.initializers;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      edge = _ref[index];
      if (!edge) {
        continue;
      }
      if (edge.to.node === node && edge.to.port === port) {
        this.emit('removeInitial', edge);
        this.initializers.splice(index, 1);
      }
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.toDOT = function() {
    var cleanID, cleanPort, data, dot, edge, id, initializer, node, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    cleanID = function(id) {
      return id.replace(/\s*/g, "");
    };
    cleanPort = function(port) {
      return port.replace(/\./g, "");
    };
    dot = "digraph {\n";
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      dot += "    " + (cleanID(node.id)) + " [label=" + node.id + " shape=box]\n";
    }
    _ref1 = this.initializers;
    for (id = _j = 0, _len1 = _ref1.length; _j < _len1; id = ++_j) {
      initializer = _ref1[id];
      if (typeof initializer.from.data === 'function') {
        data = 'Function';
      } else {
        data = initializer.from.data;
      }
      dot += "    data" + id + " [label=\"'" + data + "'\" shape=plaintext]\n";
      dot += "    data" + id + " -> " + (cleanID(initializer.to.node)) + "[headlabel=" + (cleanPort(initializer.to.port)) + " labelfontcolor=blue labelfontsize=8.0]\n";
    }
    _ref2 = this.edges;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      edge = _ref2[_k];
      dot += "    " + (cleanID(edge.from.node)) + " -> " + (cleanID(edge.to.node)) + "[taillabel=" + (cleanPort(edge.from.port)) + " headlabel=" + (cleanPort(edge.to.port)) + " labelfontcolor=blue labelfontsize=8.0]\n";
    }
    dot += "}";
    return dot;
  };

  Graph.prototype.toYUML = function() {
    var edge, initializer, yuml, _i, _j, _len, _len1, _ref, _ref1;
    yuml = [];
    _ref = this.initializers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      initializer = _ref[_i];
      yuml.push("(start)[" + initializer.to.port + "]->(" + initializer.to.node + ")");
    }
    _ref1 = this.edges;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      edge = _ref1[_j];
      yuml.push("(" + edge.from.node + ")[" + edge.from.port + "]->(" + edge.to.node + ")");
    }
    return yuml.join(",");
  };

  Graph.prototype.toJSON = function() {
    var connection, edge, exported, group, groupData, initializer, json, node, priv, property, pub, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    json = {
      properties: {},
      inports: {},
      outports: {},
      groups: [],
      processes: {},
      connections: []
    };
    if (this.name) {
      json.properties.name = this.name;
    }
    _ref = this.properties;
    for (property in _ref) {
      value = _ref[property];
      json.properties[property] = value;
    }
    _ref1 = this.inports;
    for (pub in _ref1) {
      priv = _ref1[pub];
      json.inports[pub] = priv;
    }
    _ref2 = this.outports;
    for (pub in _ref2) {
      priv = _ref2[pub];
      json.outports[pub] = priv;
    }
    _ref3 = this.exports;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      exported = _ref3[_i];
      if (!json.exports) {
        json.exports = [];
      }
      json.exports.push(exported);
    }
    _ref4 = this.groups;
    for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
      group = _ref4[_j];
      groupData = {
        name: group.name,
        nodes: group.nodes
      };
      if (group.metadata) {
        groupData.metadata = group.metadata;
      }
      json.groups.push(groupData);
    }
    _ref5 = this.nodes;
    for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
      node = _ref5[_k];
      json.processes[node.id] = {
        component: node.component
      };
      if (node.metadata) {
        json.processes[node.id].metadata = node.metadata;
      }
    }
    _ref6 = this.edges;
    for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
      edge = _ref6[_l];
      connection = {
        src: {
          process: edge.from.node,
          port: edge.from.port
        },
        tgt: {
          process: edge.to.node,
          port: edge.to.port
        }
      };
      if (Object.keys(edge.metadata).length) {
        connection.metadata = edge.metadata;
      }
      json.connections.push(connection);
    }
    _ref7 = this.initializers;
    for (_m = 0, _len4 = _ref7.length; _m < _len4; _m++) {
      initializer = _ref7[_m];
      json.connections.push({
        data: initializer.from.data,
        tgt: {
          process: initializer.to.node,
          port: initializer.to.port
        }
      });
    }
    return json;
  };

  Graph.prototype.save = function(file, success) {
    var json;
    json = JSON.stringify(this.toJSON(), null, 4);
    return require('fs').writeFile("" + file + ".json", json, "utf-8", function(err, data) {
      if (err) {
        throw err;
      }
      return success(file);
    });
  };

  return Graph;

})(EventEmitter);

exports.Graph = Graph;

exports.createGraph = function(name) {
  return new Graph(name);
};

exports.loadJSON = function(definition, success, metadata) {
  var conn, def, exported, graph, group, id, portId, priv, processId, property, pub, split, value, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
  if (metadata == null) {
    metadata = {};
  }
  if (!definition.properties) {
    definition.properties = {};
  }
  if (!definition.processes) {
    definition.processes = {};
  }
  if (!definition.connections) {
    definition.connections = [];
  }
  graph = new Graph(definition.properties.name);
  graph.startTransaction('loadJSON', metadata);
  _ref = definition.properties;
  for (property in _ref) {
    value = _ref[property];
    if (property === 'name') {
      continue;
    }
    graph.properties[property] = value;
  }
  _ref1 = definition.processes;
  for (id in _ref1) {
    def = _ref1[id];
    if (!def.metadata) {
      def.metadata = {};
    }
    graph.addNode(id, def.component, def.metadata);
  }
  _ref2 = definition.connections;
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    conn = _ref2[_i];
    if (conn.data !== void 0) {
      graph.addInitial(conn.data, conn.tgt.process, conn.tgt.port.toLowerCase());
      continue;
    }
    metadata = conn.metadata ? conn.metadata : {};
    graph.addEdge(conn.src.process, conn.src.port.toLowerCase(), conn.tgt.process, conn.tgt.port.toLowerCase(), metadata);
  }
  if (definition.exports && definition.exports.length) {
    _ref3 = definition.exports;
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      exported = _ref3[_j];
      split = exported["private"].split('.');
      if (split.length !== 2) {
        continue;
      }
      processId = split[0];
      portId = split[1];
      for (id in definition.processes) {
        if (id.toLowerCase() === processId.toLowerCase()) {
          processId = id;
        }
      }
      graph.addExport(exported["public"], processId, portId, exported.metadata);
    }
  }
  if (definition.inports) {
    _ref4 = definition.inports;
    for (pub in _ref4) {
      priv = _ref4[pub];
      graph.addInport(pub, priv.process, priv.port, priv.metadata);
    }
  }
  if (definition.outports) {
    _ref5 = definition.outports;
    for (pub in _ref5) {
      priv = _ref5[pub];
      graph.addOutport(pub, priv.process, priv.port, priv.metadata);
    }
  }
  if (definition.groups) {
    _ref6 = definition.groups;
    for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
      group = _ref6[_k];
      graph.addGroup(group.name, group.nodes, group.metadata);
    }
  }
  graph.endTransaction('loadJSON');
  return success(graph);
};

exports.loadFBP = function(fbpData, success) {
  var definition;
  definition = require('fbp').parse(fbpData);
  return exports.loadJSON(definition, success);
};

exports.loadHTTP = function(url, success) {
  var req;
  req = new XMLHttpRequest;
  req.onreadystatechange = function() {
    if (req.readyState !== 4) {
      return;
    }
    if (req.status !== 200) {
      return success();
    }
    return success(req.responseText);
  };
  req.open('GET', url, true);
  return req.send();
};

exports.loadFile = function(file, success, metadata) {
  var definition, e;
  if (metadata == null) {
    metadata = {};
  }
  if (!(typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1)) {
    try {
      definition = require(file);
      exports.loadJSON(definition, success, metadata);
      return;
    } catch (_error) {
      e = _error;
      exports.loadHTTP(file, function(data) {
        if (!data) {
          throw new Error("Failed to load graph " + file);
          return;
        }
        if (file.split('.').pop() === 'fbp') {
          return exports.loadFBP(data, success);
        }
        definition = JSON.parse(data);
        return exports.loadJSON(definition, success);
      });
    }
    return;
  }
  return require('fs').readFile(file, "utf-8", function(err, data) {
    if (err) {
      throw err;
    }
    if (file.split('.').pop() === 'fbp') {
      return exports.loadFBP(data, success);
    }
    definition = JSON.parse(data);
    return exports.loadJSON(definition, success);
  });
};

});
require.register("noflo-noflo/src/lib/InternalSocket.js", function(exports, require, module){
var EventEmitter, InternalSocket,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

InternalSocket = (function(_super) {
  __extends(InternalSocket, _super);

  function InternalSocket() {
    this.connected = false;
    this.groups = [];
  }

  InternalSocket.prototype.connect = function() {
    if (this.connected) {
      return;
    }
    this.connected = true;
    return this.emit('connect', this);
  };

  InternalSocket.prototype.disconnect = function() {
    if (!this.connected) {
      return;
    }
    this.connected = false;
    return this.emit('disconnect', this);
  };

  InternalSocket.prototype.isConnected = function() {
    return this.connected;
  };

  InternalSocket.prototype.send = function(data) {
    if (!this.connected) {
      this.connect();
    }
    return this.emit('data', data);
  };

  InternalSocket.prototype.beginGroup = function(group) {
    this.groups.push(group);
    return this.emit('begingroup', group);
  };

  InternalSocket.prototype.endGroup = function() {
    return this.emit('endgroup', this.groups.pop());
  };

  InternalSocket.prototype.getId = function() {
    var fromStr, toStr;
    fromStr = function(from) {
      return "" + from.process.id + "() " + (from.port.toUpperCase());
    };
    toStr = function(to) {
      return "" + (to.port.toUpperCase()) + " " + to.process.id + "()";
    };
    if (!(this.from || this.to)) {
      return "UNDEFINED";
    }
    if (this.from && !this.to) {
      return "" + (fromStr(this.from)) + " -> ANON";
    }
    if (!this.from) {
      return "DATA -> " + (toStr(this.to));
    }
    return "" + (fromStr(this.from)) + " -> " + (toStr(this.to));
  };

  return InternalSocket;

})(EventEmitter);

exports.InternalSocket = InternalSocket;

exports.createSocket = function() {
  return new InternalSocket;
};

});
require.register("noflo-noflo/src/lib/BasePort.js", function(exports, require, module){
var BasePort, EventEmitter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

BasePort = (function(_super) {
  __extends(BasePort, _super);

  function BasePort(options) {
    this.options = options;
    if (!this.options) {
      this.options = {};
    }
    if (!this.options.datatype) {
      this.options.datatype = 'all';
    }
    if (this.options.required === void 0) {
      this.options.required = true;
    }
    this.sockets = [];
    this.node = null;
    this.name = null;
  }

  BasePort.prototype.getId = function() {
    if (!(this.node && this.name)) {
      return 'Port';
    }
    return "" + this.node + " " + (this.name.toUpperCase());
  };

  BasePort.prototype.getDataType = function() {
    return this.options.datatype;
  };

  BasePort.prototype.attach = function(socket, index) {
    if (index == null) {
      index = null;
    }
    if (!this.isAddressable() || index === null) {
      index = this.sockets.length;
    }
    this.sockets[index] = socket;
    this.attachSocket(socket, index);
    if (this.isAddressable()) {
      this.emit('attach', socket, index);
      return;
    }
    return this.emit('attach', socket);
  };

  BasePort.prototype.attachSocket = function() {};

  BasePort.prototype.detach = function(socket) {
    var index;
    index = this.sockets.indexOf(socket);
    if (index === -1) {
      return;
    }
    this.sockets.splice(index, 1);
    if (this.isAddressable()) {
      this.emit('detach', socket, index);
      return;
    }
    return this.emit('detach', socket);
  };

  BasePort.prototype.isAddressable = function() {
    if (this.options.addressable) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isBuffered = function() {
    if (this.options.buffered) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isRequired = function() {
    if (this.options.required) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isAttached = function(socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (this.isAddressable() && socketId !== null) {
      if (this.sockets[socketId]) {
        return true;
      }
      return false;
    }
    if (this.sockets.length) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isConnected = function(socketId) {
    var connected;
    if (socketId == null) {
      socketId = null;
    }
    if (this.isAddressable()) {
      if (socketId === null) {
        throw new Error("" + (this.getId()) + ": Socket ID required");
      }
      if (!this.sockets[socketId]) {
        throw new Error("" + (this.getId()) + ": Socket " + socketId + " not available");
      }
      return this.sockets[socketId].isConnected();
    }
    connected = false;
    this.sockets.forEach((function(_this) {
      return function(socket) {
        if (socket.isConnected()) {
          return connected = true;
        }
      };
    })(this));
    return connected;
  };

  BasePort.prototype.canAttach = function() {
    return true;
  };

  return BasePort;

})(EventEmitter);

module.exports = BasePort;

});
require.register("noflo-noflo/src/lib/InPort.js", function(exports, require, module){
var BasePort, InPort,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BasePort = require('./BasePort');

InPort = (function(_super) {
  __extends(InPort, _super);

  function InPort(options, process) {
    this.process = null;
    if (!process && typeof options === 'function') {
      process = options;
      options = {};
    }
    if (options && options.buffered === void 0) {
      options.buffered = false;
    }
    if (process) {
      if (typeof process !== 'function') {
        throw new Error('process must be a function');
      }
      this.process = process;
    }
    InPort.__super__.constructor.call(this, options);
  }

  InPort.prototype.attachSocket = function(socket, localId) {
    if (localId == null) {
      localId = null;
    }
    socket.on('connect', (function(_this) {
      return function() {
        return _this.handleSocketEvent('connect', socket, localId);
      };
    })(this));
    socket.on('begingroup', (function(_this) {
      return function(group) {
        return _this.handleSocketEvent('begingroup', group, localId);
      };
    })(this));
    socket.on('data', (function(_this) {
      return function(data) {
        return _this.handleSocketEvent('data', data, localId);
      };
    })(this));
    socket.on('endgroup', (function(_this) {
      return function(group) {
        return _this.handleSocketEvent('endgroup', group, localId);
      };
    })(this));
    return socket.on('disconnect', (function(_this) {
      return function() {
        return _this.handleSocketEvent('disconnect', socket, localId);
      };
    })(this));
  };

  InPort.prototype.handleSocketEvent = function(event, payload, id) {
    if (this.process) {
      if (this.isAddressable()) {
        this.process(event, payload, id, this.nodeInstance);
      } else {
        this.process(event, payload, this.nodeInstance);
      }
    }
    if (this.isAddressable()) {
      return this.emit(event, payload, id);
    }
    return this.emit(event, payload);
  };

  return InPort;

})(BasePort);

module.exports = InPort;

});
require.register("noflo-noflo/src/lib/OutPort.js", function(exports, require, module){
var BasePort, OutPort,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BasePort = require('./BasePort');

OutPort = (function(_super) {
  __extends(OutPort, _super);

  function OutPort() {
    return OutPort.__super__.constructor.apply(this, arguments);
  }

  OutPort.prototype.connect = function(socketId) {
    var socket, sockets, _i, _len, _results;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    _results = [];
    for (_i = 0, _len = sockets.length; _i < _len; _i++) {
      socket = sockets[_i];
      _results.push(socket.connect());
    }
    return _results;
  };

  OutPort.prototype.beginGroup = function(group, socketId) {
    var sockets;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    return sockets.forEach(function(socket) {
      if (socket.isConnected()) {
        return socket.beginGroup(group);
      }
      socket.once('connect', function() {
        return socket.beginGroup(group);
      });
      return socket.connect();
    });
  };

  OutPort.prototype.send = function(data, socketId) {
    var sockets;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    return sockets.forEach(function(socket) {
      if (socket.isConnected()) {
        return socket.send(data);
      }
      socket.once('connect', function() {
        return socket.send(data);
      });
      return socket.connect();
    });
  };

  OutPort.prototype.endGroup = function(socketId) {
    var socket, sockets, _i, _len, _results;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    _results = [];
    for (_i = 0, _len = sockets.length; _i < _len; _i++) {
      socket = sockets[_i];
      _results.push(socket.endGroup());
    }
    return _results;
  };

  OutPort.prototype.disconnect = function(socketId) {
    var socket, sockets, _i, _len, _results;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    _results = [];
    for (_i = 0, _len = sockets.length; _i < _len; _i++) {
      socket = sockets[_i];
      _results.push(socket.disconnect());
    }
    return _results;
  };

  OutPort.prototype.checkRequired = function(sockets) {
    if (!(sockets.length && this.isRequired())) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
  };

  OutPort.prototype.getSockets = function(socketId) {
    if (this.isAddressable()) {
      if (socketId === null) {
        throw new Error("" + (this.getId()) + " Socket ID required");
      }
      if (!this.sockets[socketId]) {
        return [];
      }
      return [this.sockets[socketId]];
    }
    return this.sockets;
  };

  return OutPort;

})(BasePort);

module.exports = OutPort;

});
require.register("noflo-noflo/src/lib/Ports.js", function(exports, require, module){
var EventEmitter, InPort, InPorts, OutPort, OutPorts, Ports,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

InPort = require('./InPort');

OutPort = require('./OutPort');

Ports = (function(_super) {
  __extends(Ports, _super);

  Ports.prototype.model = InPort;

  function Ports(ports) {
    var name, options;
    this.ports = {};
    if (!ports) {
      return;
    }
    for (name in ports) {
      options = ports[name];
      this.add(name, options);
    }
  }

  Ports.prototype.add = function(name, options, process) {
    if (name === 'add' || name === 'remove') {
      throw new Error('Add and remove are restricted port names');
    }
    if (this.ports[name]) {
      this.remove(name);
    }
    if (typeof options === 'object' && options.canAttach) {
      this.ports[name] = options;
    } else {
      this.ports[name] = new this.model(options, process);
    }
    this[name] = this.ports[name];
    return this.emit('add', name);
  };

  Ports.prototype.remove = function(name) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not defined");
    }
    delete this.ports[name];
    delete this[name];
    return this.emit('remove', name);
  };

  return Ports;

})(EventEmitter);

exports.InPorts = InPorts = (function(_super) {
  __extends(InPorts, _super);

  function InPorts() {
    return InPorts.__super__.constructor.apply(this, arguments);
  }

  InPorts.prototype.on = function(name, event, callback) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].on(event, callback);
  };

  InPorts.prototype.once = function(name, event, callback) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].once(event, callback);
  };

  return InPorts;

})(Ports);

exports.OutPorts = OutPorts = (function(_super) {
  __extends(OutPorts, _super);

  function OutPorts() {
    return OutPorts.__super__.constructor.apply(this, arguments);
  }

  OutPorts.prototype.model = OutPort;

  OutPorts.prototype.connect = function(name, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].connect(socketId);
  };

  OutPorts.prototype.beginGroup = function(name, group, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].beginGroup(group, socketId);
  };

  OutPorts.prototype.send = function(name, data, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].send(data, socketId);
  };

  OutPorts.prototype.endGroup = function(name, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].endGroup(socketId);
  };

  OutPorts.prototype.disconnect = function(name, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].disconnect(socketId);
  };

  return OutPorts;

})(Ports);

});
require.register("noflo-noflo/src/lib/Port.js", function(exports, require, module){
var EventEmitter, Port,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

Port = (function(_super) {
  __extends(Port, _super);

  function Port(type) {
    this.type = type;
    if (!this.type) {
      this.type = 'all';
    }
    this.sockets = [];
    this.from = null;
    this.node = null;
    this.name = null;
  }

  Port.prototype.getId = function() {
    if (!(this.node && this.name)) {
      return 'Port';
    }
    return "" + this.node + " " + (this.name.toUpperCase());
  };

  Port.prototype.getDataType = function() {
    return this.type;
  };

  Port.prototype.attach = function(socket) {
    this.sockets.push(socket);
    return this.attachSocket(socket);
  };

  Port.prototype.attachSocket = function(socket, localId) {
    if (localId == null) {
      localId = null;
    }
    this.emit("attach", socket);
    this.from = socket.from;
    if (socket.setMaxListeners) {
      socket.setMaxListeners(0);
    }
    socket.on("connect", (function(_this) {
      return function() {
        return _this.emit("connect", socket, localId);
      };
    })(this));
    socket.on("begingroup", (function(_this) {
      return function(group) {
        return _this.emit("begingroup", group, localId);
      };
    })(this));
    socket.on("data", (function(_this) {
      return function(data) {
        return _this.emit("data", data, localId);
      };
    })(this));
    socket.on("endgroup", (function(_this) {
      return function(group) {
        return _this.emit("endgroup", group, localId);
      };
    })(this));
    return socket.on("disconnect", (function(_this) {
      return function() {
        return _this.emit("disconnect", socket, localId);
      };
    })(this));
  };

  Port.prototype.connect = function() {
    var socket, _i, _len, _ref, _results;
    if (this.sockets.length === 0) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
    _ref = this.sockets;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      socket = _ref[_i];
      _results.push(socket.connect());
    }
    return _results;
  };

  Port.prototype.beginGroup = function(group) {
    if (this.sockets.length === 0) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
    return this.sockets.forEach(function(socket) {
      if (socket.isConnected()) {
        return socket.beginGroup(group);
      }
      socket.once('connect', function() {
        return socket.beginGroup(group);
      });
      return socket.connect();
    });
  };

  Port.prototype.send = function(data) {
    if (this.sockets.length === 0) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
    return this.sockets.forEach(function(socket) {
      if (socket.isConnected()) {
        return socket.send(data);
      }
      socket.once('connect', function() {
        return socket.send(data);
      });
      return socket.connect();
    });
  };

  Port.prototype.endGroup = function() {
    var socket, _i, _len, _ref, _results;
    if (this.sockets.length === 0) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
    _ref = this.sockets;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      socket = _ref[_i];
      _results.push(socket.endGroup());
    }
    return _results;
  };

  Port.prototype.disconnect = function() {
    var socket, _i, _len, _ref, _results;
    if (this.sockets.length === 0) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
    _ref = this.sockets;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      socket = _ref[_i];
      _results.push(socket.disconnect());
    }
    return _results;
  };

  Port.prototype.detach = function(socket) {
    var index;
    if (this.sockets.length === 0) {
      return;
    }
    if (!socket) {
      socket = this.sockets[0];
    }
    index = this.sockets.indexOf(socket);
    if (index === -1) {
      return;
    }
    this.sockets.splice(index, 1);
    return this.emit("detach", socket);
  };

  Port.prototype.isConnected = function() {
    var connected;
    connected = false;
    this.sockets.forEach((function(_this) {
      return function(socket) {
        if (socket.isConnected()) {
          return connected = true;
        }
      };
    })(this));
    return connected;
  };

  Port.prototype.isAttached = function() {
    if (this.sockets.length > 0) {
      return true;
    }
    return false;
  };

  Port.prototype.canAttach = function() {
    return true;
  };

  return Port;

})(EventEmitter);

exports.Port = Port;

});
require.register("noflo-noflo/src/lib/ArrayPort.js", function(exports, require, module){
var ArrayPort, port,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

port = require("./Port");

ArrayPort = (function(_super) {
  __extends(ArrayPort, _super);

  function ArrayPort(type) {
    this.type = type;
    ArrayPort.__super__.constructor.call(this, this.type);
  }

  ArrayPort.prototype.attach = function(socket) {
    this.sockets.push(socket);
    return this.attachSocket(socket, this.sockets.length - 1);
  };

  ArrayPort.prototype.connect = function(socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error("" + (this.getId()) + ": No connections available");
      }
      this.sockets.forEach(function(socket) {
        return socket.connect();
      });
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error("" + (this.getId()) + ": No connection '" + socketId + "' available");
    }
    return this.sockets[socketId].connect();
  };

  ArrayPort.prototype.beginGroup = function(group, socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error("" + (this.getId()) + ": No connections available");
      }
      this.sockets.forEach((function(_this) {
        return function(socket, index) {
          return _this.beginGroup(group, index);
        };
      })(this));
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error("" + (this.getId()) + ": No connection '" + socketId + "' available");
    }
    if (this.isConnected(socketId)) {
      return this.sockets[socketId].beginGroup(group);
    }
    this.sockets[socketId].once("connect", (function(_this) {
      return function() {
        return _this.sockets[socketId].beginGroup(group);
      };
    })(this));
    return this.sockets[socketId].connect();
  };

  ArrayPort.prototype.send = function(data, socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error("" + (this.getId()) + ": No connections available");
      }
      this.sockets.forEach((function(_this) {
        return function(socket, index) {
          return _this.send(data, index);
        };
      })(this));
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error("" + (this.getId()) + ": No connection '" + socketId + "' available");
    }
    if (this.isConnected(socketId)) {
      return this.sockets[socketId].send(data);
    }
    this.sockets[socketId].once("connect", (function(_this) {
      return function() {
        return _this.sockets[socketId].send(data);
      };
    })(this));
    return this.sockets[socketId].connect();
  };

  ArrayPort.prototype.endGroup = function(socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error("" + (this.getId()) + ": No connections available");
      }
      this.sockets.forEach((function(_this) {
        return function(socket, index) {
          return _this.endGroup(index);
        };
      })(this));
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error("" + (this.getId()) + ": No connection '" + socketId + "' available");
    }
    return this.sockets[socketId].endGroup();
  };

  ArrayPort.prototype.disconnect = function(socketId) {
    var socket, _i, _len, _ref;
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error("" + (this.getId()) + ": No connections available");
      }
      _ref = this.sockets;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        socket = _ref[_i];
        socket.disconnect();
      }
      return;
    }
    if (!this.sockets[socketId]) {
      return;
    }
    return this.sockets[socketId].disconnect();
  };

  ArrayPort.prototype.isConnected = function(socketId) {
    var connected;
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      connected = false;
      this.sockets.forEach((function(_this) {
        return function(socket) {
          if (socket.isConnected()) {
            return connected = true;
          }
        };
      })(this));
      return connected;
    }
    if (!this.sockets[socketId]) {
      return false;
    }
    return this.sockets[socketId].isConnected();
  };

  ArrayPort.prototype.isAttached = function(socketId) {
    if (socketId === void 0) {
      if (this.sockets.length > 0) {
        return true;
      }
      return false;
    }
    if (this.sockets[socketId]) {
      return true;
    }
    return false;
  };

  return ArrayPort;

})(port.Port);

exports.ArrayPort = ArrayPort;

});
require.register("noflo-noflo/src/lib/Component.js", function(exports, require, module){
var Component, EventEmitter, ports,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

ports = require('./Ports');

Component = (function(_super) {
  __extends(Component, _super);

  Component.prototype.description = '';

  Component.prototype.icon = null;

  function Component(options) {
    this.error = __bind(this.error, this);
    if (!options) {
      options = {};
    }
    if (!options.inPorts) {
      options.inPorts = {};
    }
    if (options.inPorts instanceof ports.InPorts) {
      this.inPorts = options.inPorts;
    } else {
      this.inPorts = new ports.InPorts(options.inPorts);
    }
    if (!options.outPorts) {
      options.outPorts = {};
    }
    if (options.outPorts instanceof ports.OutPorts) {
      this.outPorts = options.outPorts;
    } else {
      this.outPorts = new ports.OutPorts(options.outPorts);
    }
  }

  Component.prototype.getDescription = function() {
    return this.description;
  };

  Component.prototype.isReady = function() {
    return true;
  };

  Component.prototype.isSubgraph = function() {
    return false;
  };

  Component.prototype.setIcon = function(icon) {
    this.icon = icon;
    return this.emit('icon', this.icon);
  };

  Component.prototype.getIcon = function() {
    return this.icon;
  };

  Component.prototype.error = function(e) {
    if (this.outPorts.error && this.outPorts.error.isAttached()) {
      this.outPorts.error.send(e);
      this.outPorts.error.disconnect();
      return;
    }
    throw e;
  };

  Component.prototype.shutdown = function() {};

  return Component;

})(EventEmitter);

exports.Component = Component;

});
require.register("noflo-noflo/src/lib/AsyncComponent.js", function(exports, require, module){
var AsyncComponent, component, port,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

port = require("./Port");

component = require("./Component");

AsyncComponent = (function(_super) {
  __extends(AsyncComponent, _super);

  function AsyncComponent(inPortName, outPortName, errPortName) {
    this.inPortName = inPortName != null ? inPortName : "in";
    this.outPortName = outPortName != null ? outPortName : "out";
    this.errPortName = errPortName != null ? errPortName : "error";
    if (!this.inPorts[this.inPortName]) {
      throw new Error("no inPort named '" + this.inPortName + "'");
    }
    if (!this.outPorts[this.outPortName]) {
      throw new Error("no outPort named '" + this.outPortName + "'");
    }
    this.load = 0;
    this.q = [];
    this.outPorts.load = new port.Port();
    this.inPorts[this.inPortName].on("begingroup", (function(_this) {
      return function(group) {
        if (_this.load > 0) {
          return _this.q.push({
            name: "begingroup",
            data: group
          });
        }
        return _this.outPorts[_this.outPortName].beginGroup(group);
      };
    })(this));
    this.inPorts[this.inPortName].on("endgroup", (function(_this) {
      return function() {
        if (_this.load > 0) {
          return _this.q.push({
            name: "endgroup"
          });
        }
        return _this.outPorts[_this.outPortName].endGroup();
      };
    })(this));
    this.inPorts[this.inPortName].on("disconnect", (function(_this) {
      return function() {
        if (_this.load > 0) {
          return _this.q.push({
            name: "disconnect"
          });
        }
        _this.outPorts[_this.outPortName].disconnect();
        if (_this.outPorts.load.isAttached()) {
          return _this.outPorts.load.disconnect();
        }
      };
    })(this));
    this.inPorts[this.inPortName].on("data", (function(_this) {
      return function(data) {
        if (_this.q.length > 0) {
          return _this.q.push({
            name: "data",
            data: data
          });
        }
        return _this.processData(data);
      };
    })(this));
  }

  AsyncComponent.prototype.processData = function(data) {
    this.incrementLoad();
    return this.doAsync(data, (function(_this) {
      return function(err) {
        if (err) {
          if (_this.outPorts[_this.errPortName] && _this.outPorts[_this.errPortName].isAttached()) {
            _this.outPorts[_this.errPortName].send(err);
            _this.outPorts[_this.errPortName].disconnect();
          } else {
            throw err;
          }
        }
        return _this.decrementLoad();
      };
    })(this));
  };

  AsyncComponent.prototype.incrementLoad = function() {
    this.load++;
    if (this.outPorts.load.isAttached()) {
      this.outPorts.load.send(this.load);
    }
    if (this.outPorts.load.isAttached()) {
      return this.outPorts.load.disconnect();
    }
  };

  AsyncComponent.prototype.doAsync = function(data, callback) {
    return callback(new Error("AsyncComponents must implement doAsync"));
  };

  AsyncComponent.prototype.decrementLoad = function() {
    if (this.load === 0) {
      throw new Error("load cannot be negative");
    }
    this.load--;
    if (this.outPorts.load.isAttached()) {
      this.outPorts.load.send(this.load);
    }
    if (this.outPorts.load.isAttached()) {
      this.outPorts.load.disconnect();
    }
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      return process.nextTick((function(_this) {
        return function() {
          return _this.processQueue();
        };
      })(this));
    } else {
      return setTimeout((function(_this) {
        return function() {
          return _this.processQueue();
        };
      })(this), 0);
    }
  };

  AsyncComponent.prototype.processQueue = function() {
    var event, processedData;
    if (this.load > 0) {
      return;
    }
    processedData = false;
    while (this.q.length > 0) {
      event = this.q[0];
      switch (event.name) {
        case "begingroup":
          if (processedData) {
            return;
          }
          this.outPorts[this.outPortName].beginGroup(event.data);
          this.q.shift();
          break;
        case "endgroup":
          if (processedData) {
            return;
          }
          this.outPorts[this.outPortName].endGroup();
          this.q.shift();
          break;
        case "disconnect":
          if (processedData) {
            return;
          }
          this.outPorts[this.outPortName].disconnect();
          if (this.outPorts.load.isAttached()) {
            this.outPorts.load.disconnect();
          }
          this.q.shift();
          break;
        case "data":
          this.processData(event.data);
          this.q.shift();
          processedData = true;
      }
    }
  };

  return AsyncComponent;

})(component.Component);

exports.AsyncComponent = AsyncComponent;

});
require.register("noflo-noflo/src/lib/LoggingComponent.js", function(exports, require, module){
var Component, Port, util,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require("./Component").Component;

Port = require("./Port").Port;

if (!require('./Platform').isBrowser()) {
  util = require("util");
} else {
  util = {
    inspect: function(data) {
      return data;
    }
  };
}

exports.LoggingComponent = (function(_super) {
  __extends(LoggingComponent, _super);

  function LoggingComponent() {
    this.sendLog = __bind(this.sendLog, this);
    this.outPorts = {
      log: new Port()
    };
  }

  LoggingComponent.prototype.sendLog = function(message) {
    if (typeof message === "object") {
      message.when = new Date;
      message.source = this.constructor.name;
      if (this.nodeId != null) {
        message.nodeID = this.nodeId;
      }
    }
    if ((this.outPorts.log != null) && this.outPorts.log.isAttached()) {
      return this.outPorts.log.send(message);
    } else {
      return console.log(util.inspect(message, 4, true, true));
    }
  };

  return LoggingComponent;

})(Component);

});
require.register("noflo-noflo/src/lib/ComponentLoader.js", function(exports, require, module){
var ComponentLoader, internalSocket, nofloGraph;

internalSocket = require('./InternalSocket');

nofloGraph = require('./Graph');

ComponentLoader = (function() {
  function ComponentLoader(baseDir) {
    this.baseDir = baseDir;
    this.components = null;
    this.checked = [];
    this.revalidate = false;
    this.libraryIcons = {};
  }

  ComponentLoader.prototype.getModulePrefix = function(name) {
    if (!name) {
      return '';
    }
    if (name === 'noflo') {
      return '';
    }
    return name.replace('noflo-', '');
  };

  ComponentLoader.prototype.getModuleComponents = function(moduleName) {
    var cPath, definition, dependency, e, loader, name, prefix, _ref, _ref1, _results;
    if (this.checked.indexOf(moduleName) !== -1) {
      return;
    }
    this.checked.push(moduleName);
    try {
      definition = require("/" + moduleName + "/component.json");
    } catch (_error) {
      e = _error;
      if (moduleName.substr(0, 1) === '/') {
        return this.getModuleComponents("noflo-" + (moduleName.substr(1)));
      }
      return;
    }
    for (dependency in definition.dependencies) {
      this.getModuleComponents(dependency.replace('/', '-'));
    }
    if (!definition.noflo) {
      return;
    }
    prefix = this.getModulePrefix(definition.name);
    if (definition.noflo.icon) {
      this.libraryIcons[prefix] = definition.noflo.icon;
    }
    if (moduleName[0] === '/') {
      moduleName = moduleName.substr(1);
    }
    if (definition.noflo.loader) {
      loader = require("/" + moduleName + "/" + definition.noflo.loader);
      loader(this);
    }
    if (definition.noflo.components) {
      _ref = definition.noflo.components;
      for (name in _ref) {
        cPath = _ref[name];
        if (cPath.indexOf('.coffee') !== -1) {
          cPath = cPath.replace('.coffee', '.js');
        }
        this.registerComponent(prefix, name, "/" + moduleName + "/" + cPath);
      }
    }
    if (definition.noflo.graphs) {
      _ref1 = definition.noflo.graphs;
      _results = [];
      for (name in _ref1) {
        cPath = _ref1[name];
        _results.push(this.registerComponent(prefix, name, "/" + moduleName + "/" + cPath));
      }
      return _results;
    }
  };

  ComponentLoader.prototype.listComponents = function(callback) {
    if (this.components !== null) {
      return callback(this.components);
    }
    this.components = {};
    this.getModuleComponents(this.baseDir);
    return callback(this.components);
  };

  ComponentLoader.prototype.load = function(name, callback, delayed) {
    var component, componentName, implementation, instance;
    if (!this.components) {
      this.listComponents((function(_this) {
        return function(components) {
          return _this.load(name, callback);
        };
      })(this));
      return;
    }
    component = this.components[name];
    if (!component) {
      for (componentName in this.components) {
        if (componentName.split('/')[1] === name) {
          component = this.components[componentName];
          break;
        }
      }
      if (!component) {
        throw new Error("Component " + name + " not available with base " + this.baseDir);
        return;
      }
    }
    if (this.isGraph(component)) {
      if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
        process.nextTick((function(_this) {
          return function() {
            return _this.loadGraph(name, component, callback, delayed);
          };
        })(this));
      } else {
        setTimeout((function(_this) {
          return function() {
            return _this.loadGraph(name, component, callback, delayed);
          };
        })(this), 0);
      }
      return;
    }
    if (typeof component === 'function') {
      implementation = component;
      if (component.getComponent && typeof component.getComponent === 'function') {
        instance = component.getComponent();
      } else {
        instance = component();
      }
    } else if (typeof component === 'object' && typeof component.getComponent === 'function') {
      instance = component.getComponent();
    } else {
      implementation = require(component);
      if (implementation.getComponent && typeof implementation.getComponent === 'function') {
        instance = implementation.getComponent();
      } else {
        instance = implementation();
      }
    }
    if (name === 'Graph') {
      instance.baseDir = this.baseDir;
    }
    this.setIcon(name, instance);
    return callback(instance);
  };

  ComponentLoader.prototype.isGraph = function(cPath) {
    if (typeof cPath === 'object' && cPath instanceof nofloGraph.Graph) {
      return true;
    }
    if (typeof cPath !== 'string') {
      return false;
    }
    return cPath.indexOf('.fbp') !== -1 || cPath.indexOf('.json') !== -1;
  };

  ComponentLoader.prototype.loadGraph = function(name, component, callback, delayed) {
    var delaySocket, graph, graphImplementation, graphSocket;
    graphImplementation = require(this.components['Graph']);
    graphSocket = internalSocket.createSocket();
    graph = graphImplementation.getComponent();
    graph.loader = this;
    graph.baseDir = this.baseDir;
    if (delayed) {
      delaySocket = internalSocket.createSocket();
      graph.inPorts.start.attach(delaySocket);
    }
    graph.inPorts.graph.attach(graphSocket);
    graphSocket.send(component);
    graphSocket.disconnect();
    graph.inPorts.remove('graph');
    graph.inPorts.remove('start');
    this.setIcon(name, graph);
    return callback(graph);
  };

  ComponentLoader.prototype.setIcon = function(name, instance) {
    var componentName, library, _ref;
    if (!instance.getIcon || instance.getIcon()) {
      return;
    }
    _ref = name.split('/'), library = _ref[0], componentName = _ref[1];
    if (componentName && this.getLibraryIcon(library)) {
      instance.setIcon(this.getLibraryIcon(library));
      return;
    }
    if (instance.isSubgraph()) {
      instance.setIcon('sitemap');
      return;
    }
    instance.setIcon('blank');
  };

  ComponentLoader.prototype.getLibraryIcon = function(prefix) {
    if (this.libraryIcons[prefix]) {
      return this.libraryIcons[prefix];
    }
    return null;
  };

  ComponentLoader.prototype.registerComponent = function(packageId, name, cPath, callback) {
    var fullName, prefix;
    prefix = this.getModulePrefix(packageId);
    fullName = "" + prefix + "/" + name;
    if (!packageId) {
      fullName = name;
    }
    this.components[fullName] = cPath;
    if (callback) {
      return callback();
    }
  };

  ComponentLoader.prototype.registerGraph = function(packageId, name, gPath, callback) {
    return this.registerComponent(packageId, name, gPath, callback);
  };

  ComponentLoader.prototype.clear = function() {
    this.components = null;
    this.checked = [];
    return this.revalidate = true;
  };

  return ComponentLoader;

})();

exports.ComponentLoader = ComponentLoader;

});
require.register("noflo-noflo/src/lib/NoFlo.js", function(exports, require, module){
var ports;

exports.graph = require('./Graph');

exports.Graph = exports.graph.Graph;

exports.Network = require('./Network').Network;

exports.isBrowser = require('./Platform').isBrowser;

if (!exports.isBrowser()) {
  exports.ComponentLoader = require('./nodejs/ComponentLoader').ComponentLoader;
} else {
  exports.ComponentLoader = require('./ComponentLoader').ComponentLoader;
}

exports.Component = require('./Component').Component;

exports.AsyncComponent = require('./AsyncComponent').AsyncComponent;

exports.LoggingComponent = require('./LoggingComponent').LoggingComponent;

ports = require('./Ports');

exports.InPorts = ports.InPorts;

exports.OutPorts = ports.OutPorts;

exports.InPort = require('./InPort');

exports.OutPort = require('./OutPort');

exports.Port = require('./Port').Port;

exports.ArrayPort = require('./ArrayPort').ArrayPort;

exports.internalSocket = require('./InternalSocket');

exports.createNetwork = function(graph, callback, delay) {
  var network, networkReady;
  network = new exports.Network(graph);
  networkReady = function(network) {
    if (callback != null) {
      callback(network);
    }
    return network.start();
  };
  if (graph.nodes.length === 0) {
    setTimeout(function() {
      return networkReady(network);
    }, 0);
    return network;
  }
  network.loader.listComponents(function() {
    if (delay) {
      if (callback != null) {
        callback(network);
      }
      return;
    }
    return network.connect(function() {
      return networkReady(network);
    });
  });
  return network;
};

exports.loadFile = function(file, callback) {
  return exports.graph.loadFile(file, function(net) {
    return exports.createNetwork(net, callback);
  });
};

exports.saveFile = function(graph, file, callback) {
  return exports.graph.save(file, function() {
    return callback(file);
  });
};

});
require.register("noflo-noflo/src/lib/Network.js", function(exports, require, module){
var EventEmitter, Network, componentLoader, graph, internalSocket, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

internalSocket = require("./InternalSocket");

graph = require("./Graph");

if (!require('./Platform').isBrowser()) {
  componentLoader = require("./nodejs/ComponentLoader");
  EventEmitter = require('events').EventEmitter;
} else {
  componentLoader = require('./ComponentLoader');
  EventEmitter = require('emitter');
}

Network = (function(_super) {
  __extends(Network, _super);

  Network.prototype.processes = {};

  Network.prototype.connections = [];

  Network.prototype.initials = [];

  Network.prototype.graph = null;

  Network.prototype.startupDate = null;

  Network.prototype.portBuffer = {};

  function Network(graph) {
    this.processes = {};
    this.connections = [];
    this.initials = [];
    this.graph = graph;
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      this.baseDir = graph.baseDir || process.cwd();
    } else {
      this.baseDir = graph.baseDir || '/';
    }
    this.startupDate = new Date();
    if (graph.componentLoader) {
      this.loader = graph.componentLoader;
    } else {
      this.loader = new componentLoader.ComponentLoader(this.baseDir);
    }
  }

  Network.prototype.uptime = function() {
    return new Date() - this.startupDate;
  };

  Network.prototype.connectionCount = 0;

  Network.prototype.increaseConnections = function() {
    if (this.connectionCount === 0) {
      this.emit('start', {
        start: this.startupDate
      });
    }
    return this.connectionCount++;
  };

  Network.prototype.decreaseConnections = function() {
    var ender;
    this.connectionCount--;
    if (this.connectionCount === 0) {
      ender = _.debounce((function(_this) {
        return function() {
          if (_this.connectionCount) {
            return;
          }
          return _this.emit('end', {
            start: _this.startupDate,
            end: new Date,
            uptime: _this.uptime()
          });
        };
      })(this), 10);
      return ender();
    }
  };

  Network.prototype.load = function(component, callback) {
    return this.loader.load(component, callback);
  };

  Network.prototype.addNode = function(node, callback) {
    var process;
    if (this.processes[node.id]) {
      if (callback) {
        callback(this.processes[node.id]);
      }
      return;
    }
    process = {
      id: node.id
    };
    if (!node.component) {
      this.processes[process.id] = process;
      if (callback) {
        callback(process);
      }
      return;
    }
    return this.load(node.component, (function(_this) {
      return function(instance) {
        var name, port, _ref, _ref1;
        instance.nodeId = node.id;
        process.component = instance;
        _ref = process.component.inPorts;
        for (name in _ref) {
          port = _ref[name];
          if (!port || typeof port === 'function' || !port.canAttach) {
            continue;
          }
          port.node = node.id;
          port.nodeInstance = instance;
          port.name = name;
        }
        _ref1 = process.component.outPorts;
        for (name in _ref1) {
          port = _ref1[name];
          if (!port || typeof port === 'function' || !port.canAttach) {
            continue;
          }
          port.node = node.id;
          port.nodeInstance = instance;
          port.name = name;
        }
        if (instance.isSubgraph()) {
          _this.subscribeSubgraph(process);
        }
        _this.subscribeNode(process);
        _this.processes[process.id] = process;
        if (callback) {
          return callback(process);
        }
      };
    })(this));
  };

  Network.prototype.removeNode = function(node) {
    if (!this.processes[node.id]) {
      return;
    }
    this.processes[node.id].component.shutdown();
    return delete this.processes[node.id];
  };

  Network.prototype.renameNode = function(oldId, newId) {
    var name, port, process, _ref, _ref1;
    process = this.getNode(oldId);
    if (!process) {
      return;
    }
    process.id = newId;
    _ref = process.component.inPorts;
    for (name in _ref) {
      port = _ref[name];
      port.node = newId;
    }
    _ref1 = process.component.outPorts;
    for (name in _ref1) {
      port = _ref1[name];
      port.node = newId;
    }
    this.processes[newId] = process;
    return delete this.processes[oldId];
  };

  Network.prototype.getNode = function(id) {
    return this.processes[id];
  };

  Network.prototype.connect = function(done) {
    var edges, initializers, nodes, serialize, subscribeGraph;
    if (done == null) {
      done = function() {};
    }
    serialize = (function(_this) {
      return function(next, add) {
        return function(type) {
          return _this["add" + type](add, function() {
            return next(type);
          });
        };
      };
    })(this);
    subscribeGraph = (function(_this) {
      return function() {
        _this.subscribeGraph();
        return done();
      };
    })(this);
    initializers = _.reduceRight(this.graph.initializers, serialize, subscribeGraph);
    edges = _.reduceRight(this.graph.edges, serialize, function() {
      return initializers("Initial");
    });
    nodes = _.reduceRight(this.graph.nodes, serialize, function() {
      return edges("Edge");
    });
    return nodes("Node");
  };

  Network.prototype.connectPort = function(socket, process, port, inbound) {
    if (inbound) {
      socket.to = {
        process: process,
        port: port
      };
      if (!(process.component.inPorts && process.component.inPorts[port])) {
        throw new Error("No inport '" + port + "' defined in process " + process.id + " (" + (socket.getId()) + ")");
        return;
      }
      return process.component.inPorts[port].attach(socket);
    }
    socket.from = {
      process: process,
      port: port
    };
    if (!(process.component.outPorts && process.component.outPorts[port])) {
      throw new Error("No outport '" + port + "' defined in process " + process.id + " (" + (socket.getId()) + ")");
      return;
    }
    return process.component.outPorts[port].attach(socket);
  };

  Network.prototype.subscribeGraph = function() {
    this.graph.on('addNode', (function(_this) {
      return function(node) {
        return _this.addNode(node);
      };
    })(this));
    this.graph.on('removeNode', (function(_this) {
      return function(node) {
        return _this.removeNode(node);
      };
    })(this));
    this.graph.on('renameNode', (function(_this) {
      return function(oldId, newId) {
        return _this.renameNode(oldId, newId);
      };
    })(this));
    this.graph.on('addEdge', (function(_this) {
      return function(edge) {
        return _this.addEdge(edge);
      };
    })(this));
    this.graph.on('removeEdge', (function(_this) {
      return function(edge) {
        return _this.removeEdge(edge);
      };
    })(this));
    this.graph.on('addInitial', (function(_this) {
      return function(iip) {
        return _this.addInitial(iip);
      };
    })(this));
    return this.graph.on('removeInitial', (function(_this) {
      return function(iip) {
        return _this.removeInitial(iip);
      };
    })(this));
  };

  Network.prototype.subscribeSubgraph = function(node) {
    var emitSub;
    if (!node.component.isReady()) {
      node.component.once('ready', (function(_this) {
        return function() {
          _this.subscribeSubgraph(node);
        };
      })(this));
    }
    if (!node.component.network) {
      return;
    }
    emitSub = (function(_this) {
      return function(type, data) {
        if (type === 'connect') {
          _this.increaseConnections();
        }
        if (type === 'disconnect') {
          _this.decreaseConnections();
        }
        if (!data) {
          data = {};
        }
        if (data.subgraph) {
          data.subgraph = "" + node.id + ":" + data.subgraph;
        } else {
          data.subgraph = node.id;
        }
        return _this.emit(type, data);
      };
    })(this);
    node.component.network.on('connect', function(data) {
      return emitSub('connect', data);
    });
    node.component.network.on('begingroup', function(data) {
      return emitSub('begingroup', data);
    });
    node.component.network.on('data', function(data) {
      return emitSub('data', data);
    });
    node.component.network.on('endgroup', function(data) {
      return emitSub('endgroup', data);
    });
    return node.component.network.on('disconnect', function(data) {
      return emitSub('disconnect', data);
    });
  };

  Network.prototype.subscribeSocket = function(socket) {
    socket.on('connect', (function(_this) {
      return function() {
        _this.increaseConnections();
        return _this.emit('connect', {
          id: socket.getId(),
          socket: socket
        });
      };
    })(this));
    socket.on('begingroup', (function(_this) {
      return function(group) {
        return _this.emit('begingroup', {
          id: socket.getId(),
          socket: socket,
          group: group
        });
      };
    })(this));
    socket.on('data', (function(_this) {
      return function(data) {
        return _this.emit('data', {
          id: socket.getId(),
          socket: socket,
          data: data
        });
      };
    })(this));
    socket.on('endgroup', (function(_this) {
      return function(group) {
        return _this.emit('endgroup', {
          id: socket.getId(),
          socket: socket,
          group: group
        });
      };
    })(this));
    return socket.on('disconnect', (function(_this) {
      return function() {
        _this.decreaseConnections();
        return _this.emit('disconnect', {
          id: socket.getId(),
          socket: socket
        });
      };
    })(this));
  };

  Network.prototype.subscribeNode = function(node) {
    if (!node.component.getIcon) {
      return;
    }
    return node.component.on('icon', (function(_this) {
      return function() {
        return _this.emit('icon', {
          id: node.id,
          icon: node.component.getIcon()
        });
      };
    })(this));
  };

  Network.prototype.addEdge = function(edge, callback) {
    var from, socket, to;
    socket = internalSocket.createSocket();
    from = this.getNode(edge.from.node);
    if (!from) {
      throw new Error("No process defined for outbound node " + edge.from.node);
    }
    if (!from.component) {
      throw new Error("No component defined for outbound node " + edge.from.node);
    }
    if (!from.component.isReady()) {
      from.component.once("ready", (function(_this) {
        return function() {
          return _this.addEdge(edge, callback);
        };
      })(this));
      return;
    }
    to = this.getNode(edge.to.node);
    if (!to) {
      throw new Error("No process defined for inbound node " + edge.to.node);
    }
    if (!to.component) {
      throw new Error("No component defined for inbound node " + edge.to.node);
    }
    if (!to.component.isReady()) {
      to.component.once("ready", (function(_this) {
        return function() {
          return _this.addEdge(edge, callback);
        };
      })(this));
      return;
    }
    this.connectPort(socket, to, edge.to.port, true);
    this.connectPort(socket, from, edge.from.port, false);
    this.subscribeSocket(socket);
    this.connections.push(socket);
    if (callback) {
      return callback();
    }
  };

  Network.prototype.removeEdge = function(edge) {
    var connection, _i, _len, _ref, _results;
    _ref = this.connections;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      if (!connection) {
        continue;
      }
      if (!(edge.to.node === connection.to.process.id && edge.to.port === connection.to.port)) {
        continue;
      }
      connection.to.process.component.inPorts[connection.to.port].detach(connection);
      if (edge.from.node) {
        if (connection.from && edge.from.node === connection.from.process.id && edge.from.port === connection.from.port) {
          connection.from.process.component.outPorts[connection.from.port].detach(connection);
        }
      }
      _results.push(this.connections.splice(this.connections.indexOf(connection), 1));
    }
    return _results;
  };

  Network.prototype.addInitial = function(initializer, callback) {
    var socket, to;
    socket = internalSocket.createSocket();
    this.subscribeSocket(socket);
    to = this.getNode(initializer.to.node);
    if (!to) {
      throw new Error("No process defined for inbound node " + initializer.to.node);
    }
    if (!(to.component.isReady() || to.component.inPorts[initializer.to.port])) {
      to.component.setMaxListeners(0);
      to.component.once("ready", (function(_this) {
        return function() {
          return _this.addInitial(initializer, callback);
        };
      })(this));
      return;
    }
    this.connectPort(socket, to, initializer.to.port, true);
    this.connections.push(socket);
    this.initials.push({
      socket: socket,
      data: initializer.from.data
    });
    if (callback) {
      return callback();
    }
  };

  Network.prototype.removeInitial = function(initializer) {
    var connection, _i, _len, _ref, _results;
    _ref = this.connections;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      if (!connection) {
        continue;
      }
      if (!(initializer.to.node === connection.to.process.id && initializer.to.port === connection.to.port)) {
        continue;
      }
      connection.to.process.component.inPorts[connection.to.port].detach(connection);
      _results.push(this.connections.splice(this.connections.indexOf(connection), 1));
    }
    return _results;
  };

  Network.prototype.sendInitial = function(initial) {
    initial.socket.connect();
    initial.socket.send(initial.data);
    return initial.socket.disconnect();
  };

  Network.prototype.sendInitials = function() {
    var send;
    send = (function(_this) {
      return function() {
        var initial, _i, _len, _ref;
        _ref = _this.initials;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          initial = _ref[_i];
          _this.sendInitial(initial);
        }
        return _this.initials = [];
      };
    })(this);
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      return process.nextTick(send);
    } else {
      return setTimeout(send, 0);
    }
  };

  Network.prototype.start = function() {
    return this.sendInitials();
  };

  Network.prototype.stop = function() {
    var connection, id, process, _i, _len, _ref, _ref1, _results;
    _ref = this.connections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      if (!connection.isConnected()) {
        continue;
      }
      connection.disconnect();
    }
    _ref1 = this.processes;
    _results = [];
    for (id in _ref1) {
      process = _ref1[id];
      _results.push(process.component.shutdown());
    }
    return _results;
  };

  return Network;

})(EventEmitter);

exports.Network = Network;

});
require.register("noflo-noflo/src/lib/Platform.js", function(exports, require, module){
exports.isBrowser = function() {
  if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
    return false;
  }
  return true;
};

});
require.register("noflo-noflo/src/lib/Journal.js", function(exports, require, module){
var EventEmitter, Journal, entryToPrettyString,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

entryToPrettyString = function(entry) {
  var a;
  a = entry.args;
  switch (entry.cmd) {
    case 'addNode':
      return "" + a.id + "(" + a.component + ")";
    case 'removeNode':
      return "DEL " + a.id + "(" + a.component + ")";
    case 'renameNode':
      return "RENAME " + a.oldId + " " + a.newId;
    case 'addEdge':
      return "" + a.from.node + " " + a.from.port + " -> " + a.to.port + " " + a.to.node;
    case 'removeEdge':
      return "" + a.from.node + " " + a.from.port + " -X> " + a.to.port + " " + a.to.node;
    case 'addInitial':
      return "'" + a.from.data + "' -> " + a.to.port + " " + a.to.node;
    case 'removeInitial':
      return "'" + a.from.data + "' -X> " + a.to.port + " " + a.to.node;
    case 'startTransaction':
      return ">>> " + entry.rev + ": " + a.id;
    case 'endTransaction':
      return "<<< " + entry.rev + ": " + a.id;
    default:
      throw new Error("Unknown journal entry: " + entry.cmd);
  }
};

Journal = (function(_super) {
  __extends(Journal, _super);

  Journal.prototype.graph = null;

  Journal.prototype.entries = [];

  Journal.prototype.subscribed = true;

  function Journal(graph) {
    var edge, ipp, node, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    this.graph = graph;
    this.entries = [];
    this.subscribed = true;
    this.lastRevision = 0;
    this.currentRevision = this.lastRevision;
    this.appendCommand('startTransaction', {
      id: 'initial',
      metadata: null
    });
    _ref = this.graph.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      this.appendCommand('addNode', node);
    }
    _ref1 = this.graph.edges;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      edge = _ref1[_j];
      this.appendCommand('addEdge', edge);
    }
    _ref2 = this.graph.initializers;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      ipp = _ref2[_k];
      this.appendCommand('addIntitial', iip);
    }
    this.appendCommand('endTransaction', {
      id: 'initial',
      metadata: null
    });
    this.graph.on('addNode', (function(_this) {
      return function(node) {
        return _this.appendCommand('addNode', node);
      };
    })(this));
    this.graph.on('removeNode', (function(_this) {
      return function(node) {
        return _this.appendCommand('removeNode', node);
      };
    })(this));
    this.graph.on('renameNode', (function(_this) {
      return function(oldId, newId) {
        var args;
        args = {
          oldId: oldId,
          newId: newId
        };
        return _this.appendCommand('renameNode', args);
      };
    })(this));
    this.graph.on('addEdge', (function(_this) {
      return function(edge) {
        return _this.appendCommand('addEdge', edge);
      };
    })(this));
    this.graph.on('removeEdge', (function(_this) {
      return function(edge) {
        return _this.appendCommand('removeEdge', edge);
      };
    })(this));
    this.graph.on('addInitial', (function(_this) {
      return function(iip) {
        return _this.appendCommand('addInitial', iip);
      };
    })(this));
    this.graph.on('removeInitial', (function(_this) {
      return function(iip) {
        return _this.appendCommand('removeInitial', iip);
      };
    })(this));
    this.graph.on('startTransaction', (function(_this) {
      return function(id, meta) {
        if (!_this.subscribed) {
          return;
        }
        _this.lastRevision++;
        _this.currentRevision = _this.lastRevision;
        return _this.appendCommand('startTransaction', {
          id: id,
          metadata: meta
        });
      };
    })(this));
    this.graph.on('endTransaction', (function(_this) {
      return function(id, meta) {
        return _this.appendCommand('endTransaction', {
          id: id,
          metadata: meta
        });
      };
    })(this));
  }

  Journal.prototype.appendCommand = function(cmd, args) {
    var entry;
    if (!this.subscribed) {
      return;
    }
    entry = {
      cmd: cmd,
      args: args,
      rev: this.lastRevision
    };
    return this.entries.push(entry);
  };

  Journal.prototype.executeEntry = function(entry) {
    var a;
    a = entry.args;
    switch (entry.cmd) {
      case 'addNode':
        return this.graph.addNode(a.id, a.component);
      case 'removeNode':
        return this.graph.removeNode(a.id);
      case 'renameNode':
        return this.graph.renameNode(a.oldId, a.newId);
      case 'addEdge':
        return this.graph.addEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'removeEdge':
        return this.graph.removeEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'addInitial':
        return this.graph.addInitial(a.from.data, a.to.node, a.to.port);
      case 'removeInitial':
        return this.graph.removeInitial(a.to.node, a.to.port);
      case 'startTransaction':
        return null;
      case 'endTransaction':
        return null;
      default:
        throw new Error("Unknown journal entry: " + entry.cmd);
    }
  };

  Journal.prototype.executeEntryInversed = function(entry) {
    var a;
    a = entry.args;
    switch (entry.cmd) {
      case 'addNode':
        return this.graph.removeNode(a.id);
      case 'removeNode':
        return this.graph.addNode(a.id, a.component);
      case 'renameNode':
        return this.graph.renameNode(a.newId, a.oldId);
      case 'addEdge':
        return this.graph.removeEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'removeEdge':
        return this.graph.addEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'addInitial':
        return this.graph.removeInitial(a.to.node, a.to.port);
      case 'removeInitial':
        return this.graph.addInitial(a.from.data, a.to.node, a.to.port);
      case 'startTransaction':
        return null;
      case 'endTransaction':
        return null;
      default:
        throw new Error("Unknown journal entry: " + entry.cmd);
    }
  };

  Journal.prototype.moveToRevision = function(revId) {
    var entry, i, _i, _len, _ref;
    if (revId === this.currentRevision) {
      return;
    }
    this.subscribed = false;
    if (revId > this.currentRevision) {
      _ref = this.entries;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entry = _ref[_i];
        if (entry.rev <= this.currentRevision) {
          continue;
        }
        if (entry.rev > revId) {
          break;
        }
        this.executeEntry(entry);
      }
    } else {
      i = this.entries.length;
      while (i > 0) {
        i--;
        entry = this.entries[i];
        if (entry.rev > this.currentRevision) {
          continue;
        }
        if (entry.rev === revId) {
          break;
        }
        this.executeEntryInversed(entry);
      }
    }
    this.currentRevision = revId;
    return this.subscribed = true;
  };

  Journal.prototype.undo = function() {
    if (!(this.currentRevision > 0)) {
      return;
    }
    return this.moveToRevision(this.currentRevision - 1);
  };

  Journal.prototype.redo = function() {
    if (!(this.currentRevision < this.lastRevision)) {
      return;
    }
    return this.moveToRevision(this.currentRevision + 1);
  };

  Journal.prototype.toPrettyString = function() {
    var entry, lines;
    lines = (function() {
      var _i, _len, _ref, _results;
      _ref = this.entries;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entry = _ref[_i];
        _results.push(entryToPrettyString(entry));
      }
      return _results;
    }).call(this);
    return lines.join('\n');
  };

  Journal.prototype.toJSON = function() {
    return this.entries;
  };

  Journal.prototype.save = function(file, success) {
    var json;
    json = JSON.stringify(this.toJSON(), null, 4);
    return require('fs').writeFile("" + file + ".json", json, "utf-8", function(err, data) {
      if (err) {
        throw err;
      }
      return success(file);
    });
  };

  return Journal;

})(EventEmitter);

exports.Journal = Journal;

});
require.register("noflo-noflo/src/components/Graph.js", function(exports, require, module){
var Graph, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
  noflo = require("../../lib/NoFlo");
} else {
  noflo = require('../lib/NoFlo');
}

Graph = (function(_super) {
  __extends(Graph, _super);

  function Graph() {
    this.network = null;
    this.ready = true;
    this.started = false;
    this.baseDir = null;
    this.loader = null;
    this.inPorts = new noflo.InPorts({
      graph: {
        datatype: 'all',
        description: 'NoFlo graph definition to be used with the subgraph component',
        required: true,
        immediate: true
      },
      start: {
        datatype: 'bang',
        description: 'if attached, the network will only be started when receiving a start message',
        required: false
      }
    });
    this.outPorts = new noflo.OutPorts;
    this.inPorts.on('graph', 'data', (function(_this) {
      return function(data) {
        return _this.setGraph(data);
      };
    })(this));
    this.inPorts.on('start', 'data', (function(_this) {
      return function() {
        _this.started = true;
        if (!_this.network) {
          return;
        }
        return _this.network.sendInitials();
      };
    })(this));
  }

  Graph.prototype.setGraph = function(graph) {
    this.ready = false;
    if (typeof graph === 'object') {
      if (typeof graph.addNode === 'function') {
        return this.createNetwork(graph);
      }
      noflo.graph.loadJSON(graph, (function(_this) {
        return function(instance) {
          instance.baseDir = _this.baseDir;
          return _this.createNetwork(instance);
        };
      })(this));
      return;
    }
    if (graph.substr(0, 1) !== "/" && graph.substr(1, 1) !== ":" && process && process.cwd) {
      graph = "" + (process.cwd()) + "/" + graph;
    }
    return graph = noflo.graph.loadFile(graph, (function(_this) {
      return function(instance) {
        instance.baseDir = _this.baseDir;
        return _this.createNetwork(instance);
      };
    })(this));
  };

  Graph.prototype.createNetwork = function(graph) {
    var _ref;
    graph.componentLoader = this.loader;
    if (((_ref = this.inPorts.start) != null ? _ref.isAttached() : void 0) && !this.started) {
      noflo.createNetwork(graph, (function(_this) {
        return function(network) {
          _this.network = network;
          _this.emit('network', _this.network);
          return _this.network.connect(function() {
            var name, notReady, process, _ref1;
            notReady = false;
            _ref1 = _this.network.processes;
            for (name in _ref1) {
              process = _ref1[name];
              if (!_this.checkComponent(name, process)) {
                notReady = true;
              }
            }
            if (!notReady) {
              return _this.setToReady();
            }
          });
        };
      })(this), true);
      return;
    }
    return noflo.createNetwork(graph, (function(_this) {
      return function(network) {
        var name, notReady, process, _ref1;
        _this.network = network;
        _this.emit('network', _this.network);
        notReady = false;
        _ref1 = _this.network.processes;
        for (name in _ref1) {
          process = _ref1[name];
          if (!_this.checkComponent(name, process)) {
            notReady = true;
          }
        }
        if (!notReady) {
          return _this.setToReady();
        }
      };
    })(this));
  };

  Graph.prototype.checkComponent = function(name, process) {
    if (!process.component.isReady()) {
      process.component.once("ready", (function(_this) {
        return function() {
          _this.checkComponent(name, process);
          return _this.setToReady();
        };
      })(this));
      return false;
    }
    this.findEdgePorts(name, process);
    return true;
  };

  Graph.prototype.isExportedInport = function(port, nodeName, portName) {
    var exported, priv, pub, _i, _len, _ref, _ref1;
    _ref = this.network.graph.inports;
    for (pub in _ref) {
      priv = _ref[pub];
      if (!(priv.process === nodeName && priv.port === portName)) {
        continue;
      }
      return pub;
    }
    _ref1 = this.network.graph.exports;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      exported = _ref1[_i];
      if (!(exported.process === nodeName && exported.port === portName)) {
        continue;
      }
      this.network.graph.checkTransactionStart();
      this.network.graph.removeExport(exported["public"]);
      this.network.graph.addInport(exported["public"], exported.process, exported.port, exported.metadata);
      this.network.graph.checkTransactionEnd();
      return exported["public"];
    }
    if (port.isAttached()) {
      return false;
    }
    return (nodeName + '.' + portName).toLowerCase();
  };

  Graph.prototype.isExportedOutport = function(port, nodeName, portName) {
    var exported, priv, pub, _i, _len, _ref, _ref1;
    _ref = this.network.graph.outports;
    for (pub in _ref) {
      priv = _ref[pub];
      if (!(priv.process === nodeName && priv.port === portName)) {
        continue;
      }
      return pub;
    }
    _ref1 = this.network.graph.exports;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      exported = _ref1[_i];
      if (!(exported.process === nodeName && exported.port === portName)) {
        continue;
      }
      this.network.graph.checkTransactionStart();
      this.network.graph.removeExport(exported["public"]);
      this.network.graph.addOutport(exported["public"], exported.process, exported.port, exported.metadata);
      this.network.graph.checkTransactionEnd();
      return exported["public"];
    }
    if (port.isAttached()) {
      return false;
    }
    return (nodeName + '.' + portName).toLowerCase();
  };

  Graph.prototype.setToReady = function() {
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      return process.nextTick((function(_this) {
        return function() {
          _this.ready = true;
          return _this.emit('ready');
        };
      })(this));
    } else {
      return setTimeout((function(_this) {
        return function() {
          _this.ready = true;
          return _this.emit('ready');
        };
      })(this), 0);
    }
  };

  Graph.prototype.findEdgePorts = function(name, process) {
    var port, portName, targetPortName, _ref, _ref1;
    _ref = process.component.inPorts;
    for (portName in _ref) {
      port = _ref[portName];
      if (!port || typeof port === 'function' || !port.canAttach) {
        continue;
      }
      targetPortName = this.isExportedInport(port, name, portName);
      if (targetPortName === false) {
        continue;
      }
      this.inPorts.add(targetPortName, port);
    }
    _ref1 = process.component.outPorts;
    for (portName in _ref1) {
      port = _ref1[portName];
      if (!port || typeof port === 'function' || !port.canAttach) {
        continue;
      }
      targetPortName = this.isExportedOutport(port, name, portName);
      if (targetPortName === false) {
        continue;
      }
      this.outPorts.add(targetPortName, port);
    }
    return true;
  };

  Graph.prototype.isReady = function() {
    return this.ready;
  };

  Graph.prototype.isSubgraph = function() {
    return true;
  };

  Graph.prototype.shutdown = function() {
    if (!this.network) {
      return;
    }
    return this.network.stop();
  };

  return Graph;

})(noflo.Component);

exports.getComponent = function() {
  return new Graph;
};

});
require.register("noflo-noflo-runtime-base/src/Base.js", function(exports, require, module){
var BaseTransport, protocols;

protocols = {
  Graph: require('./protocol/Graph'),
  Network: require('./protocol/Network'),
  Component: require('./protocol/Component')
};

BaseTransport = (function() {
  function BaseTransport(options) {
    this.options = options;
    if (!this.options) {
      this.options = {};
    }
    this.graph = new protocols.Graph(this);
    this.network = new protocols.Network(this);
    this.component = new protocols.Component(this);
    this.context = null;
  }

  BaseTransport.prototype.send = function(protocol, topic, payload, context) {};

  BaseTransport.prototype.receive = function(protocol, topic, payload, context) {
    this.context = context;
    switch (protocol) {
      case 'graph':
        return this.graph.receive(topic, payload, context);
      case 'network':
        return this.network.receive(topic, payload, context);
      case 'component':
        return this.component.receive(topic, payload, context);
    }
  };

  return BaseTransport;

})();

module.exports = BaseTransport;

});
require.register("noflo-noflo-runtime-base/src/protocol/Graph.js", function(exports, require, module){
var GraphProtocol, noflo;

noflo = require('noflo');

GraphProtocol = (function() {
  function GraphProtocol(transport) {
    this.transport = transport;
    this.graphs = {};
  }

  GraphProtocol.prototype.send = function(topic, payload, context) {
    return this.transport.send('graph', topic, payload, context);
  };

  GraphProtocol.prototype.receive = function(topic, payload, context) {
    var graph;
    if (topic !== 'clear') {
      graph = this.resolveGraph(payload, context);
      if (!graph) {
        return;
      }
    }
    switch (topic) {
      case 'clear':
        return this.initGraph(payload, context);
      case 'addnode':
        return this.addNode(graph, payload, context);
      case 'removenode':
        return this.removeNode(graph, payload, context);
      case 'renamenode':
        return this.renameNode(graph, payload, context);
      case 'addedge':
        return this.addEdge(graph, payload, context);
      case 'removeedge':
        return this.removeEdge(graph, payload, context);
      case 'addinitial':
        return this.addInitial(graph, payload, context);
      case 'removeinitial':
        return this.removeInitial(graph, payload, context);
      case 'addinport':
        return this.addInport(graph, payload, context);
      case 'removeinport':
        return this.removeInport(graph, payload, context);
      case 'addoutport':
        return this.addOutport(graph, payload, context);
      case 'removeoutport':
        return this.removeOutport(graph, payload, context);
    }
  };

  GraphProtocol.prototype.resolveGraph = function(payload, context) {
    if (!payload.graph) {
      this.send('error', new Error('No graph specified'), context);
      return;
    }
    if (!this.graphs[payload.graph]) {
      this.send('error', new Error('Requested graph not found'), context);
      return;
    }
    return this.graphs[payload.graph];
  };

  GraphProtocol.prototype.initGraph = function(payload, context) {
    var fullName, graph;
    if (!payload.id) {
      this.send('error', new Error('No graph ID provided'), context);
      return;
    }
    if (!payload.name) {
      payload.name = 'NoFlo runtime';
    }
    graph = new noflo.Graph(payload.name);
    fullName = payload.id;
    if (payload.library) {
      graph.properties.library = payload.library;
      fullName = "" + payload.library + "/" + fullName;
    }
    graph.baseDir = this.transport.options.baseDir;
    this.subscribeGraph(payload.id, graph, context);
    if (!payload.main) {
      this.transport.component.registerGraph(fullName, graph, context);
    }
    return this.graphs[payload.id] = graph;
  };

  GraphProtocol.prototype.subscribeGraph = function(id, graph, context) {
    graph.on('addNode', (function(_this) {
      return function(node) {
        node.graph = id;
        return _this.send('addnode', node, context);
      };
    })(this));
    graph.on('removeNode', (function(_this) {
      return function(node) {
        node.graph = id;
        return _this.send('removenode', node, context);
      };
    })(this));
    graph.on('renameNode', (function(_this) {
      return function(oldId, newId) {
        return _this.send('renamenode', {
          from: oldId,
          to: newId,
          graph: id
        }, context);
      };
    })(this));
    graph.on('addEdge', (function(_this) {
      return function(edge) {
        var edgeData;
        edgeData = {
          src: edge.from,
          tgt: edge.to,
          metadata: edge.metadata,
          graph: id
        };
        return _this.send('addedge', edgeData, context);
      };
    })(this));
    graph.on('removeEdge', (function(_this) {
      return function(edge) {
        var edgeData;
        edgeData = {
          src: edge.from,
          tgt: edge.to,
          metadata: edge.metadata,
          graph: id
        };
        return _this.send('removeedge', edgeData, context);
      };
    })(this));
    graph.on('addInitial', (function(_this) {
      return function(iip) {
        var iipData;
        iipData = {
          src: iip.from,
          tgt: iip.to,
          metadata: iip.metadata,
          graph: id
        };
        return _this.send('addinitial', iipData, context);
      };
    })(this));
    return graph.on('removeInitial', (function(_this) {
      return function(iip) {
        var iipData;
        iipData = {
          src: iip.from,
          tgt: iip.to,
          metadata: iip.metadata,
          graph: id
        };
        return _this.send('removeinitial', iipData, context);
      };
    })(this));
  };

  GraphProtocol.prototype.addNode = function(graph, node, context) {
    if (!(node.id || node.component)) {
      this.send('error', new Error('No ID or component supplied'), context);
      return;
    }
    return graph.addNode(node.id, node.component, node.metadata);
  };

  GraphProtocol.prototype.removeNode = function(graph, payload) {
    if (!payload.id) {
      this.send('error', new Error('No ID supplied'), context);
      return;
    }
    return graph.removeNode(payload.id);
  };

  GraphProtocol.prototype.renameNode = function(graph, payload, context) {
    if (!(payload.from || payload.to)) {
      this.send('error', new Error('No from or to supplied'), context);
      return;
    }
    return graph.renameNode(payload.from, payload.to);
  };

  GraphProtocol.prototype.addEdge = function(graph, edge, context) {
    if (!(edge.src || edge.tgt)) {
      this.send('error', new Error('No src or tgt supplied'), context);
      return;
    }
    return graph.addEdge(edge.src.node, edge.src.port, edge.tgt.node, edge.tgt.port, edge.metadata);
  };

  GraphProtocol.prototype.removeEdge = function(graph, edge, context) {
    if (!(edge.src || edge.tgt)) {
      this.send('error', new Error('No src or tgt supplied'), context);
      return;
    }
    return graph.removeEdge(edge.src.node, edge.src.port, edge.tgt.node, edge.tgt.port);
  };

  GraphProtocol.prototype.addInitial = function(graph, payload, context) {
    if (!(payload.src || payload.tgt)) {
      this.send('error', new Error('No src or tgt supplied'), context);
      return;
    }
    return graph.addInitial(payload.src.data, payload.tgt.node, payload.tgt.port, payload.metadata);
  };

  GraphProtocol.prototype.removeInitial = function(graph, payload, context) {
    if (!payload.tgt) {
      this.send('error', new Error('No tgt supplied'), context);
      return;
    }
    return graph.removeInitial(payload.tgt.node, payload.tgt.port);
  };

  GraphProtocol.prototype.addInport = function(graph, payload, context) {
    if (!(payload["public"] || payload.node || payload.port)) {
      this.send('error', new Error('Missing exported inport information'), context);
      return;
    }
    return graph.addInport(payload["public"], payload.node, payload.port, payload.metadata);
  };

  GraphProtocol.prototype.removeInport = function(graph, payload, context) {
    if (!payload["public"]) {
      this.send('error', new Error('Missing exported inport name'), context);
      return;
    }
    return graph.removeInport(payload["public"]);
  };

  GraphProtocol.prototype.addOutport = function(graph, payload, context) {
    if (!(payload["public"] || payload.node || payload.port)) {
      this.send('error', new Error('Missing exported outport information'), context);
      return;
    }
    return graph.addOutport(payload["public"], payload.node, payload.port, payload.metadata);
  };

  GraphProtocol.prototype.removeOutport = function(graph, payload, context) {
    if (!payload["public"]) {
      this.send('error', new Error('Missing exported outport name'), context);
      return;
    }
    return graph.removeOutport(payload["public"]);
  };

  return GraphProtocol;

})();

module.exports = GraphProtocol;

});
require.register("noflo-noflo-runtime-base/src/protocol/Network.js", function(exports, require, module){
var NetworkProtocol, noflo, prepareSocketEvent;

noflo = require('noflo');

prepareSocketEvent = function(event, req) {
  var payload;
  payload = {
    id: event.id,
    graph: req.graph
  };
  if (event.socket.from) {
    payload.src = {
      node: event.socket.from.process.id,
      port: event.socket.from.port
    };
  }
  if (event.socket.to) {
    payload.tgt = {
      node: event.socket.to.process.id,
      port: event.socket.to.port
    };
  }
  if (event.group) {
    payload.group = event.group;
  }
  if (event.data) {
    if (event.data.toJSON) {
      payload.data = event.data.toJSON();
    }
    if (event.data.toString) {
      payload.data = event.data.toString();
      if (payload.data === '[object Object]') {
        try {
          payload.data = JSON.parse(JSON.stringify(event.data));
        } catch (_error) {}
      }
    } else {
      payload.data = event.data;
    }
  }
  if (event.subgraph) {
    payload.subgraph = event.subgraph;
  }
  return payload;
};

NetworkProtocol = (function() {
  function NetworkProtocol(transport) {
    this.transport = transport;
    this.networks = {};
  }

  NetworkProtocol.prototype.send = function(topic, payload, context) {
    return this.transport.send('network', topic, payload, context);
  };

  NetworkProtocol.prototype.receive = function(topic, payload, context) {
    var graph;
    graph = this.resolveGraph(payload, context);
    if (!graph) {
      return;
    }
    switch (topic) {
      case 'start':
        return this.initNetwork(graph, payload, context);
      case 'stop':
        return this.stopNetwork(graph, payload, context);
    }
  };

  NetworkProtocol.prototype.resolveGraph = function(payload, context) {
    if (!payload.graph) {
      this.send('error', new Error('No graph specified'), context);
      return;
    }
    if (!this.transport.graph.graphs[payload.graph]) {
      this.send('error', new Error('Requested graph not found'), context);
      return;
    }
    return this.transport.graph.graphs[payload.graph];
  };

  NetworkProtocol.prototype.initNetwork = function(graph, payload, context) {
    graph.componentLoader = this.transport.component.getLoader(graph.baseDir);
    return noflo.createNetwork(graph, (function(_this) {
      return function(network) {
        _this.networks[payload.graph] = network;
        _this.subscribeNetwork(network, payload, context);
        return network.connect(function() {
          network.sendInitials();
          return graph.on('addInitial', function() {
            return network.sendInitials();
          });
        });
      };
    })(this), true);
  };

  NetworkProtocol.prototype.subscribeNetwork = function(network, payload, context) {
    network.on('start', (function(_this) {
      return function(event) {
        return _this.send('started', {
          time: event.start,
          graph: payload.graph
        }, context);
      };
    })(this));
    network.on('icon', (function(_this) {
      return function(event) {
        event.graph = payload.graph;
        return _this.send('icon', event, context);
      };
    })(this));
    network.on('connect', (function(_this) {
      return function(event) {
        return _this.send('connect', prepareSocketEvent(event, payload), context);
      };
    })(this));
    network.on('begingroup', (function(_this) {
      return function(event) {
        return _this.send('begingroup', prepareSocketEvent(event, payload), context);
      };
    })(this));
    network.on('data', (function(_this) {
      return function(event) {
        return _this.send('data', prepareSocketEvent(event, payload), context);
      };
    })(this));
    network.on('endgroup', (function(_this) {
      return function(event) {
        return _this.send('endgroup', prepareSocketEvent(event, payload), context);
      };
    })(this));
    network.on('disconnect', (function(_this) {
      return function(event) {
        return _this.send('disconnect', prepareSocketEvent(event, payload), context);
      };
    })(this));
    return network.on('end', (function(_this) {
      return function(event) {
        return _this.send('stopped', {
          time: new Date,
          uptime: event.uptime,
          graph: payload.graph
        }, context);
      };
    })(this));
  };

  NetworkProtocol.prototype.stopNetwork = function(graph, payload, context) {
    if (!this.networks[payload.graph]) {
      return;
    }
    return this.networks[payload.graph].stop();
  };

  return NetworkProtocol;

})();

module.exports = NetworkProtocol;

});
require.register("noflo-noflo-runtime-base/src/protocol/Component.js", function(exports, require, module){
var ComponentProtocol, noflo;

noflo = require('noflo');

ComponentProtocol = (function() {
  ComponentProtocol.prototype.loaders = {};

  function ComponentProtocol(transport) {
    this.transport = transport;
  }

  ComponentProtocol.prototype.send = function(topic, payload, context) {
    return this.transport.send('component', topic, payload, context);
  };

  ComponentProtocol.prototype.receive = function(topic, payload, context) {
    switch (topic) {
      case 'list':
        return this.listComponents(payload, context);
      case 'getsource':
        return this.getSource(payload, context);
      case 'source':
        return this.setSource(payload, context);
    }
  };

  ComponentProtocol.prototype.getLoader = function(baseDir) {
    if (!this.loaders[baseDir]) {
      this.loaders[baseDir] = new noflo.ComponentLoader(baseDir);
    }
    return this.loaders[baseDir];
  };

  ComponentProtocol.prototype.listComponents = function(payload, context) {
    var baseDir, loader;
    baseDir = this.transport.options.baseDir;
    loader = this.getLoader(baseDir);
    return loader.listComponents((function(_this) {
      return function(components) {
        return Object.keys(components).forEach(function(component) {
          return _this.processComponent(loader, component, context);
        });
      };
    })(this));
  };

  ComponentProtocol.prototype.getSource = function(payload, context) {};

  ComponentProtocol.prototype.setSource = function(payload, context) {
    var e, fullName, implementation, library, source;
    source = payload.code;
    if (payload.language === 'coffeescript') {
      if (!window.CoffeeScript) {
        return;
      }
      try {
        source = CoffeeScript.compile(payload.code, {
          bare: true
        });
      } catch (_error) {
        e = _error;
        this.send('error', new Error("" + payload.name + " L" + e.location.first_line + ", C" + e.location.first_column + ": " + e.message), context);
        return;
      }
    }
    implementation = eval("(function () { var exports = {}; " + source + "; return exports; })()");
    if (!(implementation || implementation.getComponent)) {
      this.send('error', new Error("" + payload.name + ": No component implementation available"), context);
      return;
    }
    library = payload.library ? payload.library : '';
    fullName = payload.name;
    if (library) {
      fullName = "" + library + "/" + fullName;
    }
    return Object.keys(this.loaders).forEach((function(_this) {
      return function(baseDir) {
        var loader;
        loader = _this.getLoader(baseDir);
        return loader.listComponents(function(components) {
          loader.registerComponent(library, payload.name, implementation);
          return _this.processComponent(loader, fullName, context);
        });
      };
    })(this));
  };

  ComponentProtocol.prototype.processComponent = function(loader, component, context) {
    return loader.load(component, (function(_this) {
      return function(instance) {
        if (!instance.isReady()) {
          instance.once('ready', function() {
            return _this.sendComponent(component, instance, context);
          });
          return;
        }
        return _this.sendComponent(component, instance, context);
      };
    })(this), true);
  };

  ComponentProtocol.prototype.sendComponent = function(component, instance, context) {
    var icon, inPorts, outPorts, port, portName, _ref, _ref1;
    inPorts = [];
    outPorts = [];
    _ref = instance.inPorts;
    for (portName in _ref) {
      port = _ref[portName];
      if (!port || typeof port === 'function' || !port.canAttach) {
        continue;
      }
      inPorts.push({
        id: portName,
        type: port.type,
        array: port instanceof noflo.ArrayPort
      });
    }
    _ref1 = instance.outPorts;
    for (portName in _ref1) {
      port = _ref1[portName];
      if (!port || typeof port === 'function' || !port.canAttach) {
        continue;
      }
      outPorts.push({
        id: portName,
        type: port.type,
        array: port instanceof noflo.ArrayPort
      });
    }
    icon = instance.getIcon ? instance.getIcon() : 'blank';
    return this.send('component', {
      name: component,
      description: instance.description,
      icon: icon,
      inPorts: inPorts,
      outPorts: outPorts
    }, context);
  };

  ComponentProtocol.prototype.registerGraph = function(id, graph, context) {
    var loader, send;
    send = (function(_this) {
      return function() {
        return _this.processComponent(loader, id, context);
      };
    })(this);
    loader = this.getLoader(graph.baseDir);
    loader.listComponents((function(_this) {
      return function(components) {
        loader.registerComponent('', id, graph);
        return send();
      };
    })(this));
    graph.on('addNode', send);
    graph.on('removeNode', send);
    graph.on('renameNode', send);
    graph.on('addEdge', send);
    graph.on('removeEdge', send);
    graph.on('addInitial', send);
    return graph.on('removeInitial', send);
  };

  return ComponentProtocol;

})();

module.exports = ComponentProtocol;

});
require.register("noflo-noflo-runtime-iframe/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-runtime-iframe.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-runtime-iframe/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-runtime-iframe","description":"NoFlo runtime for execution inside an iframe","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-runtime-iframe","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*","noflo/noflo-runtime-base":"*","noflo/noflo-core":"*","noflo/noflo-flow":"*"},"scripts":["index.js"],"json":["component.json"],"files":["runtime/component.js","html/component.html","runtime/network.js","html/network.html"]}');
});
require.register("noflo-noflo-ajax/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-ajax.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-ajax/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-ajax","description":"AJAX components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-ajax","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Get.coffee","components/GetJsonP.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"globe","components":{"Get":"components/Get.coffee","GetJsonP":"components/GetJsonP.coffee"}}}');
});
require.register("noflo-noflo-ajax/components/Get.js", function(exports, require, module){
var Get, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Get = (function(_super) {
  __extends(Get, _super);

  function Get() {
    this.inPorts = {
      url: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('string'),
      error: new noflo.Port('object')
    };
    Get.__super__.constructor.call(this, 'url');
  }

  Get.prototype.doAsync = function(url, callback) {
    var req;
    req = new XMLHttpRequest;
    req.onreadystatechange = (function(_this) {
      return function() {
        if (req.readyState === 4) {
          if (req.status === 200) {
            _this.outPorts.out.beginGroup(url);
            _this.outPorts.out.send(req.responseText);
            _this.outPorts.out.endGroup();
            _this.outPorts.out.disconnect();
            return callback();
          } else {
            return callback(new Error("Error loading " + url));
          }
        }
      };
    })(this);
    req.open('GET', url, true);
    return req.send(null);
  };

  return Get;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new Get;
};

});
require.register("noflo-noflo-ajax/components/GetJsonP.js", function(exports, require, module){
var GetJsonP, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetJsonP = (function(_super) {
  __extends(GetJsonP, _super);

  function GetJsonP() {
    this.inPorts = {
      url: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    GetJsonP.__super__.constructor.call(this, 'url');
  }

  GetJsonP.prototype.doAsync = function(url, callback) {
    var body, id, s;
    id = 'noflo' + (Math.random() * 100).toString().replace(/\./g, '');
    body = document.querySelector('body');
    s = document.createElement('script');
    window[id] = (function(_this) {
      return function(data) {
        _this.outPorts.out.beginGroup(url);
        _this.outPorts.out.send(data);
        _this.outPorts.out.endGroup();
        _this.outPorts.out.disconnect();
        delete window[id];
        body.removeChild(s);
        return callback();
      };
    })(this);
    s.type = 'application/javascript';
    if (url.indexOf('?') === -1) {
      url = "" + url + "?callback=?";
    }
    s.src = url.replace('callback=?', "callback=" + id);
    return body.appendChild(s);
  };

  return GetJsonP;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetJsonP;
};

});
require.register("noflo-noflo-core/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of core.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-core/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-core","description":"NoFlo Essentials","repo":"noflo/noflo-core","version":"0.1.0","author":{"name":"Henri Bergius","email":"henri.bergius@iki.fi"},"contributors":[{"name":"Kenneth Kan","email":"kenhkan@gmail.com"},{"name":"Ryan Shaw","email":"ryanshaw@unc.edu"}],"keywords":[],"dependencies":{"noflo/noflo":"*","component/underscore":"*"},"scripts":["components/Callback.coffee","components/DisconnectAfterPacket.coffee","components/Drop.coffee","components/Group.coffee","components/Kick.coffee","components/Merge.coffee","components/Output.coffee","components/Repeat.coffee","components/RepeatAsync.coffee","components/Split.coffee","components/RunInterval.coffee","components/RunTimeout.coffee","components/MakeFunction.coffee","index.js"],"json":["component.json"],"noflo":{"components":{"Callback":"components/Callback.coffee","DisconnectAfterPacket":"components/DisconnectAfterPacket.coffee","Drop":"components/Drop.coffee","Group":"components/Group.coffee","Kick":"components/Kick.coffee","Merge":"components/Merge.coffee","Output":"components/Output.coffee","Repeat":"components/Repeat.coffee","RepeatAsync":"components/RepeatAsync.coffee","Split":"components/Split.coffee","RunInterval":"components/RunInterval.coffee","RunTimeout":"components/RunTimeout.coffee","MakeFunction":"components/MakeFunction.coffee"}}}');
});
require.register("noflo-noflo-core/components/Callback.js", function(exports, require, module){
var Callback, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore')._;

Callback = (function(_super) {
  __extends(Callback, _super);

  Callback.prototype.description = 'This component calls a given callback function for each IP it receives.  The Callback component is typically used to connect NoFlo with external Node.js code.';

  Callback.prototype.icon = 'sign-out';

  function Callback() {
    this.callback = null;
    this.inPorts = {
      "in": new noflo.Port('all'),
      callback: new noflo.Port('function')
    };
    this.outPorts = {
      error: new noflo.Port('object')
    };
    this.inPorts.callback.on('data', (function(_this) {
      return function(data) {
        if (!_.isFunction(data)) {
          _this.error('The provided callback must be a function');
          return;
        }
        return _this.callback = data;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (!_this.callback) {
          _this.error('No callback provided');
          return;
        }
        return _this.callback(data);
      };
    })(this));
  }

  Callback.prototype.error = function(msg) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(new Error(msg));
      this.outPorts.error.disconnect();
      return;
    }
    throw new Error(msg);
  };

  return Callback;

})(noflo.Component);

exports.getComponent = function() {
  return new Callback;
};

});
require.register("noflo-noflo-core/components/DisconnectAfterPacket.js", function(exports, require, module){
var DisconnectAfterPacket, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DisconnectAfterPacket = (function(_super) {
  __extends(DisconnectAfterPacket, _super);

  DisconnectAfterPacket.prototype.description = 'Forwards any packets, but also sends a disconnect after each of them';

  DisconnectAfterPacket.prototype.icon = 'pause';

  function DisconnectAfterPacket() {
    this.inPorts = {
      "in": new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        _this.outPorts.out.send(data);
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
  }

  return DisconnectAfterPacket;

})(noflo.Component);

exports.getComponent = function() {
  return new DisconnectAfterPacket;
};

});
require.register("noflo-noflo-core/components/Drop.js", function(exports, require, module){
var Drop, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Drop = (function(_super) {
  __extends(Drop, _super);

  Drop.prototype.description = 'This component drops every packet it receives with no action';

  Drop.prototype.icon = 'trash-o';

  function Drop() {
    this.inPorts = {
      "in": new noflo.ArrayPort('all')
    };
    this.outPorts = {};
  }

  return Drop;

})(noflo.Component);

exports.getComponent = function() {
  return new Drop;
};

});
require.register("noflo-noflo-core/components/Group.js", function(exports, require, module){
var Group, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Group = (function(_super) {
  __extends(Group, _super);

  Group.prototype.description = 'Adds a set of groups around the packets received at each connection';

  Group.prototype.icon = 'tags';

  function Group() {
    this.groups = [];
    this.newGroups = [];
    this.threshold = null;
    this.inPorts = {
      "in": new noflo.ArrayPort('all'),
      group: new noflo.ArrayPort('string'),
      threshold: new noflo.Port('integer')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        var group, _i, _len, _ref, _results;
        _ref = _this.newGroups;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _results.push(_this.outPorts.out.beginGroup(group));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        var group, _i, _len, _ref;
        _ref = _this.newGroups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.endGroup();
        }
        _this.outPorts.out.disconnect();
        return _this.groups = [];
      };
    })(this));
    this.inPorts.group.on('data', (function(_this) {
      return function(data) {
        var diff;
        if (_this.threshold) {
          diff = _this.newGroups.length - _this.threshold + 1;
          if (diff > 0) {
            _this.newGroups = _this.newGroups.slice(diff);
          }
        }
        return _this.newGroups.push(data);
      };
    })(this));
    this.inPorts.threshold.on('data', (function(_this) {
      return function(threshold) {
        _this.threshold = threshold;
      };
    })(this));
  }

  return Group;

})(noflo.Component);

exports.getComponent = function() {
  return new Group;
};

});
require.register("noflo-noflo-core/components/Kick.js", function(exports, require, module){
var Kick, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Kick = (function(_super) {
  __extends(Kick, _super);

  Kick.prototype.description = 'This component generates a single packet and sends it to the output port. Mostly usable for debugging, but can also be useful for starting up networks.';

  Kick.prototype.icon = 'share';

  function Kick() {
    this.data = {
      packet: null,
      group: []
    };
    this.groups = [];
    this.inPorts = {
      "in": new noflo.Port('bang'),
      data: new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('all')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function() {
        return _this.data.group = _this.groups.slice(0);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.sendKick(_this.data);
        return _this.groups = [];
      };
    })(this));
    this.inPorts.data.on('data', (function(_this) {
      return function(data) {
        return _this.data.packet = data;
      };
    })(this));
  }

  Kick.prototype.sendKick = function(kick) {
    var group, _i, _j, _len, _len1, _ref, _ref1;
    _ref = kick.group;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      this.outPorts.out.beginGroup(group);
    }
    this.outPorts.out.send(kick.packet);
    _ref1 = kick.group;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      group = _ref1[_j];
      this.outPorts.out.endGroup();
    }
    return this.outPorts.out.disconnect();
  };

  return Kick;

})(noflo.Component);

exports.getComponent = function() {
  return new Kick;
};

});
require.register("noflo-noflo-core/components/Merge.js", function(exports, require, module){
var Merge, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Merge = (function(_super) {
  __extends(Merge, _super);

  Merge.prototype.description = 'This component receives data on multiple input ports and sends the same data out to the connected output port';

  Merge.prototype.icon = 'compress';

  function Merge() {
    this.inPorts = {
      "in": new noflo.ArrayPort('all')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.outPorts.out.connect();
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        var socket, _i, _len, _ref;
        _ref = _this.inPorts["in"].sockets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          socket = _ref[_i];
          if (socket.connected) {
            return;
          }
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Merge;

})(noflo.Component);

exports.getComponent = function() {
  return new Merge;
};

});
require.register("noflo-noflo-core/components/Output.js", function(exports, require, module){
var Output, noflo, util,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

if (!noflo.isBrowser()) {
  util = require('util');
} else {
  util = {
    inspect: function(data) {
      return data;
    }
  };
}

Output = (function(_super) {
  __extends(Output, _super);

  Output.prototype.description = 'This component receives input on a single inport, and sends the data items directly to console.log';

  Output.prototype.icon = 'bug';

  function Output() {
    this.options = null;
    this.inPorts = {
      "in": new noflo.ArrayPort('all'),
      options: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        _this.log(data);
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.disconnect();
        }
      };
    })(this));
    this.inPorts.options.on('data', (function(_this) {
      return function(data) {
        return _this.setOptions(data);
      };
    })(this));
  }

  Output.prototype.setOptions = function(options) {
    var key, value, _results;
    if (typeof options !== 'object') {
      throw new Error('Options is not an object');
    }
    if (this.options == null) {
      this.options = {};
    }
    _results = [];
    for (key in options) {
      if (!__hasProp.call(options, key)) continue;
      value = options[key];
      _results.push(this.options[key] = value);
    }
    return _results;
  };

  Output.prototype.log = function(data) {
    if (this.options != null) {
      return console.log(util.inspect(data, this.options.showHidden, this.options.depth, this.options.colors));
    } else {
      return console.log(data);
    }
  };

  return Output;

})(noflo.Component);

exports.getComponent = function() {
  return new Output();
};

});
require.register("noflo-noflo-core/components/Repeat.js", function(exports, require, module){
var Repeat, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Repeat = (function(_super) {
  __extends(Repeat, _super);

  Repeat.prototype.description = 'Forwards packets and metadata in the same way it receives them';

  Repeat.prototype.icon = 'forward';

  function Repeat() {
    this.inPorts = {
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.outPorts.out.connect();
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Repeat;

})(noflo.Component);

exports.getComponent = function() {
  return new Repeat();
};

});
require.register("noflo-noflo-core/components/RepeatAsync.js", function(exports, require, module){
var RepeatAsync, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RepeatAsync = (function(_super) {
  __extends(RepeatAsync, _super);

  RepeatAsync.prototype.description = "Like 'Repeat', except repeat on next tick";

  RepeatAsync.prototype.icon = 'step-forward';

  function RepeatAsync() {
    this.groups = [];
    this.inPorts = {
      "in": new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var groups, later;
        groups = _this.groups;
        later = function() {
          var group, _i, _j, _len, _len1;
          for (_i = 0, _len = groups.length; _i < _len; _i++) {
            group = groups[_i];
            _this.outPorts.out.beginGroup(group);
          }
          _this.outPorts.out.send(data);
          for (_j = 0, _len1 = groups.length; _j < _len1; _j++) {
            group = groups[_j];
            _this.outPorts.out.endGroup();
          }
          return _this.outPorts.out.disconnect();
        };
        return setTimeout(later, 0);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.groups = [];
      };
    })(this));
  }

  return RepeatAsync;

})(noflo.Component);

exports.getComponent = function() {
  return new RepeatAsync;
};

});
require.register("noflo-noflo-core/components/Split.js", function(exports, require, module){
var Split, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Split = (function(_super) {
  __extends(Split, _super);

  Split.prototype.description = 'This component receives data on a single input port and sends the same data out to all connected output ports';

  Split.prototype.icon = 'expand';

  function Split() {
    this.inPorts = {
      "in": new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('all')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.outPorts.out.connect();
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Split;

})(noflo.Component);

exports.getComponent = function() {
  return new Split;
};

});
require.register("noflo-noflo-core/components/RunInterval.js", function(exports, require, module){
var RunInterval, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RunInterval = (function(_super) {
  __extends(RunInterval, _super);

  RunInterval.prototype.description = 'Send a packet at the given interval';

  RunInterval.prototype.icon = 'clock-o';

  function RunInterval() {
    this.timer = null;
    this.interval = null;
    this.inPorts = {
      interval: new noflo.Port('number'),
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('bang')
    };
    this.inPorts.interval.on('data', (function(_this) {
      return function(interval) {
        _this.interval = interval;
        if (_this.timer != null) {
          clearInterval(_this.timer);
          return _this.timer = setInterval(function() {
            return _this.outPorts.out.send(true);
          }, _this.interval);
        }
      };
    })(this));
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        if (_this.timer != null) {
          clearInterval(_this.timer);
        }
        _this.outPorts.out.connect();
        return _this.timer = setInterval(function() {
          return _this.outPorts.out.send(true);
        }, _this.interval);
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        if (!_this.timer) {
          return;
        }
        clearInterval(_this.timer);
        _this.timer = null;
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  RunInterval.prototype.shutdown = function() {
    if (this.timer != null) {
      return clearInterval(this.timer);
    }
  };

  return RunInterval;

})(noflo.Component);

exports.getComponent = function() {
  return new RunInterval;
};

});
require.register("noflo-noflo-core/components/RunTimeout.js", function(exports, require, module){
var RunTimeout, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RunTimeout = (function(_super) {
  __extends(RunTimeout, _super);

  RunTimeout.prototype.description = 'Send a packet after the given time in ms';

  RunTimeout.prototype.icon = 'clock-o';

  function RunTimeout() {
    this.timer = null;
    this.time = null;
    this.inPorts = {
      time: new noflo.Port('number'),
      start: new noflo.Port('bang'),
      clear: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('bang')
    };
    this.inPorts.time.on('data', (function(_this) {
      return function(time) {
        _this.time = time;
        if (_this.timer != null) {
          clearTimeout(_this.timer);
          return _this.timer = setTimeout(function() {
            return _this.outPorts.out.send(true);
          }, _this.time);
        }
      };
    })(this));
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        if (_this.timer != null) {
          clearTimeout(_this.timer);
        }
        _this.outPorts.out.connect();
        return _this.timer = setTimeout(function() {
          _this.outPorts.out.send(true);
          return _this.outPorts.out.disconnect();
        }, _this.time);
      };
    })(this));
    this.inPorts.clear.on('data', (function(_this) {
      return function() {
        if (!_this.timer) {
          return;
        }
        clearTimeout(_this.timer);
        _this.timer = null;
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  RunTimeout.prototype.shutdown = function() {
    if (this.timer != null) {
      return clearTimeout(this.timer);
    }
  };

  return RunTimeout;

})(noflo.Component);

exports.getComponent = function() {
  return new RunTimeout;
};

});
require.register("noflo-noflo-core/components/MakeFunction.js", function(exports, require, module){
var MakeFunction, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MakeFunction = (function(_super) {
  __extends(MakeFunction, _super);

  MakeFunction.prototype.description = 'Evaluates a function each time data hits the "in" port and sends the return value to "out". Within the function "x" will be the variable from the in port. For example, to make a ^2 function input "return x*x;" to the function port.';

  MakeFunction.prototype.icon = 'code';

  function MakeFunction() {
    this.f = null;
    this.inPorts = {
      "in": new noflo.Port('all'),
      "function": new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('all'),
      "function": new noflo.Port('function'),
      error: new noflo.Port('object')
    };
    this.inPorts["function"].on('data', (function(_this) {
      return function(data) {
        var error;
        if (typeof data === "function") {
          _this.f = data;
        } else {
          try {
            _this.f = Function("x", data);
          } catch (_error) {
            error = _error;
            _this.error('Error creating function: ' + data);
          }
        }
        if (_this.f && _this.outPorts["function"].isAttached()) {
          return _this.outPorts["function"].send(_this.f);
        }
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var error;
        if (!_this.f) {
          _this.error('No function defined');
          return;
        }
        try {
          return _this.outPorts.out.send(_this.f(data));
        } catch (_error) {
          error = _error;
          return _this.error('Error evaluating function.');
        }
      };
    })(this));
  }

  MakeFunction.prototype.error = function(msg) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(new Error(msg));
      this.outPorts.error.disconnect();
      return;
    }
    throw new Error(msg);
  };

  return MakeFunction;

})(noflo.Component);

exports.getComponent = function() {
  return new MakeFunction;
};

});
require.register("noflo-noflo-css/index.js", function(exports, require, module){
/*
 * This file can be used for general library features that are exposed as CommonJS modules
 * that the components then utilize
 */

});
require.register("noflo-noflo-css/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-css","description":"Cascading Style Sheets components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-css","version":"0.0.1","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/MoveElement.coffee","components/RotateElement.coffee","components/SetElementTop.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"css3","components":{"MoveElement":"components/MoveElement.coffee","RotateElement":"components/RotateElement.coffee","SetElementTop":"components/SetElementTop.coffee"}}}');
});
require.register("noflo-noflo-css/components/MoveElement.js", function(exports, require, module){
var MoveElement, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MoveElement = (function(_super) {
  __extends(MoveElement, _super);

  MoveElement.prototype.description = 'Change the coordinates of a DOM element';

  MoveElement.prototype.icon = 'arrows';

  function MoveElement() {
    this.element = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      point: new noflo.Port('object'),
      x: new noflo.Port('number'),
      y: new noflo.Port('number'),
      z: new noflo.Port('number')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.element = element;
      };
    })(this));
    this.inPorts.point.on('data', (function(_this) {
      return function(point) {
        _this.setPosition('left', "" + point.x + "px");
        return _this.setPosition('top', "" + point.y + "px");
      };
    })(this));
    this.inPorts.x.on('data', (function(_this) {
      return function(x) {
        return _this.setPosition('left', "" + x + "px");
      };
    })(this));
    this.inPorts.y.on('data', (function(_this) {
      return function(y) {
        return _this.setPosition('top', "" + y + "px");
      };
    })(this));
    this.inPorts.z.on('data', (function(_this) {
      return function(z) {
        return _this.setPosition('zIndex', z);
      };
    })(this));
  }

  MoveElement.prototype.setPosition = function(attr, value) {
    this.element.style.position = 'absolute';
    return this.element.style[attr] = value;
  };

  return MoveElement;

})(noflo.Component);

exports.getComponent = function() {
  return new MoveElement;
};

});
require.register("noflo-noflo-css/components/RotateElement.js", function(exports, require, module){
var RotateElement, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RotateElement = (function(_super) {
  __extends(RotateElement, _super);

  RotateElement.prototype.description = 'Change the coordinates of a DOM element';

  RotateElement.prototype.icon = 'rotate-right';

  function RotateElement() {
    this.element = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      percent: new noflo.Port('number'),
      degrees: new noflo.Port('number')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.element = element;
      };
    })(this));
    this.inPorts.percent.on('data', (function(_this) {
      return function(percent) {
        var degrees;
        if (!_this.element) {
          return;
        }
        degrees = 360 * percent % 360;
        return _this.setRotation(_this.element, degrees);
      };
    })(this));
    this.inPorts.degrees.on('data', (function(_this) {
      return function(degrees) {
        if (!_this.element) {
          return;
        }
        return _this.setRotation(_this.element, degrees);
      };
    })(this));
  }

  RotateElement.prototype.setRotation = function(element, degrees) {
    return this.setVendor(element, "transform", "rotate(" + degrees + "deg)");
  };

  RotateElement.prototype.setVendor = function(element, property, value) {
    var propertyCap;
    propertyCap = property.charAt(0).toUpperCase() + property.substr(1);
    element.style["webkit" + propertyCap] = value;
    element.style["moz" + propertyCap] = value;
    element.style["ms" + propertyCap] = value;
    element.style["o" + propertyCap] = value;
    return element.style[property] = value;
  };

  return RotateElement;

})(noflo.Component);

exports.getComponent = function() {
  return new RotateElement;
};

});
require.register("noflo-noflo-css/components/SetElementTop.js", function(exports, require, module){
var SetElementTop, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetElementTop = (function(_super) {
  __extends(SetElementTop, _super);

  SetElementTop.prototype.description = 'Set element\'s CSS top';

  SetElementTop.prototype.icon = 'arrows-v';

  function SetElementTop() {
    this.element = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      top: new noflo.Port('number')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.element = element;
      };
    })(this));
    this.inPorts.top.on('data', (function(_this) {
      return function(top) {
        if (!_this.element) {
          return;
        }
        _this.element.style.position = 'absolute';
        return _this.element.style.top = "" + top + "px";
      };
    })(this));
  }

  return SetElementTop;

})(noflo.Component);

exports.getComponent = function() {
  return new SetElementTop;
};

});
require.register("noflo-noflo-dom/index.js", function(exports, require, module){
/*
 * This file can be used for general library features that are exposed as CommonJS modules
 * that the components then utilize
 */

});
require.register("noflo-noflo-dom/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-dom","description":"Document Object Model components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-dom","version":"0.0.1","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/AddClass.coffee","components/AppendChild.coffee","components/CreateElement.coffee","components/CreateFragment.coffee","components/GetAttribute.coffee","components/GetElement.coffee","components/HasClass.coffee","components/ReadHtml.coffee","components/RemoveElement.coffee","components/SetAttribute.coffee","components/WriteHtml.coffee","components/RemoveClass.coffee","components/RequestAnimationFrame.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"html5","components":{"AddClass":"components/AddClass.coffee","AppendChild":"components/AppendChild.coffee","CreateElement":"components/CreateElement.coffee","CreateFragment":"components/CreateFragment.coffee","GetAttribute":"components/GetAttribute.coffee","GetElement":"components/GetElement.coffee","HasClass":"components/HasClass.coffee","WriteHtml":"components/WriteHtml.coffee","ReadHtml":"components/ReadHtml.coffee","RemoveElement":"components/RemoveElement.coffee","SetAttribute":"components/SetAttribute.coffee","RemoveClass":"components/RemoveClass.coffee","RequestAnimationFrame":"components/RequestAnimationFrame.coffee"}}}');
});
require.register("noflo-noflo-dom/components/AddClass.js", function(exports, require, module){
var AddClass, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

AddClass = (function(_super) {
  __extends(AddClass, _super);

  AddClass.prototype.description = 'Add a class to an element';

  function AddClass() {
    this.element = null;
    this["class"] = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      "class": new noflo.Port('string')
    };
    this.outPorts = {};
    this.inPorts.element.on('data', (function(_this) {
      return function(data) {
        _this.element = data;
        if (_this["class"]) {
          return _this.addClass();
        }
      };
    })(this));
    this.inPorts["class"].on('data', (function(_this) {
      return function(data) {
        _this["class"] = data;
        if (_this.element) {
          return _this.addClass();
        }
      };
    })(this));
  }

  AddClass.prototype.addClass = function() {
    return this.element.classList.add(this["class"]);
  };

  return AddClass;

})(noflo.Component);

exports.getComponent = function() {
  return new AddClass;
};

});
require.register("noflo-noflo-dom/components/AppendChild.js", function(exports, require, module){
var AppendChild, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

AppendChild = (function(_super) {
  __extends(AppendChild, _super);

  AppendChild.prototype.description = 'Append elements as children of a parent element';

  function AppendChild() {
    this.parent = null;
    this.children = [];
    this.inPorts = {
      parent: new noflo.Port('object'),
      child: new noflo.Port('object')
    };
    this.outPorts = {};
    this.inPorts.parent.on('data', (function(_this) {
      return function(data) {
        _this.parent = data;
        if (_this.children.length) {
          return _this.append();
        }
      };
    })(this));
    this.inPorts.child.on('data', (function(_this) {
      return function(data) {
        if (!_this.parent) {
          _this.children.push(data);
          return;
        }
        return _this.parent.appendChild(data);
      };
    })(this));
  }

  AppendChild.prototype.append = function() {
    var child, _i, _len, _ref;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      this.parent.appendChild(child);
    }
    return this.children = [];
  };

  return AppendChild;

})(noflo.Component);

exports.getComponent = function() {
  return new AppendChild;
};

});
require.register("noflo-noflo-dom/components/CreateElement.js", function(exports, require, module){
var CreateElement, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CreateElement = (function(_super) {
  __extends(CreateElement, _super);

  CreateElement.prototype.description = 'Create a new DOM Element';

  function CreateElement() {
    this.tagName = null;
    this.container = null;
    this.inPorts = {
      tagname: new noflo.Port('string'),
      container: new noflo.Port('object')
    };
    this.outPorts = {
      element: new noflo.Port('object')
    };
    this.inPorts.tagname.on('data', (function(_this) {
      return function(tagName) {
        _this.tagName = tagName;
        return _this.createElement();
      };
    })(this));
    this.inPorts.tagname.on('disconnect', (function(_this) {
      return function() {
        if (!_this.inPorts.container.isAttached()) {
          return _this.outPorts.element.disconnect();
        }
      };
    })(this));
    this.inPorts.container.on('data', (function(_this) {
      return function(container) {
        _this.container = container;
        return _this.createElement();
      };
    })(this));
    this.inPorts.container.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.element.disconnect();
      };
    })(this));
  }

  CreateElement.prototype.createElement = function() {
    var el;
    if (!this.tagName) {
      return;
    }
    if (this.inPorts.container.isAttached()) {
      if (!this.container) {
        return;
      }
    }
    el = document.createElement(this.tagName);
    if (this.container) {
      this.container.appendChild(el);
    }
    return this.outPorts.element.send(el);
  };

  return CreateElement;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateElement;
};

});
require.register("noflo-noflo-dom/components/CreateFragment.js", function(exports, require, module){
var CreateFragment, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CreateFragment = (function(_super) {
  __extends(CreateFragment, _super);

  CreateFragment.prototype.description = 'Create a new DOM DocumentFragment';

  function CreateFragment() {
    this.inPorts = {
      "in": new noflo.Port('bang')
    };
    this.outPorts = {
      fragment: new noflo.Port('object')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function() {
        return _this.outPorts.fragment.send(document.createDocumentFragment());
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.fragment.disconnect();
      };
    })(this));
  }

  return CreateFragment;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateFragment;
};

});
require.register("noflo-noflo-dom/components/GetAttribute.js", function(exports, require, module){
var GetAttribute, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetAttribute = (function(_super) {
  __extends(GetAttribute, _super);

  function GetAttribute() {
    this.attribute = null;
    this.element = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      attribute: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(data) {
        _this.element = data;
        if (_this.attribute) {
          return _this.getAttribute();
        }
      };
    })(this));
    this.inPorts.attribute.on('data', (function(_this) {
      return function(data) {
        _this.attribute = data;
        if (_this.element) {
          return _this.getAttribute();
        }
      };
    })(this));
  }

  GetAttribute.prototype.getAttribute = function() {
    var value;
    value = this.element.getAttribute(this.attribute);
    this.outPorts.out.beginGroup(this.attribute);
    this.outPorts.out.send(value);
    this.outPorts.out.endGroup();
    return this.outPorts.out.disconnect();
  };

  return GetAttribute;

})(noflo.Component);

exports.getComponent = function() {
  return new GetAttribute;
};

});
require.register("noflo-noflo-dom/components/GetElement.js", function(exports, require, module){
var GetElement, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetElement = (function(_super) {
  __extends(GetElement, _super);

  GetElement.prototype.description = 'Get a DOM element matching a query';

  function GetElement() {
    this.container = null;
    this.inPorts = {
      "in": new noflo.Port('object'),
      selector: new noflo.Port('string')
    };
    this.outPorts = {
      element: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (typeof data.querySelector !== 'function') {
          _this.error('Given container doesn\'t support querySelectors');
          return;
        }
        return _this.container = data;
      };
    })(this));
    this.inPorts.selector.on('data', (function(_this) {
      return function(data) {
        return _this.select(data);
      };
    })(this));
  }

  GetElement.prototype.select = function(selector) {
    var el, element, _i, _len;
    if (this.container) {
      el = this.container.querySelectorAll(selector);
    } else {
      el = document.querySelectorAll(selector);
    }
    if (!el.length) {
      this.error("No element matching '" + selector + "' found");
      return;
    }
    for (_i = 0, _len = el.length; _i < _len; _i++) {
      element = el[_i];
      this.outPorts.element.send(element);
    }
    return this.outPorts.element.disconnect();
  };

  GetElement.prototype.error = function(msg) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(new Error(msg));
      this.outPorts.error.disconnect();
      return;
    }
    throw new Error(msg);
  };

  return GetElement;

})(noflo.Component);

exports.getComponent = function() {
  return new GetElement;
};

});
require.register("noflo-noflo-dom/components/HasClass.js", function(exports, require, module){
var HasClass, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

HasClass = (function(_super) {
  __extends(HasClass, _super);

  HasClass.prototype.description = 'Check if an element has a given class';

  function HasClass() {
    this.element = null;
    this["class"] = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      "class": new noflo.Port('string')
    };
    this.outPorts = {
      element: new noflo.Port('object'),
      missed: new noflo.Port('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(data) {
        _this.element = data;
        if (_this["class"]) {
          return _this.checkClass();
        }
      };
    })(this));
    this.inPorts.element.on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.element.disconnect();
        if (!_this.outPorts.missed.isAttached()) {
          return;
        }
        return _this.outPorts.missed.disconnect();
      };
    })(this));
    this.inPorts["class"].on('data', (function(_this) {
      return function(data) {
        _this["class"] = data;
        if (_this.element) {
          return _this.checkClass();
        }
      };
    })(this));
  }

  HasClass.prototype.checkClass = function() {
    if (this.element.classList.contains(this["class"])) {
      this.outPorts.element.send(this.element);
      return;
    }
    if (!this.outPorts.missed.isAttached()) {
      return;
    }
    return this.outPorts.missed.send(this.element);
  };

  return HasClass;

})(noflo.Component);

exports.getComponent = function() {
  return new HasClass;
};

});
require.register("noflo-noflo-dom/components/ReadHtml.js", function(exports, require, module){
var ReadHtml, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ReadHtml = (function(_super) {
  __extends(ReadHtml, _super);

  ReadHtml.prototype.description = 'Read HTML from an existing element';

  function ReadHtml() {
    this.inPorts = {
      container: new noflo.Port('object')
    };
    this.outPorts = {
      html: new noflo.Port('string')
    };
    this.inPorts.container.on('data', (function(_this) {
      return function(data) {
        _this.outPorts.html.send(data.innerHTML);
        return _this.outPorts.html.disconnect();
      };
    })(this));
  }

  return ReadHtml;

})(noflo.Component);

exports.getComponent = function() {
  return new ReadHtml;
};

});
require.register("noflo-noflo-dom/components/RemoveElement.js", function(exports, require, module){
var RemoveElement, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RemoveElement = (function(_super) {
  __extends(RemoveElement, _super);

  RemoveElement.prototype.description = 'Remove an element from DOM';

  function RemoveElement() {
    this.inPorts = {
      element: new noflo.Port('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        if (!element.parentNode) {
          return;
        }
        return element.parentNode.removeChild(element);
      };
    })(this));
  }

  return RemoveElement;

})(noflo.Component);

exports.getComponent = function() {
  return new RemoveElement;
};

});
require.register("noflo-noflo-dom/components/SetAttribute.js", function(exports, require, module){
var SetAttribute, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetAttribute = (function(_super) {
  __extends(SetAttribute, _super);

  function SetAttribute() {
    this.attribute = null;
    this.value = null;
    this.element = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      attribute: new noflo.Port('string'),
      value: new noflo.Port('string')
    };
    this.outPorts = {
      element: new noflo.Port('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        _this.element = element;
        if (_this.attribute && _this.value) {
          return _this.setAttribute();
        }
      };
    })(this));
    this.inPorts.attribute.on('data', (function(_this) {
      return function(attribute) {
        _this.attribute = attribute;
        if (_this.element && _this.value) {
          return _this.setAttribute();
        }
      };
    })(this));
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.value = _this.normalizeValue(value);
        if (_this.attribute && _this.element) {
          return _this.setAttribute();
        }
      };
    })(this));
  }

  SetAttribute.prototype.setAttribute = function() {
    this.element.setAttribute(this.attribute, this.value);
    this.value = null;
    if (this.outPorts.element.isAttached()) {
      this.outPorts.element.send(this.element);
      return this.outPorts.element.disconnect();
    }
  };

  SetAttribute.prototype.normalizeValue = function(value) {
    var key, newVal, val;
    if (typeof value === 'object') {
      if (toString.call(value) !== '[object Array]') {
        newVal = [];
        for (key in value) {
          val = value[key];
          newVal.push(val);
        }
        value = newVal;
      }
      return value.join(' ');
    }
    return value;
  };

  return SetAttribute;

})(noflo.Component);

exports.getComponent = function() {
  return new SetAttribute;
};

});
require.register("noflo-noflo-dom/components/WriteHtml.js", function(exports, require, module){
var WriteHtml, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

WriteHtml = (function(_super) {
  __extends(WriteHtml, _super);

  WriteHtml.prototype.description = 'Write HTML inside an existing element';

  function WriteHtml() {
    this.container = null;
    this.html = null;
    this.inPorts = {
      html: new noflo.Port('string'),
      container: new noflo.Port('object')
    };
    this.outPorts = {
      container: new noflo.Port('object')
    };
    this.inPorts.html.on('data', (function(_this) {
      return function(data) {
        _this.html = data;
        if (_this.container) {
          return _this.writeHtml();
        }
      };
    })(this));
    this.inPorts.container.on('data', (function(_this) {
      return function(data) {
        _this.container = data;
        if (_this.html !== null) {
          return _this.writeHtml();
        }
      };
    })(this));
  }

  WriteHtml.prototype.writeHtml = function() {
    this.container.innerHTML = this.html;
    this.html = null;
    if (this.outPorts.container.isAttached()) {
      this.outPorts.container.send(this.container);
      return this.outPorts.container.disconnect();
    }
  };

  return WriteHtml;

})(noflo.Component);

exports.getComponent = function() {
  return new WriteHtml;
};

});
require.register("noflo-noflo-dom/components/RemoveClass.js", function(exports, require, module){
var RemoveClass, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RemoveClass = (function(_super) {
  __extends(RemoveClass, _super);

  RemoveClass.prototype.description = 'Remove a class from an element';

  function RemoveClass() {
    this.element = null;
    this["class"] = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      "class": new noflo.Port('string')
    };
    this.outPorts = {};
    this.inPorts.element.on('data', (function(_this) {
      return function(data) {
        _this.element = data;
        if (_this["class"]) {
          return _this.removeClass();
        }
      };
    })(this));
    this.inPorts["class"].on('data', (function(_this) {
      return function(data) {
        _this["class"] = data;
        if (_this.element) {
          return _this.removeClass();
        }
      };
    })(this));
  }

  RemoveClass.prototype.removeClass = function() {
    return this.element.classList.remove(this["class"]);
  };

  return RemoveClass;

})(noflo.Component);

exports.getComponent = function() {
  return new RemoveClass;
};

});
require.register("noflo-noflo-dom/components/RequestAnimationFrame.js", function(exports, require, module){
var RequestAnimationFrame, noflo, requestAnimationFrame,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
  return window.setTimeout(function() {
    return callback(+new Date());
  }, 1000 / 60);
};

RequestAnimationFrame = (function(_super) {
  __extends(RequestAnimationFrame, _super);

  RequestAnimationFrame.prototype.description = 'Sends bangs that correspond with screen refresh rate.';

  RequestAnimationFrame.prototype.icon = 'film';

  function RequestAnimationFrame() {
    this.running = false;
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('bang')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function(data) {
        _this.running = true;
        return _this.animate();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function(data) {
        return _this.running = false;
      };
    })(this));
  }

  RequestAnimationFrame.prototype.animate = function() {
    if (this.running) {
      requestAnimationFrame(this.animate.bind(this));
      return this.outPorts.out.send(true);
    }
  };

  RequestAnimationFrame.prototype.shutdown = function() {
    return this.running = false;
  };

  return RequestAnimationFrame;

})(noflo.Component);

exports.getComponent = function() {
  return new RequestAnimationFrame;
};

});
require.register("noflo-noflo-flow/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of flow.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-flow/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-flow","description":"Flow Control for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-dom","version":"0.2.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Concat.coffee","components/Gate.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"random","components":{"Concat":"components/Concat.coffee","Gate":"components/Gate.coffee"}}}');
});
require.register("noflo-noflo-flow/components/Concat.js", function(exports, require, module){
var Concat, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Concat = (function(_super) {
  __extends(Concat, _super);

  Concat.prototype.description = 'Gathers data from all incoming connections and sends them together in order of connection';

  function Concat() {
    var subscribed;
    this.buffers = {};
    this.hasConnected = {};
    this.inPorts = {
      "in": new noflo.ArrayPort
    };
    this.outPorts = {
      out: new noflo.Port
    };
    subscribed = false;
    this.inPorts["in"].on('connect', (function(_this) {
      return function(socket) {
        var id, _i, _len, _ref;
        _this.hasConnected[_this.inPorts["in"].sockets.indexOf(socket)] = true;
        if (!subscribed) {
          _ref = _this.inPorts["in"].sockets;
          for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
            socket = _ref[id];
            _this.subscribeSocket(id);
          }
          return subscribed = true;
        }
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        var socket, _i, _len, _ref;
        _ref = _this.inPorts["in"].sockets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          socket = _ref[_i];
          if (socket.isConnected()) {
            return;
          }
        }
        _this.clearBuffers();
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  Concat.prototype.clearBuffers = function() {
    var data, id, _ref;
    _ref = this.buffers;
    for (id in _ref) {
      data = _ref[id];
      if (!this.hasConnected[id]) {
        return;
      }
    }
    this.buffers = {};
    return this.hasConnected = {};
  };

  Concat.prototype.subscribeSocket = function(id) {
    this.buffers[id] = [];
    return this.inPorts["in"].sockets[id].on('data', (function(_this) {
      return function(data) {
        if (typeof _this.buffers[id] !== 'object') {
          _this.buffers[id] = [];
        }
        _this.buffers[id].push(data);
        return _this.checkSend();
      };
    })(this));
  };

  Concat.prototype.checkSend = function() {
    var buffer, id, socket, _i, _len, _ref, _ref1, _results;
    _ref = this.inPorts["in"].sockets;
    for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
      socket = _ref[id];
      if (!this.buffers[id]) {
        return;
      }
      if (!this.buffers[id].length) {
        return;
      }
    }
    _ref1 = this.buffers;
    _results = [];
    for (id in _ref1) {
      buffer = _ref1[id];
      _results.push(this.outPorts.out.send(buffer.shift()));
    }
    return _results;
  };

  return Concat;

})(noflo.Component);

exports.getComponent = function() {
  return new Concat;
};

});
require.register("noflo-noflo-flow/components/Gate.js", function(exports, require, module){
var Gate, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Gate = (function(_super) {
  __extends(Gate, _super);

  Gate.prototype.description = 'This component forwards received packets when the gate is open';

  Gate.prototype.icon = 'pause';

  function Gate() {
    this.open = false;
    this.inPorts = {
      "in": new noflo.Port('all'),
      open: new noflo.Port('bang'),
      close: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        if (!_this.open) {
          return;
        }
        return _this.outPorts.out.connect();
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        if (!_this.open) {
          return;
        }
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (!_this.open) {
          return;
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        if (!_this.open) {
          return;
        }
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (!_this.open) {
          return;
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.open.on('data', (function(_this) {
      return function() {
        _this.open = true;
        return _this.setIcon('play');
      };
    })(this));
    this.inPorts.close.on('data', (function(_this) {
      return function() {
        _this.open = false;
        _this.outPorts.out.disconnect();
        return _this.setIcon('pause');
      };
    })(this));
  }

  return Gate;

})(noflo.Component);

exports.getComponent = function() {
  return new Gate;
};

});
require.register("noflo-noflo-gestures/graphs/DetectDrag.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectDrag"},"exports":[{"private":"receivegesture_3bwyo.in","public":"in"},{"private":"checkmindistance_zsyhq.comparison","public":"distance"},{"private":"sendpass_lskxq.out","public":"pass"},{"private":"sendfail_64mm2.out","public":"fail"},{"private":"checkmaxspeed_sojti.comparison","public":"maxspeed"}],"processes":{"ReceiveGesture_3bwyo":{"component":"core/Repeat","metadata":{"x":-605,"y":82,"label":"ReceiveGesture"}},"core/Split_qfhom":{"component":"core/Split","metadata":{"x":-605,"y":159,"label":"core/Split"}},"SendPass_lskxq":{"component":"strings/SendString","metadata":{"x":1143,"y":28,"label":"SendPass"}},"SendFail_64mm2":{"component":"strings/SendString","metadata":{"x":1145,"y":305,"label":"SendFail"}},"Failures_13q8s":{"component":"core/Merge","metadata":{"x":941,"y":311,"label":"Failures"}},"GetDistance_bjx0s":{"component":"objects/GetObjectKey","metadata":{"x":526,"y":161,"label":"GetDistance"}},"CheckMinDistance_zsyhq":{"component":"math/Compare","metadata":{"x":900,"y":160,"label":"CheckMinDistance"}},"GetIndividualPointer_hv93t":{"component":"objects/SplitObject","metadata":{"x":-410,"y":159,"label":"GetIndividualPointer"}},"SplitDistance_vreyf":{"component":"core/Split","metadata":{"x":711.9999999999998,"y":160,"label":"SplitDistance"}},"SplitPointer_8rn9q":{"component":"core/Split","metadata":{"x":-223.5000000000008,"y":159.16666666666666,"label":"SplitPointer"}},"SendPointer_b4unv":{"component":"strings/SendString","metadata":{"x":340.3333333333328,"y":160.16666666666669,"label":"SendPointer"}},"GetSpeed_o56fp":{"component":"objects/GetObjectKey","metadata":{"x":-40.49999999999977,"y":159,"label":"GetSpeed"}},"CheckMaxSpeed_sojti":{"component":"math/Compare","metadata":{"x":150.50000000000023,"y":161,"label":"CheckMaxSpeed"}}},"connections":[{"src":{"process":"ReceiveGesture_3bwyo","port":"out"},"tgt":{"process":"core/Split_qfhom","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"SendFail_64mm2","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"SendPass_lskxq","port":"string"},"metadata":{"route":9}},{"src":{"process":"Failures_13q8s","port":"out"},"tgt":{"process":"SendFail_64mm2","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_bjx0s","port":"missed"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckMinDistance_zsyhq","port":"fail"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"GetIndividualPointer_hv93t","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetDistance_bjx0s","port":"out"},"tgt":{"process":"SplitDistance_vreyf","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitDistance_vreyf","port":"out"},"tgt":{"process":"CheckMinDistance_zsyhq","port":"value"},"metadata":{"route":9}},{"src":{"process":"GetIndividualPointer_hv93t","port":"out"},"tgt":{"process":"SplitPointer_8rn9q","port":"in"},"metadata":{"route":8}},{"src":{"process":"CheckMinDistance_zsyhq","port":"pass"},"tgt":{"process":"SendPass_lskxq","port":"in"},"metadata":{"route":5}},{"src":{"process":"SendPointer_b4unv","port":"out"},"tgt":{"process":"GetDistance_bjx0s","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_8rn9q","port":"out"},"tgt":{"process":"SendPointer_b4unv","port":"string"},"metadata":{"route":9}},{"src":{"process":"CheckMaxSpeed_sojti","port":"pass"},"tgt":{"process":"SendPointer_b4unv","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetSpeed_o56fp","port":"out"},"tgt":{"process":"CheckMaxSpeed_sojti","port":"value"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_8rn9q","port":"out"},"tgt":{"process":"GetSpeed_o56fp","port":"in"},"metadata":{"route":8}},{"src":{"process":"GetSpeed_o56fp","port":"missed"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckMaxSpeed_sojti","port":"fail"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"data":"distance","tgt":{"process":"GetDistance_bjx0s","port":"key"}},{"data":">=","tgt":{"process":"CheckMinDistance_zsyhq","port":"operator"}},{"data":"<=","tgt":{"process":"CheckMaxSpeed_sojti","port":"operator"}},{"data":"speed","tgt":{"process":"GetSpeed_o56fp","port":"key"}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectSwipe.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectSwipe"},"exports":[{"private":"receivegesture_7fxc3.in","public":"in"},{"private":"sendpass_iuc21.out","public":"pass"},{"private":"sendfail_n9iay.out","public":"fail"},{"private":"checkspeed_cru21.comparison","public":"speed"},{"private":"checkdistance_786cc.comparison","public":"distance"}],"processes":{"ReceiveGesture_7fxc3":{"component":"core/Repeat","metadata":{"x":277,"y":124,"label":"ReceiveGesture"}},"GetIndividualPointer_9o878":{"component":"objects/SplitObject","metadata":{"x":473,"y":217,"label":"GetIndividualPointer"}},"SendPass_iuc21":{"component":"strings/SendString","metadata":{"x":2060,"y":113,"label":"SendPass"}},"GetSpeed_26n6h":{"component":"objects/GetObjectKey","metadata":{"x":863,"y":216,"label":"GetSpeed"}},"DetectionFailed_uj7oh":{"component":"core/Merge","metadata":{"x":1850,"y":337,"label":"DetectionFailed"}},"core/Split_cbjyy":{"component":"core/Split","metadata":{"x":273,"y":216,"label":"core/Split"}},"SendFail_n9iay":{"component":"strings/SendString","metadata":{"x":2062,"y":337.16666666666663,"label":"SendFail"}},"CheckSpeed_cru21":{"component":"math/Compare","metadata":{"x":1055.6666666666665,"y":215.66666666666666,"label":"CheckSpeed"}},"strings/SendString_75se6":{"component":"strings/SendString","metadata":{"x":1250.6666666666665,"y":216.66666666666666,"label":"strings/SendString"}},"GetDistance_zdjyf":{"component":"objects/GetObjectKey","metadata":{"x":1445.6666666666665,"y":215.66666666666666,"label":"GetDistance"}},"CheckDistance_786cc":{"component":"math/Compare","metadata":{"x":1648,"y":216,"label":"CheckDistance"}},"core/Split_x6p93":{"component":"core/Split","metadata":{"x":667.9999999999986,"y":215.66666666666663,"label":"core/Split"}}},"connections":[{"src":{"process":"GetSpeed_26n6h","port":"missed"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckSpeed_cru21","port":"pass"},"tgt":{"process":"strings/SendString_75se6","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetSpeed_26n6h","port":"out"},"tgt":{"process":"CheckSpeed_cru21","port":"value"},"metadata":{"route":1}},{"src":{"process":"CheckSpeed_cru21","port":"fail"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"strings/SendString_75se6","port":"out"},"tgt":{"process":"GetDistance_zdjyf","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetDistance_zdjyf","port":"missed"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckDistance_786cc","port":"fail"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_zdjyf","port":"out"},"tgt":{"process":"CheckDistance_786cc","port":"value"},"metadata":{"route":5}},{"src":{"process":"CheckDistance_786cc","port":"pass"},"tgt":{"process":"SendPass_iuc21","port":"in"},"metadata":{"route":5}},{"src":{"process":"DetectionFailed_uj7oh","port":"out"},"tgt":{"process":"SendFail_n9iay","port":"in"},"metadata":{"route":1}},{"src":{"process":"ReceiveGesture_7fxc3","port":"out"},"tgt":{"process":"core/Split_cbjyy","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"SendPass_iuc21","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"SendFail_n9iay","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"GetIndividualPointer_9o878","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetIndividualPointer_9o878","port":"out"},"tgt":{"process":"core/Split_x6p93","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_x6p93","port":"out"},"tgt":{"process":"strings/SendString_75se6","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_x6p93","port":"out"},"tgt":{"process":"GetSpeed_26n6h","port":"in"},"metadata":{"route":9}},{"data":"speed","tgt":{"process":"GetSpeed_26n6h","port":"key"}},{"data":"distance","tgt":{"process":"GetDistance_zdjyf","port":"key"}},{"data":">=","tgt":{"process":"CheckSpeed_cru21","port":"operator"}},{"data":">=","tgt":{"process":"CheckDistance_786cc","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectPinch.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectPinch"},"exports":[{"private":"core/split_ewbre.in","public":"in"},{"private":"sendpass_cf0pu.out","public":"pass"},{"private":"sendfail_vmi5n.out","public":"fail"}],"processes":{"core/Split_ewbre":{"component":"core/Split","metadata":{"x":740,"y":151,"label":"core/Split"}},"SendFail_vmi5n":{"component":"strings/SendString","metadata":{"x":1423,"y":259,"label":"SendFail"}},"SendPass_cf0pu":{"component":"strings/SendString","metadata":{"x":1421,"y":65,"label":"SendPass"}},"objects/Size_jjmmg":{"component":"objects/Size","metadata":{"x":939,"y":150,"label":"objects/Size"}},"math/Compare_hk3su":{"component":"math/Compare","metadata":{"x":1146,"y":147,"label":"math/Compare"}}},"connections":[{"src":{"process":"objects/Size_jjmmg","port":"out"},"tgt":{"process":"math/Compare_hk3su","port":"value"},"metadata":{"route":9}},{"src":{"process":"math/Compare_hk3su","port":"pass"},"tgt":{"process":"SendPass_cf0pu","port":"in"},"metadata":{"route":5}},{"src":{"process":"math/Compare_hk3su","port":"fail"},"tgt":{"process":"SendFail_vmi5n","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"SendFail_vmi5n","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"SendPass_cf0pu","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"objects/Size_jjmmg","port":"in"},"metadata":{"route":9}},{"data":1,"tgt":{"process":"math/Compare_hk3su","port":"comparison"}},{"data":">","tgt":{"process":"math/Compare_hk3su","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/graphs/FilterByTarget.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"name":"FilterByTarget"},"exports":[{"private":"StartEvent_rjg24.in","public":"started"},{"private":"GetTarget_7cfim.object","public":"startevent"},{"private":"MoveEvent_reuhl.in","public":"move"},{"private":"VerifyTarget_ty3p5.accept","public":"accept"},{"private":"TargetElement_9tv87.out","public":"target"},{"private":"OnTarget_l85x9.out","public":"ontarget"},{"private":"AllowedMoves_y6ulv.out","public":"move"}],"processes":{"GetTarget_7cfim":{"component":"objects/GetObjectKey","metadata":{"x":634,"y":210,"label":"GetTarget"}},"MoveEvent_reuhl":{"component":"core/Repeat","metadata":{"x":425,"y":362,"label":"MoveEvent"}},"SplitTarget_sqlg0":{"component":"core/Split","metadata":{"x":836,"y":212,"label":"SplitTarget"}},"StartEvent_rjg24":{"component":"core/Repeat","metadata":{"x":426.00000000000006,"y":213,"label":"StartEvent"}},"VerifyTarget_ty3p5":{"component":"objects/FilterPropertyValue","metadata":{"x":1051.3333333333335,"y":211.33333333333331,"label":"VerifyTarget"}},"AllowedMoves_y6ulv":{"component":"flow/Gate","metadata":{"x":1508.6666666666665,"y":212.5,"label":"AllowedMoves"}},"SplitOnTarget_xmi67":{"component":"core/Split","metadata":{"x":1275.833333333334,"y":209.66666666666669,"label":"SplitOnTarget"}},"OnTarget_l85x9":{"component":"core/Repeat","metadata":{"x":1509.833333333334,"y":118.66666666666669,"label":"OnTarget"}},"TargetElement_9tv87":{"component":"core/Repeat","metadata":{"x":1507.833333333334,"y":26.666666666666686,"label":"TargetElement"}}},"connections":[{"src":{"process":"GetTarget_7cfim","port":"out"},"tgt":{"process":"SplitTarget_sqlg0","port":"in"},"metadata":{"route":5}},{"src":{"process":"StartEvent_rjg24","port":"out"},"tgt":{"process":"GetTarget_7cfim","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitTarget_sqlg0","port":"out"},"tgt":{"process":"VerifyTarget_ty3p5","port":"in"},"metadata":{"route":5}},{"src":{"process":"MoveEvent_reuhl","port":"out"},"tgt":{"process":"AllowedMoves_y6ulv","port":"in"},"metadata":{"route":2}},{"src":{"process":"VerifyTarget_ty3p5","port":"missed"},"tgt":{"process":"AllowedMoves_y6ulv","port":"close"},"metadata":{"route":1}},{"src":{"process":"VerifyTarget_ty3p5","port":"out"},"tgt":{"process":"SplitOnTarget_xmi67","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitOnTarget_xmi67","port":"out"},"tgt":{"process":"AllowedMoves_y6ulv","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitOnTarget_xmi67","port":"out"},"tgt":{"process":"OnTarget_l85x9","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitTarget_sqlg0","port":"out"},"tgt":{"process":"TargetElement_9tv87","port":"in"},"metadata":{"route":5}},{"data":"target","tgt":{"process":"GetTarget_7cfim","port":"key"}}]}');
});
require.register("noflo-noflo-gestures/graphs/GestureToObject.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"Behavior"},"exports":[{"private":"listengestures_ns8li.element","public":"element"},{"private":"gesturedatatoobject_yh3yq.out","public":"out"}],"processes":{"ListenGestures_ns8li":{"component":"gestures/ListenGestures","metadata":{"x":609,"y":139,"label":"ListenGestures"}},"GestureDataToObject_yh3yq":{"component":"groups/CollectObject","metadata":{"x":1252,"y":159,"label":"GestureDataToObject"}},"SplitEnd_akdq1":{"component":"core/Split","metadata":{"x":847.1666666666667,"y":85.66666666666666,"label":"SplitEnd"}},"ClearOnEnd_9w9o":{"component":"core/RepeatAsync","metadata":{"x":1051.1666666666667,"y":88.66666666666666,"label":"ClearOnEnd"}},"SplitSpeed_2jnkm":{"component":"core/Split","metadata":{"x":849.5,"y":147.5,"label":"SplitSpeed"}},"SplitStart_hr2rx":{"component":"core/Split","metadata":{"x":845.833333333333,"y":23.50000000000003,"label":"SplitStart"}},"ReleaseMoveOrEnd_ahcs5":{"component":"core/Merge","metadata":{"x":1050.3333333333326,"y":157.83333333333331,"label":"ReleaseMoveOrEnd"}}},"connections":[{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"ClearOnEnd_9w9o","port":"in"},"metadata":{"route":1}},{"src":{"process":"ClearOnEnd_9w9o","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"clear"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"end"},"tgt":{"process":"SplitEnd_akdq1","port":"in"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"start"},"tgt":{"process":"SplitStart_hr2rx","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitStart_hr2rx","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":5}},{"src":{"process":"ListenGestures_ns8li","port":"startpoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":5}},{"src":{"process":"ListenGestures_ns8li","port":"elements"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":7}},{"src":{"process":"ListenGestures_ns8li","port":"angle"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"ListenGestures_ns8li","port":"distance"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"SplitSpeed_2jnkm","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"ListenGestures_ns8li","port":"movepoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":3}},{"src":{"process":"ListenGestures_ns8li","port":"current"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":3}},{"src":{"process":"ListenGestures_ns8li","port":"duration"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"endpoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"speed"},"tgt":{"process":"SplitSpeed_2jnkm","port":"in"},"metadata":{"route":8}},{"src":{"process":"SplitSpeed_2jnkm","port":"out"},"tgt":{"process":"ReleaseMoveOrEnd_ahcs5","port":"in"},"metadata":{"route":8}},{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"ReleaseMoveOrEnd_ahcs5","port":"in"},"metadata":{"route":1}},{"src":{"process":"ReleaseMoveOrEnd_ahcs5","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"release"},"metadata":{"route":8}},{"data":"elements","tgt":{"process":"GestureDataToObject_yh3yq","port":"allpackets"}},{"data":"startelement,startpoint,elements,angle,distance,speed,movepoint,current,duration,endelement,endpoint","tgt":{"process":"GestureDataToObject_yh3yq","port":"keys"}}]}');
});
require.register("noflo-noflo-gestures/graphs/ListenGestures.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"ListenGestures"},"exports":[{"private":"gestures/listenpointer_8ftd1.element","public":"element"},{"private":"movepoint_fjlur.out","public":"movepoint"},{"private":"distance_kwk39.out","public":"distance"},{"private":"gestureelements_yvm9m.out","public":"elements"},{"private":"angle_43qpo.out","public":"angle"},{"private":"speed_e99jq.out","public":"speed"},{"private":"getstartelement_w7m64.out","public":"start"},{"private":"startpoint_u8int.out","public":"startpoint"},{"private":"getendelement_slbp9.out","public":"end"},{"private":"getendingpoint_dettb.client","public":"endpoint"},{"private":"currentelement_cu0q5.out","public":"current"},{"private":"duration_qyevv.out","public":"duration"}],"processes":{"GestureStart_r8vr5":{"component":"core/Split","metadata":{"x":466,"y":-31,"label":"GestureStart"}},"GetStartingPoint_pidfs":{"component":"interaction/ReadCoordinates","metadata":{"x":765,"y":-191,"label":"GetStartingPoint"}},"GetMovePoint_9dia9":{"component":"interaction/ReadCoordinates","metadata":{"x":1368,"y":136,"label":"GetMovePoint"}},"core/Split_baeeb":{"component":"core/Split","metadata":{"x":1563,"y":137,"label":"core/Split"}},"core/Split_4ds1h":{"component":"core/Split","metadata":{"x":973,"y":-191,"label":"core/Split"}},"GestureAngle_dwjj":{"component":"math/CalculateAngle","metadata":{"x":1939,"y":-127,"label":"GestureAngle"}},"GestureDistance_esqkc":{"component":"math/CalculateDistance","metadata":{"x":1934,"y":20,"label":"GestureDistance"}},"LastMove_p5yj7":{"component":"core/Kick","metadata":{"x":1062,"y":176,"label":"LastMove"}},"GestureEnd_qqx8o":{"component":"core/Split","metadata":{"x":460,"y":162,"label":"GestureEnd"}},"GestureMove_hy46s":{"component":"core/Split","metadata":{"x":463,"y":65,"label":"GestureMove"}},"AllTouchedElements_i3x74":{"component":"packets/UniquePacket","metadata":{"x":1445,"y":6,"label":"AllTouchedElements"}},"GetMoveElement_iaexm":{"component":"objects/GetObjectKey","metadata":{"x":1059,"y":6,"label":"GetMoveElement"}},"GetStartElement_w7m64":{"component":"objects/GetObjectKey","metadata":{"x":968,"y":-404.66666666666663,"label":"GetStartElement"}},"MoveDate_6bjnl":{"component":"objects/CreateDate","metadata":{"x":2145,"y":164,"label":"MoveDate"}},"StartDate_swbwu":{"component":"objects/CreateDate","metadata":{"x":968,"y":-281,"label":"StartDate"}},"math/Subtract_j5v20":{"component":"math/Subtract","metadata":{"x":2516,"y":-193,"label":"math/Subtract"}},"SetStart_ql51c":{"component":"strings/SendString","metadata":{"x":765,"y":-284,"label":"SetStart"}},"math/Divide_x4gc8":{"component":"math/Divide","metadata":{"x":2939,"y":-199,"label":"math/Divide"}},"core/Split_x0a12":{"component":"core/Split","metadata":{"x":2151,"y":23,"label":"core/Split"}},"objects/CallMethod_iu7k2":{"component":"objects/CallMethod","metadata":{"x":2348,"y":167,"label":"objects/CallMethod"}},"objects/CallMethod_rtfd2":{"component":"objects/CallMethod","metadata":{"x":2139,"y":-274,"label":"objects/CallMethod"}},"Distance_kwk39":{"component":"core/Repeat","metadata":{"x":2580,"y":20,"label":"Distance"}},"GestureElements_yvm9m":{"component":"core/Repeat","metadata":{"x":1639,"y":4,"label":"GestureElements"}},"Angle_43qpo":{"component":"core/Repeat","metadata":{"x":2312,"y":-121,"label":"Angle"}},"Speed_e99jq":{"component":"core/Repeat","metadata":{"x":3362,"y":-171,"label":"Speed"}},"MovePoint_fjlur":{"component":"core/Repeat","metadata":{"x":1939,"y":262,"label":"MovePoint"}},"StartPoint_u8int":{"component":"core/Repeat","metadata":{"x":1382,"y":-189,"label":"StartPoint"}},"gestures/ListenPointer_8ftd1":{"component":"gestures/ListenPointer","metadata":{"x":213,"y":-1,"label":"gestures/ListenPointer"}},"GetEndElement_slbp9":{"component":"objects/GetObjectKey","metadata":{"x":1367.3333333333335,"y":283.3333333333335,"label":"GetEndElement"}},"core/RepeatAsync_c56tj":{"component":"core/RepeatAsync","metadata":{"x":1058.666666666667,"y":312.33333333333326,"label":"core/RepeatAsync"}},"strings/SendString_t6gby":{"component":"strings/SendString","metadata":{"x":1935,"y":166.33333333333337,"label":"strings/SendString"}},"groups/SendByGroup_z06kk":{"component":"groups/SendByGroup","metadata":{"x":556,"y":-151.66666666666669,"label":"groups/SendByGroup"}},"core/Split_ekxij":{"component":"core/Split","metadata":{"x":3158.5,"y":-166.33333333333343,"label":"core/Split"}},"core/Split_eph3d":{"component":"core/Split","metadata":{"x":2123.333333333334,"y":-122.66666666666669,"label":"core/Split"}},"core/Split_3elep":{"component":"core/Split","metadata":{"x":2731.1666666666697,"y":-171.83333333333258,"label":"core/Split"}},"core/Split_8l3yu":{"component":"core/Split","metadata":{"x":1251.3333333333333,"y":7.166666666666629,"label":"core/Split"}},"CurrentElement_cu0q5":{"component":"core/Repeat","metadata":{"x":1599.833333333333,"y":-192.00000000000006,"label":"CurrentElement"}},"Duration_qyevv":{"component":"core/Repeat","metadata":{"x":2937.833333333333,"y":-295.83333333333326,"label":"Duration"}},"GetEndingPoint_dettb":{"component":"interaction/ReadCoordinates","metadata":{"x":727.8333333333331,"y":335.3333333333333,"label":"GetEndingPoint"}},"core/Merge_6so":{"component":"core/Merge","metadata":{"x":1196.666666666667,"y":-188.99999999999983,"label":"core/Merge"}},"interaction/ReadCoordinates_82cb1":{"component":"interaction/ReadCoordinates","metadata":{"x":767.3333333333339,"y":-85.83333333333314,"label":"interaction/ReadCoordinates"}},"core/Drop_sa8z5":{"component":"core/Drop","metadata":{"x":1596.833333333333,"y":326.0000000000001,"label":"core/Drop"}},"core/Merge_lqxll":{"component":"core/Merge","metadata":{"x":768.9999999999995,"y":-403.66666666666663,"label":"core/Merge"}},"groups/SendByGroup_8yaj":{"component":"groups/SendByGroup","metadata":{"x":1166.999999999999,"y":-286.83333333333326,"label":"groups/SendByGroup"}}},"connections":[{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"origin"},"metadata":{"route":5}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"destination"},"metadata":{"route":3}},{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"origin"},"metadata":{"route":5}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"destination"},"metadata":{"route":3}},{"src":{"process":"GetMovePoint_9dia9","port":"client"},"tgt":{"process":"core/Split_baeeb","port":"in"},"metadata":{"route":3}},{"src":{"process":"GetStartingPoint_pidfs","port":"client"},"tgt":{"process":"core/Split_4ds1h","port":"in"},"metadata":{"route":5}},{"src":{"process":"SetStart_ql51c","port":"out"},"tgt":{"process":"StartDate_swbwu","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureDistance_esqkc","port":"distance"},"tgt":{"process":"core/Split_x0a12","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"dividend"},"metadata":{"route":9}},{"src":{"process":"objects/CallMethod_iu7k2","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"minuend"},"metadata":{"route":3}},{"src":{"process":"MoveDate_6bjnl","port":"out"},"tgt":{"process":"objects/CallMethod_iu7k2","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"Distance_kwk39","port":"in"},"metadata":{"route":9}},{"src":{"process":"AllTouchedElements_i3x74","port":"out"},"tgt":{"process":"GestureElements_yvm9m","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"MovePoint_fjlur","port":"in"},"metadata":{"route":3}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"end"},"tgt":{"process":"GestureEnd_qqx8o","port":"in"},"metadata":{"route":1}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"move"},"tgt":{"process":"GestureMove_hy46s","port":"in"},"metadata":{"route":3}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"start"},"tgt":{"process":"GestureStart_r8vr5","port":"in"},"metadata":{"route":5}},{"src":{"process":"LastMove_p5yj7","port":"out"},"tgt":{"process":"GetEndElement_slbp9","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"LastMove_p5yj7","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"core/RepeatAsync_c56tj","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"strings/SendString_t6gby","port":"in"},"metadata":{"route":3}},{"src":{"process":"strings/SendString_t6gby","port":"out"},"tgt":{"process":"MoveDate_6bjnl","port":"in"},"metadata":{"route":4}},{"src":{"process":"groups/SendByGroup_z06kk","port":"out"},"tgt":{"process":"GetStartingPoint_pidfs","port":"event"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"groups/SendByGroup_z06kk","port":"data"},"metadata":{"route":5}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"groups/SendByGroup_z06kk","port":"in"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"LastMove_p5yj7","port":"data"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"GetMoveElement_iaexm","port":"in"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"GetMovePoint_9dia9","port":"event"},"metadata":{"route":3}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"clear"},"metadata":{"route":0}},{"src":{"process":"core/Split_ekxij","port":"out"},"tgt":{"process":"Speed_e99jq","port":"in"},"metadata":{"route":8}},{"src":{"process":"math/Divide_x4gc8","port":"quotient"},"tgt":{"process":"core/Split_ekxij","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_ekxij","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"clear"},"metadata":{"route":0}},{"src":{"process":"core/RepeatAsync_c56tj","port":"out"},"tgt":{"process":"AllTouchedElements_i3x74","port":"clear"},"metadata":{"route":1}},{"src":{"process":"GestureAngle_dwjj","port":"angle"},"tgt":{"process":"core/Split_eph3d","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_eph3d","port":"out"},"tgt":{"process":"Angle_43qpo","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_eph3d","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"clear"},"metadata":{"route":0}},{"src":{"process":"math/Subtract_j5v20","port":"difference"},"tgt":{"process":"core/Split_3elep","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"divisor"},"metadata":{"route":9}},{"src":{"process":"GetMoveElement_iaexm","port":"out"},"tgt":{"process":"core/Split_8l3yu","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_8l3yu","port":"out"},"tgt":{"process":"AllTouchedElements_i3x74","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_8l3yu","port":"out"},"tgt":{"process":"CurrentElement_cu0q5","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"Duration_qyevv","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"clear"},"metadata":{"route":0}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"GetEndingPoint_dettb","port":"event"},"metadata":{"route":1}},{"src":{"process":"objects/CallMethod_rtfd2","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"subtrahend"},"metadata":{"route":5}},{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"core/Merge_6so","port":"in"},"metadata":{"route":5}},{"src":{"process":"core/Merge_6so","port":"out"},"tgt":{"process":"StartPoint_u8int","port":"in"},"metadata":{"route":5}},{"src":{"process":"interaction/ReadCoordinates_82cb1","port":"client"},"tgt":{"process":"core/Merge_6so","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"interaction/ReadCoordinates_82cb1","port":"event"},"metadata":{"route":5}},{"src":{"process":"GetEndElement_slbp9","port":"missed"},"tgt":{"process":"core/Drop_sa8z5","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"core/Merge_lqxll","port":"in"},"metadata":{"route":5}},{"src":{"process":"core/Merge_lqxll","port":"out"},"tgt":{"process":"GetStartElement_w7m64","port":"in"},"metadata":{"route":5}},{"src":{"process":"groups/SendByGroup_z06kk","port":"out"},"tgt":{"process":"core/Merge_lqxll","port":"in"},"metadata":{"route":5}},{"src":{"process":"groups/SendByGroup_8yaj","port":"out"},"tgt":{"process":"objects/CallMethod_rtfd2","port":"in"},"metadata":{"route":5}},{"src":{"process":"StartDate_swbwu","port":"out"},"tgt":{"process":"groups/SendByGroup_8yaj","port":"data"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"SetStart_ql51c","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"groups/SendByGroup_8yaj","port":"in"},"metadata":{"route":3}},{"data":"target","tgt":{"process":"GetMoveElement_iaexm","port":"key"}},{"data":"target","tgt":{"process":"GetStartElement_w7m64","port":"key"}},{"data":"now","tgt":{"process":"SetStart_ql51c","port":"string"}},{"data":"getTime","tgt":{"process":"objects/CallMethod_iu7k2","port":"method"}},{"data":"getTime","tgt":{"process":"objects/CallMethod_rtfd2","port":"method"}},{"data":"target","tgt":{"process":"GetEndElement_slbp9","port":"key"}},{"data":"now","tgt":{"process":"strings/SendString_t6gby","port":"string"}}]}');
});
require.register("noflo-noflo-gestures/graphs/ListenPointer.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"name":"ListenPointer"},"exports":[{"private":"Listen_1025g.element","public":"element"},{"private":"Listen_1025g.capture","public":"capture"},{"private":"StartEvent_x8itv.out","public":"start"},{"private":"MoveEvent_qa3pp.out","public":"move"},{"private":"EndEvent_hmwp9.out","public":"end"}],"processes":{"Listen_1025g":{"component":"interaction/ListenPointer","metadata":{"x":500,"y":-65,"label":"Listen"}},"End_vom22":{"component":"core/Merge","metadata":{"x":843,"y":96,"label":"End"}},"Start_86u3g":{"component":"core/Split","metadata":{"x":848,"y":-157,"label":"Start"}},"MoveOnlyDuringGesture_986zt":{"component":"flow/Gate","metadata":{"x":1106,"y":-40,"label":"MoveOnlyDuringGesture"}},"EndOnlyOnce_vexfn":{"component":"flow/Gate","metadata":{"x":1107,"y":75,"label":"EndOnlyOnce"}},"SplitEnd_cnfy6":{"component":"core/Split","metadata":{"x":1407,"y":79,"label":"SplitEnd"}},"Asynchronize_x0hqm":{"component":"core/RepeatAsync","metadata":{"x":1404,"y":171.33333333333331,"label":"Asynchronize"}},"StartEvent_x8itv":{"component":"core/Repeat","metadata":{"x":1662,"y":-162,"label":"StartEvent"}},"MoveEvent_qa3pp":{"component":"core/Repeat","metadata":{"x":1662,"y":-35,"label":"MoveEvent"}},"EndEvent_hmwp9":{"component":"core/Repeat","metadata":{"x":1659,"y":75,"label":"EndEvent"}}},"connections":[{"src":{"process":"Listen_1025g","port":"leave"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"cancel"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"up"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"down"},"tgt":{"process":"Start_86u3g","port":"in"},"metadata":{"route":5}},{"src":{"process":"Listen_1025g","port":"move"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"in"},"metadata":{"route":3}},{"src":{"process":"End_vom22","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"in"},"metadata":{"route":1}},{"src":{"process":"EndOnlyOnce_vexfn","port":"out"},"tgt":{"process":"SplitEnd_cnfy6","port":"in"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"Asynchronize_x0hqm","port":"in"},"metadata":{"route":1}},{"src":{"process":"Asynchronize_x0hqm","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"close"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"close"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"StartEvent_x8itv","port":"in"},"metadata":{"route":5}},{"src":{"process":"MoveOnlyDuringGesture_986zt","port":"out"},"tgt":{"process":"MoveEvent_qa3pp","port":"in"},"metadata":{"route":3}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"EndEvent_hmwp9","port":"in"},"metadata":{"route":1}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectCardinalDirection.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectCardinalDirection"},"exports":[{"private":"receivegesture_thbmw.in","public":"in"},{"private":"sendeast_218qx.out","public":"east"},{"private":"sendsouth_wx2b5.out","public":"south"},{"private":"sendwest_rkdz9.out","public":"west"},{"private":"sendnorth_c562k.out","public":"north"},{"private":"fail_5b0qo.out","public":"fail"},{"private":"checkmaxdistance_cebq5.comparison","public":"maxdistance"}],"processes":{"ReceiveGesture_thbmw":{"component":"core/Repeat","metadata":{"x":-294,"y":134,"label":"ReceiveGesture"}},"SplitGesture_dkk87":{"component":"core/Split","metadata":{"x":-296,"y":214,"label":"SplitGesture"}},"SendNorth_c562k":{"component":"strings/SendString","metadata":{"x":1733,"y":447,"label":"SendNorth"}},"SendEast_218qx":{"component":"strings/SendString","metadata":{"x":1721,"y":-5,"label":"SendEast"}},"RouteDirection_apgsp":{"component":"gestures/CardinalRouter","metadata":{"x":1469,"y":195,"label":"RouteDirection"}},"GetIndividualPointer_ozjfa":{"component":"objects/SplitObject","metadata":{"x":-86,"y":214,"label":"GetIndividualPointer"}},"GetStartPoint_bhrl2":{"component":"objects/GetObjectKey","metadata":{"x":879,"y":157,"label":"GetStartPoint"}},"GetCurrentPoint_rwwt0":{"component":"objects/GetObjectKey","metadata":{"x":877,"y":259,"label":"GetCurrentPoint"}},"GetGestureAngle_djpr6":{"component":"math/CalculateAngle","metadata":{"x":1083,"y":193,"label":"GetGestureAngle"}},"SendWest_rkdz9":{"component":"strings/SendString","metadata":{"x":1730.8333333333333,"y":348.33333333333337,"label":"SendWest"}},"SendSouth_wx2b5":{"component":"strings/SendString","metadata":{"x":1721.8333333333333,"y":107.33333333333337,"label":"SendSouth"}},"Fail_5b0qo":{"component":"core/Merge","metadata":{"x":1738.1666666666665,"y":564,"label":"Fail"}},"core/Split_n3qif":{"component":"core/Split","metadata":{"x":1276.999999999999,"y":193.66666666666669,"label":"core/Split"}},"GetDistance_owyyb":{"component":"objects/GetObjectKey","metadata":{"x":304,"y":216,"label":"GetDistance"}},"CheckMaxDistance_cebq5":{"component":"math/Compare","metadata":{"x":499,"y":214,"label":"CheckMaxDistance"}},"SendPointer_v0eqv":{"component":"strings/SendString","metadata":{"x":688,"y":214,"label":"SendPointer"}},"SplitPointer_v0u8k":{"component":"core/Split","metadata":{"x":109.00000000000006,"y":215.33333333333331,"label":"SplitPointer"}}},"connections":[{"src":{"process":"GetStartPoint_bhrl2","port":"object"},"tgt":{"process":"GetCurrentPoint_rwwt0","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetStartPoint_bhrl2","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"origin"},"metadata":{"route":9}},{"src":{"process":"GetCurrentPoint_rwwt0","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"destination"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendEast_218qx","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendWest_rkdz9","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendNorth_c562k","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendSouth_wx2b5","port":"string"},"metadata":{"route":9}},{"src":{"process":"RouteDirection_apgsp","port":"n"},"tgt":{"process":"SendNorth_c562k","port":"in"},"metadata":{"route":4}},{"src":{"process":"RouteDirection_apgsp","port":"w"},"tgt":{"process":"SendWest_rkdz9","port":"in"},"metadata":{"route":5}},{"src":{"process":"RouteDirection_apgsp","port":"s"},"tgt":{"process":"SendSouth_wx2b5","port":"in"},"metadata":{"route":6}},{"src":{"process":"RouteDirection_apgsp","port":"e"},"tgt":{"process":"SendEast_218qx","port":"in"},"metadata":{"route":7}},{"src":{"process":"ReceiveGesture_thbmw","port":"out"},"tgt":{"process":"SplitGesture_dkk87","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"GetIndividualPointer_ozjfa","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetCurrentPoint_rwwt0","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetStartPoint_bhrl2","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetGestureAngle_djpr6","port":"angle"},"tgt":{"process":"core/Split_n3qif","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_n3qif","port":"out"},"tgt":{"process":"RouteDirection_apgsp","port":"degrees"},"metadata":{"route":9}},{"src":{"process":"core/Split_n3qif","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"clear"},"metadata":{"route":0}},{"src":{"process":"GetIndividualPointer_ozjfa","port":"out"},"tgt":{"process":"SplitPointer_v0u8k","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_v0u8k","port":"out"},"tgt":{"process":"SendPointer_v0eqv","port":"string"},"metadata":{"route":9}},{"src":{"process":"SendPointer_v0eqv","port":"out"},"tgt":{"process":"GetStartPoint_bhrl2","port":"in"},"metadata":{"route":9}},{"src":{"process":"CheckMaxDistance_cebq5","port":"pass"},"tgt":{"process":"SendPointer_v0eqv","port":"in"},"metadata":{"route":9}},{"src":{"process":"CheckMaxDistance_cebq5","port":"fail"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_owyyb","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"SplitPointer_v0u8k","port":"out"},"tgt":{"process":"GetDistance_owyyb","port":"in"},"metadata":{"route":0}},{"src":{"process":"GetDistance_owyyb","port":"out"},"tgt":{"process":"CheckMaxDistance_cebq5","port":"value"},"metadata":{"route":9}},{"data":"startpoint","tgt":{"process":"GetStartPoint_bhrl2","port":"key"}},{"data":"movepoint","tgt":{"process":"GetCurrentPoint_rwwt0","port":"key"}},{"data":"distance","tgt":{"process":"GetDistance_owyyb","port":"key"}},{"data":"<=","tgt":{"process":"CheckMaxDistance_cebq5","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-gestures.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-gestures/graphs/DetectDrag.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectDrag"},"exports":[{"private":"receivegesture_3bwyo.in","public":"in"},{"private":"checkmindistance_zsyhq.comparison","public":"distance"},{"private":"sendpass_lskxq.out","public":"pass"},{"private":"sendfail_64mm2.out","public":"fail"},{"private":"checkmaxspeed_sojti.comparison","public":"maxspeed"}],"processes":{"ReceiveGesture_3bwyo":{"component":"core/Repeat","metadata":{"x":-605,"y":82,"label":"ReceiveGesture"}},"core/Split_qfhom":{"component":"core/Split","metadata":{"x":-605,"y":159,"label":"core/Split"}},"SendPass_lskxq":{"component":"strings/SendString","metadata":{"x":1143,"y":28,"label":"SendPass"}},"SendFail_64mm2":{"component":"strings/SendString","metadata":{"x":1145,"y":305,"label":"SendFail"}},"Failures_13q8s":{"component":"core/Merge","metadata":{"x":941,"y":311,"label":"Failures"}},"GetDistance_bjx0s":{"component":"objects/GetObjectKey","metadata":{"x":526,"y":161,"label":"GetDistance"}},"CheckMinDistance_zsyhq":{"component":"math/Compare","metadata":{"x":900,"y":160,"label":"CheckMinDistance"}},"GetIndividualPointer_hv93t":{"component":"objects/SplitObject","metadata":{"x":-410,"y":159,"label":"GetIndividualPointer"}},"SplitDistance_vreyf":{"component":"core/Split","metadata":{"x":711.9999999999998,"y":160,"label":"SplitDistance"}},"SplitPointer_8rn9q":{"component":"core/Split","metadata":{"x":-223.5000000000008,"y":159.16666666666666,"label":"SplitPointer"}},"SendPointer_b4unv":{"component":"strings/SendString","metadata":{"x":340.3333333333328,"y":160.16666666666669,"label":"SendPointer"}},"GetSpeed_o56fp":{"component":"objects/GetObjectKey","metadata":{"x":-40.49999999999977,"y":159,"label":"GetSpeed"}},"CheckMaxSpeed_sojti":{"component":"math/Compare","metadata":{"x":150.50000000000023,"y":161,"label":"CheckMaxSpeed"}}},"connections":[{"src":{"process":"ReceiveGesture_3bwyo","port":"out"},"tgt":{"process":"core/Split_qfhom","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"SendFail_64mm2","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"SendPass_lskxq","port":"string"},"metadata":{"route":9}},{"src":{"process":"Failures_13q8s","port":"out"},"tgt":{"process":"SendFail_64mm2","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_bjx0s","port":"missed"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckMinDistance_zsyhq","port":"fail"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"GetIndividualPointer_hv93t","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetDistance_bjx0s","port":"out"},"tgt":{"process":"SplitDistance_vreyf","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitDistance_vreyf","port":"out"},"tgt":{"process":"CheckMinDistance_zsyhq","port":"value"},"metadata":{"route":9}},{"src":{"process":"GetIndividualPointer_hv93t","port":"out"},"tgt":{"process":"SplitPointer_8rn9q","port":"in"},"metadata":{"route":8}},{"src":{"process":"CheckMinDistance_zsyhq","port":"pass"},"tgt":{"process":"SendPass_lskxq","port":"in"},"metadata":{"route":5}},{"src":{"process":"SendPointer_b4unv","port":"out"},"tgt":{"process":"GetDistance_bjx0s","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_8rn9q","port":"out"},"tgt":{"process":"SendPointer_b4unv","port":"string"},"metadata":{"route":9}},{"src":{"process":"CheckMaxSpeed_sojti","port":"pass"},"tgt":{"process":"SendPointer_b4unv","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetSpeed_o56fp","port":"out"},"tgt":{"process":"CheckMaxSpeed_sojti","port":"value"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_8rn9q","port":"out"},"tgt":{"process":"GetSpeed_o56fp","port":"in"},"metadata":{"route":8}},{"src":{"process":"GetSpeed_o56fp","port":"missed"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckMaxSpeed_sojti","port":"fail"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"data":"distance","tgt":{"process":"GetDistance_bjx0s","port":"key"}},{"data":">=","tgt":{"process":"CheckMinDistance_zsyhq","port":"operator"}},{"data":"<=","tgt":{"process":"CheckMaxSpeed_sojti","port":"operator"}},{"data":"speed","tgt":{"process":"GetSpeed_o56fp","port":"key"}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectSwipe.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectSwipe"},"exports":[{"private":"receivegesture_7fxc3.in","public":"in"},{"private":"sendpass_iuc21.out","public":"pass"},{"private":"sendfail_n9iay.out","public":"fail"},{"private":"checkspeed_cru21.comparison","public":"speed"},{"private":"checkdistance_786cc.comparison","public":"distance"}],"processes":{"ReceiveGesture_7fxc3":{"component":"core/Repeat","metadata":{"x":277,"y":124,"label":"ReceiveGesture"}},"GetIndividualPointer_9o878":{"component":"objects/SplitObject","metadata":{"x":473,"y":217,"label":"GetIndividualPointer"}},"SendPass_iuc21":{"component":"strings/SendString","metadata":{"x":2060,"y":113,"label":"SendPass"}},"GetSpeed_26n6h":{"component":"objects/GetObjectKey","metadata":{"x":863,"y":216,"label":"GetSpeed"}},"DetectionFailed_uj7oh":{"component":"core/Merge","metadata":{"x":1850,"y":337,"label":"DetectionFailed"}},"core/Split_cbjyy":{"component":"core/Split","metadata":{"x":273,"y":216,"label":"core/Split"}},"SendFail_n9iay":{"component":"strings/SendString","metadata":{"x":2062,"y":337.16666666666663,"label":"SendFail"}},"CheckSpeed_cru21":{"component":"math/Compare","metadata":{"x":1055.6666666666665,"y":215.66666666666666,"label":"CheckSpeed"}},"strings/SendString_75se6":{"component":"strings/SendString","metadata":{"x":1250.6666666666665,"y":216.66666666666666,"label":"strings/SendString"}},"GetDistance_zdjyf":{"component":"objects/GetObjectKey","metadata":{"x":1445.6666666666665,"y":215.66666666666666,"label":"GetDistance"}},"CheckDistance_786cc":{"component":"math/Compare","metadata":{"x":1648,"y":216,"label":"CheckDistance"}},"core/Split_x6p93":{"component":"core/Split","metadata":{"x":667.9999999999986,"y":215.66666666666663,"label":"core/Split"}}},"connections":[{"src":{"process":"GetSpeed_26n6h","port":"missed"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckSpeed_cru21","port":"pass"},"tgt":{"process":"strings/SendString_75se6","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetSpeed_26n6h","port":"out"},"tgt":{"process":"CheckSpeed_cru21","port":"value"},"metadata":{"route":1}},{"src":{"process":"CheckSpeed_cru21","port":"fail"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"strings/SendString_75se6","port":"out"},"tgt":{"process":"GetDistance_zdjyf","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetDistance_zdjyf","port":"missed"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckDistance_786cc","port":"fail"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_zdjyf","port":"out"},"tgt":{"process":"CheckDistance_786cc","port":"value"},"metadata":{"route":5}},{"src":{"process":"CheckDistance_786cc","port":"pass"},"tgt":{"process":"SendPass_iuc21","port":"in"},"metadata":{"route":5}},{"src":{"process":"DetectionFailed_uj7oh","port":"out"},"tgt":{"process":"SendFail_n9iay","port":"in"},"metadata":{"route":1}},{"src":{"process":"ReceiveGesture_7fxc3","port":"out"},"tgt":{"process":"core/Split_cbjyy","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"SendPass_iuc21","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"SendFail_n9iay","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"GetIndividualPointer_9o878","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetIndividualPointer_9o878","port":"out"},"tgt":{"process":"core/Split_x6p93","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_x6p93","port":"out"},"tgt":{"process":"strings/SendString_75se6","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_x6p93","port":"out"},"tgt":{"process":"GetSpeed_26n6h","port":"in"},"metadata":{"route":9}},{"data":"speed","tgt":{"process":"GetSpeed_26n6h","port":"key"}},{"data":"distance","tgt":{"process":"GetDistance_zdjyf","port":"key"}},{"data":">=","tgt":{"process":"CheckSpeed_cru21","port":"operator"}},{"data":">=","tgt":{"process":"CheckDistance_786cc","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectPinch.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectPinch"},"exports":[{"private":"core/split_ewbre.in","public":"in"},{"private":"sendpass_cf0pu.out","public":"pass"},{"private":"sendfail_vmi5n.out","public":"fail"}],"processes":{"core/Split_ewbre":{"component":"core/Split","metadata":{"x":740,"y":151,"label":"core/Split"}},"SendFail_vmi5n":{"component":"strings/SendString","metadata":{"x":1423,"y":259,"label":"SendFail"}},"SendPass_cf0pu":{"component":"strings/SendString","metadata":{"x":1421,"y":65,"label":"SendPass"}},"objects/Size_jjmmg":{"component":"objects/Size","metadata":{"x":939,"y":150,"label":"objects/Size"}},"math/Compare_hk3su":{"component":"math/Compare","metadata":{"x":1146,"y":147,"label":"math/Compare"}}},"connections":[{"src":{"process":"objects/Size_jjmmg","port":"out"},"tgt":{"process":"math/Compare_hk3su","port":"value"},"metadata":{"route":9}},{"src":{"process":"math/Compare_hk3su","port":"pass"},"tgt":{"process":"SendPass_cf0pu","port":"in"},"metadata":{"route":5}},{"src":{"process":"math/Compare_hk3su","port":"fail"},"tgt":{"process":"SendFail_vmi5n","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"SendFail_vmi5n","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"SendPass_cf0pu","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"objects/Size_jjmmg","port":"in"},"metadata":{"route":9}},{"data":1,"tgt":{"process":"math/Compare_hk3su","port":"comparison"}},{"data":">","tgt":{"process":"math/Compare_hk3su","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/graphs/FilterByTarget.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"name":"FilterByTarget"},"exports":[{"private":"StartEvent_rjg24.in","public":"started"},{"private":"GetTarget_7cfim.object","public":"startevent"},{"private":"MoveEvent_reuhl.in","public":"move"},{"private":"VerifyTarget_ty3p5.accept","public":"accept"},{"private":"TargetElement_9tv87.out","public":"target"},{"private":"OnTarget_l85x9.out","public":"ontarget"},{"private":"AllowedMoves_y6ulv.out","public":"move"}],"processes":{"GetTarget_7cfim":{"component":"objects/GetObjectKey","metadata":{"x":634,"y":210,"label":"GetTarget"}},"MoveEvent_reuhl":{"component":"core/Repeat","metadata":{"x":425,"y":362,"label":"MoveEvent"}},"SplitTarget_sqlg0":{"component":"core/Split","metadata":{"x":836,"y":212,"label":"SplitTarget"}},"StartEvent_rjg24":{"component":"core/Repeat","metadata":{"x":426.00000000000006,"y":213,"label":"StartEvent"}},"VerifyTarget_ty3p5":{"component":"objects/FilterPropertyValue","metadata":{"x":1051.3333333333335,"y":211.33333333333331,"label":"VerifyTarget"}},"AllowedMoves_y6ulv":{"component":"flow/Gate","metadata":{"x":1508.6666666666665,"y":212.5,"label":"AllowedMoves"}},"SplitOnTarget_xmi67":{"component":"core/Split","metadata":{"x":1275.833333333334,"y":209.66666666666669,"label":"SplitOnTarget"}},"OnTarget_l85x9":{"component":"core/Repeat","metadata":{"x":1509.833333333334,"y":118.66666666666669,"label":"OnTarget"}},"TargetElement_9tv87":{"component":"core/Repeat","metadata":{"x":1507.833333333334,"y":26.666666666666686,"label":"TargetElement"}}},"connections":[{"src":{"process":"GetTarget_7cfim","port":"out"},"tgt":{"process":"SplitTarget_sqlg0","port":"in"},"metadata":{"route":5}},{"src":{"process":"StartEvent_rjg24","port":"out"},"tgt":{"process":"GetTarget_7cfim","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitTarget_sqlg0","port":"out"},"tgt":{"process":"VerifyTarget_ty3p5","port":"in"},"metadata":{"route":5}},{"src":{"process":"MoveEvent_reuhl","port":"out"},"tgt":{"process":"AllowedMoves_y6ulv","port":"in"},"metadata":{"route":2}},{"src":{"process":"VerifyTarget_ty3p5","port":"missed"},"tgt":{"process":"AllowedMoves_y6ulv","port":"close"},"metadata":{"route":1}},{"src":{"process":"VerifyTarget_ty3p5","port":"out"},"tgt":{"process":"SplitOnTarget_xmi67","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitOnTarget_xmi67","port":"out"},"tgt":{"process":"AllowedMoves_y6ulv","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitOnTarget_xmi67","port":"out"},"tgt":{"process":"OnTarget_l85x9","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitTarget_sqlg0","port":"out"},"tgt":{"process":"TargetElement_9tv87","port":"in"},"metadata":{"route":5}},{"data":"target","tgt":{"process":"GetTarget_7cfim","port":"key"}}]}');
});
require.register("noflo-noflo-gestures/graphs/GestureToObject.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"Behavior"},"exports":[{"private":"listengestures_ns8li.element","public":"element"},{"private":"gesturedatatoobject_yh3yq.out","public":"out"}],"processes":{"ListenGestures_ns8li":{"component":"gestures/ListenGestures","metadata":{"x":609,"y":139,"label":"ListenGestures"}},"GestureDataToObject_yh3yq":{"component":"groups/CollectObject","metadata":{"x":1252,"y":159,"label":"GestureDataToObject"}},"SplitEnd_akdq1":{"component":"core/Split","metadata":{"x":847.1666666666667,"y":85.66666666666666,"label":"SplitEnd"}},"ClearOnEnd_9w9o":{"component":"core/RepeatAsync","metadata":{"x":1051.1666666666667,"y":88.66666666666666,"label":"ClearOnEnd"}},"SplitSpeed_2jnkm":{"component":"core/Split","metadata":{"x":849.5,"y":147.5,"label":"SplitSpeed"}},"SplitStart_hr2rx":{"component":"core/Split","metadata":{"x":845.833333333333,"y":23.50000000000003,"label":"SplitStart"}},"ReleaseMoveOrEnd_ahcs5":{"component":"core/Merge","metadata":{"x":1050.3333333333326,"y":157.83333333333331,"label":"ReleaseMoveOrEnd"}}},"connections":[{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"ClearOnEnd_9w9o","port":"in"},"metadata":{"route":1}},{"src":{"process":"ClearOnEnd_9w9o","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"clear"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"end"},"tgt":{"process":"SplitEnd_akdq1","port":"in"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"start"},"tgt":{"process":"SplitStart_hr2rx","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitStart_hr2rx","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":5}},{"src":{"process":"ListenGestures_ns8li","port":"startpoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":5}},{"src":{"process":"ListenGestures_ns8li","port":"elements"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":7}},{"src":{"process":"ListenGestures_ns8li","port":"angle"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"ListenGestures_ns8li","port":"distance"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"SplitSpeed_2jnkm","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"ListenGestures_ns8li","port":"movepoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":3}},{"src":{"process":"ListenGestures_ns8li","port":"current"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":3}},{"src":{"process":"ListenGestures_ns8li","port":"duration"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"endpoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"speed"},"tgt":{"process":"SplitSpeed_2jnkm","port":"in"},"metadata":{"route":8}},{"src":{"process":"SplitSpeed_2jnkm","port":"out"},"tgt":{"process":"ReleaseMoveOrEnd_ahcs5","port":"in"},"metadata":{"route":8}},{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"ReleaseMoveOrEnd_ahcs5","port":"in"},"metadata":{"route":1}},{"src":{"process":"ReleaseMoveOrEnd_ahcs5","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"release"},"metadata":{"route":8}},{"data":"elements","tgt":{"process":"GestureDataToObject_yh3yq","port":"allpackets"}},{"data":"startelement,startpoint,elements,angle,distance,speed,movepoint,current,duration,endelement,endpoint","tgt":{"process":"GestureDataToObject_yh3yq","port":"keys"}}]}');
});
require.register("noflo-noflo-gestures/graphs/ListenGestures.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"ListenGestures"},"exports":[{"private":"gestures/listenpointer_8ftd1.element","public":"element"},{"private":"movepoint_fjlur.out","public":"movepoint"},{"private":"distance_kwk39.out","public":"distance"},{"private":"gestureelements_yvm9m.out","public":"elements"},{"private":"angle_43qpo.out","public":"angle"},{"private":"speed_e99jq.out","public":"speed"},{"private":"getstartelement_w7m64.out","public":"start"},{"private":"startpoint_u8int.out","public":"startpoint"},{"private":"getendelement_slbp9.out","public":"end"},{"private":"getendingpoint_dettb.client","public":"endpoint"},{"private":"currentelement_cu0q5.out","public":"current"},{"private":"duration_qyevv.out","public":"duration"}],"processes":{"GestureStart_r8vr5":{"component":"core/Split","metadata":{"x":466,"y":-31,"label":"GestureStart"}},"GetStartingPoint_pidfs":{"component":"interaction/ReadCoordinates","metadata":{"x":765,"y":-191,"label":"GetStartingPoint"}},"GetMovePoint_9dia9":{"component":"interaction/ReadCoordinates","metadata":{"x":1368,"y":136,"label":"GetMovePoint"}},"core/Split_baeeb":{"component":"core/Split","metadata":{"x":1563,"y":137,"label":"core/Split"}},"core/Split_4ds1h":{"component":"core/Split","metadata":{"x":973,"y":-191,"label":"core/Split"}},"GestureAngle_dwjj":{"component":"math/CalculateAngle","metadata":{"x":1939,"y":-127,"label":"GestureAngle"}},"GestureDistance_esqkc":{"component":"math/CalculateDistance","metadata":{"x":1934,"y":20,"label":"GestureDistance"}},"LastMove_p5yj7":{"component":"core/Kick","metadata":{"x":1062,"y":176,"label":"LastMove"}},"GestureEnd_qqx8o":{"component":"core/Split","metadata":{"x":460,"y":162,"label":"GestureEnd"}},"GestureMove_hy46s":{"component":"core/Split","metadata":{"x":463,"y":65,"label":"GestureMove"}},"AllTouchedElements_i3x74":{"component":"packets/UniquePacket","metadata":{"x":1445,"y":6,"label":"AllTouchedElements"}},"GetMoveElement_iaexm":{"component":"objects/GetObjectKey","metadata":{"x":1059,"y":6,"label":"GetMoveElement"}},"GetStartElement_w7m64":{"component":"objects/GetObjectKey","metadata":{"x":968,"y":-404.66666666666663,"label":"GetStartElement"}},"MoveDate_6bjnl":{"component":"objects/CreateDate","metadata":{"x":2145,"y":164,"label":"MoveDate"}},"StartDate_swbwu":{"component":"objects/CreateDate","metadata":{"x":968,"y":-281,"label":"StartDate"}},"math/Subtract_j5v20":{"component":"math/Subtract","metadata":{"x":2516,"y":-193,"label":"math/Subtract"}},"SetStart_ql51c":{"component":"strings/SendString","metadata":{"x":765,"y":-284,"label":"SetStart"}},"math/Divide_x4gc8":{"component":"math/Divide","metadata":{"x":2939,"y":-199,"label":"math/Divide"}},"core/Split_x0a12":{"component":"core/Split","metadata":{"x":2151,"y":23,"label":"core/Split"}},"objects/CallMethod_iu7k2":{"component":"objects/CallMethod","metadata":{"x":2348,"y":167,"label":"objects/CallMethod"}},"objects/CallMethod_rtfd2":{"component":"objects/CallMethod","metadata":{"x":2139,"y":-274,"label":"objects/CallMethod"}},"Distance_kwk39":{"component":"core/Repeat","metadata":{"x":2580,"y":20,"label":"Distance"}},"GestureElements_yvm9m":{"component":"core/Repeat","metadata":{"x":1639,"y":4,"label":"GestureElements"}},"Angle_43qpo":{"component":"core/Repeat","metadata":{"x":2312,"y":-121,"label":"Angle"}},"Speed_e99jq":{"component":"core/Repeat","metadata":{"x":3362,"y":-171,"label":"Speed"}},"MovePoint_fjlur":{"component":"core/Repeat","metadata":{"x":1939,"y":262,"label":"MovePoint"}},"StartPoint_u8int":{"component":"core/Repeat","metadata":{"x":1382,"y":-189,"label":"StartPoint"}},"gestures/ListenPointer_8ftd1":{"component":"gestures/ListenPointer","metadata":{"x":213,"y":-1,"label":"gestures/ListenPointer"}},"GetEndElement_slbp9":{"component":"objects/GetObjectKey","metadata":{"x":1367.3333333333335,"y":283.3333333333335,"label":"GetEndElement"}},"core/RepeatAsync_c56tj":{"component":"core/RepeatAsync","metadata":{"x":1058.666666666667,"y":312.33333333333326,"label":"core/RepeatAsync"}},"strings/SendString_t6gby":{"component":"strings/SendString","metadata":{"x":1935,"y":166.33333333333337,"label":"strings/SendString"}},"groups/SendByGroup_z06kk":{"component":"groups/SendByGroup","metadata":{"x":556,"y":-151.66666666666669,"label":"groups/SendByGroup"}},"core/Split_ekxij":{"component":"core/Split","metadata":{"x":3158.5,"y":-166.33333333333343,"label":"core/Split"}},"core/Split_eph3d":{"component":"core/Split","metadata":{"x":2123.333333333334,"y":-122.66666666666669,"label":"core/Split"}},"core/Split_3elep":{"component":"core/Split","metadata":{"x":2731.1666666666697,"y":-171.83333333333258,"label":"core/Split"}},"core/Split_8l3yu":{"component":"core/Split","metadata":{"x":1251.3333333333333,"y":7.166666666666629,"label":"core/Split"}},"CurrentElement_cu0q5":{"component":"core/Repeat","metadata":{"x":1599.833333333333,"y":-192.00000000000006,"label":"CurrentElement"}},"Duration_qyevv":{"component":"core/Repeat","metadata":{"x":2937.833333333333,"y":-295.83333333333326,"label":"Duration"}},"GetEndingPoint_dettb":{"component":"interaction/ReadCoordinates","metadata":{"x":727.8333333333331,"y":335.3333333333333,"label":"GetEndingPoint"}},"core/Merge_6so":{"component":"core/Merge","metadata":{"x":1196.666666666667,"y":-188.99999999999983,"label":"core/Merge"}},"interaction/ReadCoordinates_82cb1":{"component":"interaction/ReadCoordinates","metadata":{"x":767.3333333333339,"y":-85.83333333333314,"label":"interaction/ReadCoordinates"}},"core/Drop_sa8z5":{"component":"core/Drop","metadata":{"x":1596.833333333333,"y":326.0000000000001,"label":"core/Drop"}},"core/Merge_lqxll":{"component":"core/Merge","metadata":{"x":768.9999999999995,"y":-403.66666666666663,"label":"core/Merge"}},"groups/SendByGroup_8yaj":{"component":"groups/SendByGroup","metadata":{"x":1166.999999999999,"y":-286.83333333333326,"label":"groups/SendByGroup"}}},"connections":[{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"origin"},"metadata":{"route":5}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"destination"},"metadata":{"route":3}},{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"origin"},"metadata":{"route":5}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"destination"},"metadata":{"route":3}},{"src":{"process":"GetMovePoint_9dia9","port":"client"},"tgt":{"process":"core/Split_baeeb","port":"in"},"metadata":{"route":3}},{"src":{"process":"GetStartingPoint_pidfs","port":"client"},"tgt":{"process":"core/Split_4ds1h","port":"in"},"metadata":{"route":5}},{"src":{"process":"SetStart_ql51c","port":"out"},"tgt":{"process":"StartDate_swbwu","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureDistance_esqkc","port":"distance"},"tgt":{"process":"core/Split_x0a12","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"dividend"},"metadata":{"route":9}},{"src":{"process":"objects/CallMethod_iu7k2","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"minuend"},"metadata":{"route":3}},{"src":{"process":"MoveDate_6bjnl","port":"out"},"tgt":{"process":"objects/CallMethod_iu7k2","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"Distance_kwk39","port":"in"},"metadata":{"route":9}},{"src":{"process":"AllTouchedElements_i3x74","port":"out"},"tgt":{"process":"GestureElements_yvm9m","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"MovePoint_fjlur","port":"in"},"metadata":{"route":3}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"end"},"tgt":{"process":"GestureEnd_qqx8o","port":"in"},"metadata":{"route":1}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"move"},"tgt":{"process":"GestureMove_hy46s","port":"in"},"metadata":{"route":3}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"start"},"tgt":{"process":"GestureStart_r8vr5","port":"in"},"metadata":{"route":5}},{"src":{"process":"LastMove_p5yj7","port":"out"},"tgt":{"process":"GetEndElement_slbp9","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"LastMove_p5yj7","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"core/RepeatAsync_c56tj","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"strings/SendString_t6gby","port":"in"},"metadata":{"route":3}},{"src":{"process":"strings/SendString_t6gby","port":"out"},"tgt":{"process":"MoveDate_6bjnl","port":"in"},"metadata":{"route":4}},{"src":{"process":"groups/SendByGroup_z06kk","port":"out"},"tgt":{"process":"GetStartingPoint_pidfs","port":"event"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"groups/SendByGroup_z06kk","port":"data"},"metadata":{"route":5}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"groups/SendByGroup_z06kk","port":"in"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"LastMove_p5yj7","port":"data"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"GetMoveElement_iaexm","port":"in"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"GetMovePoint_9dia9","port":"event"},"metadata":{"route":3}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"clear"},"metadata":{"route":0}},{"src":{"process":"core/Split_ekxij","port":"out"},"tgt":{"process":"Speed_e99jq","port":"in"},"metadata":{"route":8}},{"src":{"process":"math/Divide_x4gc8","port":"quotient"},"tgt":{"process":"core/Split_ekxij","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_ekxij","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"clear"},"metadata":{"route":0}},{"src":{"process":"core/RepeatAsync_c56tj","port":"out"},"tgt":{"process":"AllTouchedElements_i3x74","port":"clear"},"metadata":{"route":1}},{"src":{"process":"GestureAngle_dwjj","port":"angle"},"tgt":{"process":"core/Split_eph3d","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_eph3d","port":"out"},"tgt":{"process":"Angle_43qpo","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_eph3d","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"clear"},"metadata":{"route":0}},{"src":{"process":"math/Subtract_j5v20","port":"difference"},"tgt":{"process":"core/Split_3elep","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"divisor"},"metadata":{"route":9}},{"src":{"process":"GetMoveElement_iaexm","port":"out"},"tgt":{"process":"core/Split_8l3yu","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_8l3yu","port":"out"},"tgt":{"process":"AllTouchedElements_i3x74","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_8l3yu","port":"out"},"tgt":{"process":"CurrentElement_cu0q5","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"Duration_qyevv","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"clear"},"metadata":{"route":0}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"GetEndingPoint_dettb","port":"event"},"metadata":{"route":1}},{"src":{"process":"objects/CallMethod_rtfd2","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"subtrahend"},"metadata":{"route":5}},{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"core/Merge_6so","port":"in"},"metadata":{"route":5}},{"src":{"process":"core/Merge_6so","port":"out"},"tgt":{"process":"StartPoint_u8int","port":"in"},"metadata":{"route":5}},{"src":{"process":"interaction/ReadCoordinates_82cb1","port":"client"},"tgt":{"process":"core/Merge_6so","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"interaction/ReadCoordinates_82cb1","port":"event"},"metadata":{"route":5}},{"src":{"process":"GetEndElement_slbp9","port":"missed"},"tgt":{"process":"core/Drop_sa8z5","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"core/Merge_lqxll","port":"in"},"metadata":{"route":5}},{"src":{"process":"core/Merge_lqxll","port":"out"},"tgt":{"process":"GetStartElement_w7m64","port":"in"},"metadata":{"route":5}},{"src":{"process":"groups/SendByGroup_z06kk","port":"out"},"tgt":{"process":"core/Merge_lqxll","port":"in"},"metadata":{"route":5}},{"src":{"process":"groups/SendByGroup_8yaj","port":"out"},"tgt":{"process":"objects/CallMethod_rtfd2","port":"in"},"metadata":{"route":5}},{"src":{"process":"StartDate_swbwu","port":"out"},"tgt":{"process":"groups/SendByGroup_8yaj","port":"data"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"SetStart_ql51c","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"groups/SendByGroup_8yaj","port":"in"},"metadata":{"route":3}},{"data":"target","tgt":{"process":"GetMoveElement_iaexm","port":"key"}},{"data":"target","tgt":{"process":"GetStartElement_w7m64","port":"key"}},{"data":"now","tgt":{"process":"SetStart_ql51c","port":"string"}},{"data":"getTime","tgt":{"process":"objects/CallMethod_iu7k2","port":"method"}},{"data":"getTime","tgt":{"process":"objects/CallMethod_rtfd2","port":"method"}},{"data":"target","tgt":{"process":"GetEndElement_slbp9","port":"key"}},{"data":"now","tgt":{"process":"strings/SendString_t6gby","port":"string"}}]}');
});
require.register("noflo-noflo-gestures/graphs/ListenPointer.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"name":"ListenPointer"},"exports":[{"private":"Listen_1025g.element","public":"element"},{"private":"Listen_1025g.capture","public":"capture"},{"private":"StartEvent_x8itv.out","public":"start"},{"private":"MoveEvent_qa3pp.out","public":"move"},{"private":"EndEvent_hmwp9.out","public":"end"}],"processes":{"Listen_1025g":{"component":"interaction/ListenPointer","metadata":{"x":500,"y":-65,"label":"Listen"}},"End_vom22":{"component":"core/Merge","metadata":{"x":843,"y":96,"label":"End"}},"Start_86u3g":{"component":"core/Split","metadata":{"x":848,"y":-157,"label":"Start"}},"MoveOnlyDuringGesture_986zt":{"component":"flow/Gate","metadata":{"x":1106,"y":-40,"label":"MoveOnlyDuringGesture"}},"EndOnlyOnce_vexfn":{"component":"flow/Gate","metadata":{"x":1107,"y":75,"label":"EndOnlyOnce"}},"SplitEnd_cnfy6":{"component":"core/Split","metadata":{"x":1407,"y":79,"label":"SplitEnd"}},"Asynchronize_x0hqm":{"component":"core/RepeatAsync","metadata":{"x":1404,"y":171.33333333333331,"label":"Asynchronize"}},"StartEvent_x8itv":{"component":"core/Repeat","metadata":{"x":1662,"y":-162,"label":"StartEvent"}},"MoveEvent_qa3pp":{"component":"core/Repeat","metadata":{"x":1662,"y":-35,"label":"MoveEvent"}},"EndEvent_hmwp9":{"component":"core/Repeat","metadata":{"x":1659,"y":75,"label":"EndEvent"}}},"connections":[{"src":{"process":"Listen_1025g","port":"leave"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"cancel"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"up"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"down"},"tgt":{"process":"Start_86u3g","port":"in"},"metadata":{"route":5}},{"src":{"process":"Listen_1025g","port":"move"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"in"},"metadata":{"route":3}},{"src":{"process":"End_vom22","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"in"},"metadata":{"route":1}},{"src":{"process":"EndOnlyOnce_vexfn","port":"out"},"tgt":{"process":"SplitEnd_cnfy6","port":"in"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"Asynchronize_x0hqm","port":"in"},"metadata":{"route":1}},{"src":{"process":"Asynchronize_x0hqm","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"close"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"close"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"StartEvent_x8itv","port":"in"},"metadata":{"route":5}},{"src":{"process":"MoveOnlyDuringGesture_986zt","port":"out"},"tgt":{"process":"MoveEvent_qa3pp","port":"in"},"metadata":{"route":3}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"EndEvent_hmwp9","port":"in"},"metadata":{"route":1}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectCardinalDirection.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectCardinalDirection"},"exports":[{"private":"receivegesture_thbmw.in","public":"in"},{"private":"sendeast_218qx.out","public":"east"},{"private":"sendsouth_wx2b5.out","public":"south"},{"private":"sendwest_rkdz9.out","public":"west"},{"private":"sendnorth_c562k.out","public":"north"},{"private":"fail_5b0qo.out","public":"fail"},{"private":"checkmaxdistance_cebq5.comparison","public":"maxdistance"}],"processes":{"ReceiveGesture_thbmw":{"component":"core/Repeat","metadata":{"x":-294,"y":134,"label":"ReceiveGesture"}},"SplitGesture_dkk87":{"component":"core/Split","metadata":{"x":-296,"y":214,"label":"SplitGesture"}},"SendNorth_c562k":{"component":"strings/SendString","metadata":{"x":1733,"y":447,"label":"SendNorth"}},"SendEast_218qx":{"component":"strings/SendString","metadata":{"x":1721,"y":-5,"label":"SendEast"}},"RouteDirection_apgsp":{"component":"gestures/CardinalRouter","metadata":{"x":1469,"y":195,"label":"RouteDirection"}},"GetIndividualPointer_ozjfa":{"component":"objects/SplitObject","metadata":{"x":-86,"y":214,"label":"GetIndividualPointer"}},"GetStartPoint_bhrl2":{"component":"objects/GetObjectKey","metadata":{"x":879,"y":157,"label":"GetStartPoint"}},"GetCurrentPoint_rwwt0":{"component":"objects/GetObjectKey","metadata":{"x":877,"y":259,"label":"GetCurrentPoint"}},"GetGestureAngle_djpr6":{"component":"math/CalculateAngle","metadata":{"x":1083,"y":193,"label":"GetGestureAngle"}},"SendWest_rkdz9":{"component":"strings/SendString","metadata":{"x":1730.8333333333333,"y":348.33333333333337,"label":"SendWest"}},"SendSouth_wx2b5":{"component":"strings/SendString","metadata":{"x":1721.8333333333333,"y":107.33333333333337,"label":"SendSouth"}},"Fail_5b0qo":{"component":"core/Merge","metadata":{"x":1738.1666666666665,"y":564,"label":"Fail"}},"core/Split_n3qif":{"component":"core/Split","metadata":{"x":1276.999999999999,"y":193.66666666666669,"label":"core/Split"}},"GetDistance_owyyb":{"component":"objects/GetObjectKey","metadata":{"x":304,"y":216,"label":"GetDistance"}},"CheckMaxDistance_cebq5":{"component":"math/Compare","metadata":{"x":499,"y":214,"label":"CheckMaxDistance"}},"SendPointer_v0eqv":{"component":"strings/SendString","metadata":{"x":688,"y":214,"label":"SendPointer"}},"SplitPointer_v0u8k":{"component":"core/Split","metadata":{"x":109.00000000000006,"y":215.33333333333331,"label":"SplitPointer"}}},"connections":[{"src":{"process":"GetStartPoint_bhrl2","port":"object"},"tgt":{"process":"GetCurrentPoint_rwwt0","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetStartPoint_bhrl2","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"origin"},"metadata":{"route":9}},{"src":{"process":"GetCurrentPoint_rwwt0","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"destination"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendEast_218qx","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendWest_rkdz9","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendNorth_c562k","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendSouth_wx2b5","port":"string"},"metadata":{"route":9}},{"src":{"process":"RouteDirection_apgsp","port":"n"},"tgt":{"process":"SendNorth_c562k","port":"in"},"metadata":{"route":4}},{"src":{"process":"RouteDirection_apgsp","port":"w"},"tgt":{"process":"SendWest_rkdz9","port":"in"},"metadata":{"route":5}},{"src":{"process":"RouteDirection_apgsp","port":"s"},"tgt":{"process":"SendSouth_wx2b5","port":"in"},"metadata":{"route":6}},{"src":{"process":"RouteDirection_apgsp","port":"e"},"tgt":{"process":"SendEast_218qx","port":"in"},"metadata":{"route":7}},{"src":{"process":"ReceiveGesture_thbmw","port":"out"},"tgt":{"process":"SplitGesture_dkk87","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"GetIndividualPointer_ozjfa","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetCurrentPoint_rwwt0","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetStartPoint_bhrl2","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetGestureAngle_djpr6","port":"angle"},"tgt":{"process":"core/Split_n3qif","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_n3qif","port":"out"},"tgt":{"process":"RouteDirection_apgsp","port":"degrees"},"metadata":{"route":9}},{"src":{"process":"core/Split_n3qif","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"clear"},"metadata":{"route":0}},{"src":{"process":"GetIndividualPointer_ozjfa","port":"out"},"tgt":{"process":"SplitPointer_v0u8k","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_v0u8k","port":"out"},"tgt":{"process":"SendPointer_v0eqv","port":"string"},"metadata":{"route":9}},{"src":{"process":"SendPointer_v0eqv","port":"out"},"tgt":{"process":"GetStartPoint_bhrl2","port":"in"},"metadata":{"route":9}},{"src":{"process":"CheckMaxDistance_cebq5","port":"pass"},"tgt":{"process":"SendPointer_v0eqv","port":"in"},"metadata":{"route":9}},{"src":{"process":"CheckMaxDistance_cebq5","port":"fail"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_owyyb","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"SplitPointer_v0u8k","port":"out"},"tgt":{"process":"GetDistance_owyyb","port":"in"},"metadata":{"route":0}},{"src":{"process":"GetDistance_owyyb","port":"out"},"tgt":{"process":"CheckMaxDistance_cebq5","port":"value"},"metadata":{"route":9}},{"data":"startpoint","tgt":{"process":"GetStartPoint_bhrl2","port":"key"}},{"data":"movepoint","tgt":{"process":"GetCurrentPoint_rwwt0","port":"key"}},{"data":"distance","tgt":{"process":"GetDistance_owyyb","port":"key"}},{"data":"<=","tgt":{"process":"CheckMaxDistance_cebq5","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-gestures","description":"Gesture recognition components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-gestures","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*","noflo/noflo-interaction":"*","noflo/noflo-math":"*","noflo/noflo-flow":"*","noflo/noflo-groups":"*","noflo/noflo-packets":"*","noflo/noflo-objects":"*","noflo/noflo-dom":"*","noflo/noflo-strings":"*","noflo/noflo-core":"*"},"scripts":["components/CalculateCenter.coffee","components/CalculateScale.coffee","components/CardinalRouter.coffee","components/DegreesToCardinal.coffee","components/DegreesToCompass.coffee","components/DetectScratch.coffee","components/DetectTarget.coffee","graphs/DetectDrag.json","graphs/DetectSwipe.json","graphs/DetectPinch.json","graphs/FilterByTarget.json","graphs/GestureToObject.json","graphs/ListenGestures.json","graphs/ListenPointer.json","graphs/DetectCardinalDirection.json","index.js"],"json":["graphs/DetectDrag.json","graphs/DetectSwipe.json","graphs/DetectPinch.json","graphs/FilterByTarget.json","graphs/GestureToObject.json","graphs/ListenGestures.json","graphs/ListenPointer.json","graphs/DetectCardinalDirection.json","component.json"],"noflo":{"icon":"hand-o-right","components":{"CalculateCenter":"components/CalculateCenter.coffee","CalculateScale":"components/CalculateScale.coffee","CardinalRouter":"components/CardinalRouter.coffee","DegreesToCardinal":"components/DegreesToCardinal.coffee","DegreesToCompass":"components/DegreesToCompass.coffee","DetectScratch":"components/DetectScratch.coffee","DetectTarget":"components/DetectTarget.coffee"},"graphs":{"DetectDrag":"graphs/DetectDrag.json","DetectSwipe":"graphs/DetectSwipe.json","DetectPinch":"graphs/DetectPinch.json","FilterByTarget":"graphs/FilterByTarget.json","GestureToObject":"graphs/GestureToObject.json","ListenGestures":"graphs/ListenGestures.json","ListenPointer":"graphs/ListenPointer.json","DetectCardinalDirection":"graphs/DetectCardinalDirection.json"}}}');
});
require.register("noflo-noflo-gestures/components/CalculateCenter.js", function(exports, require, module){
var CalculateCenter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CalculateCenter = (function(_super) {
  __extends(CalculateCenter, _super);

  CalculateCenter.prototype.description = 'Calculate the center point for a gesture';

  function CalculateCenter() {
    this.inPorts = {
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      center: new noflo.Port('object')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(gesture) {
        return _this.outPorts.center.send(_this.calculateCenter(gesture));
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.center.disconnect();
      };
    })(this));
  }

  CalculateCenter.prototype.calculateCenter = function(gesture) {
    var center, id, startX, startY, touch;
    if (Object.keys(gesture).length === 1) {
      return gesture.startpoint;
    }
    startX = [];
    startY = [];
    for (id in gesture) {
      touch = gesture[id];
      if (!touch) {
        continue;
      }
      if (!touch.startpoint) {
        continue;
      }
      startX.push(touch.startpoint.x);
      startY.push(touch.startpoint.y);
    }
    return center = {
      x: Math.min.apply(Math, startX) + Math.max.apply(Math, startX) / 2,
      y: Math.min.apply(Math, startY) + Math.max.apply(Math, startY) / 2
    };
  };

  return CalculateCenter;

})(noflo.Component);

exports.getComponent = function() {
  return new CalculateCenter;
};

});
require.register("noflo-noflo-gestures/components/CalculateScale.js", function(exports, require, module){
var CalculateScale, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CalculateScale = (function(_super) {
  __extends(CalculateScale, _super);

  CalculateScale.prototype.description = 'Calculate the scale based on gestural movement';

  function CalculateScale() {
    this.inPorts = {
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      scale: new noflo.Port('number')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(gesture) {
        return _this.outPorts.scale.send(_this.calculateScale(gesture));
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.scale.disconnect();
      };
    })(this));
  }

  CalculateScale.prototype.calculateScale = function(gesture) {
    var id, movePoints, scale, startPoints, touch;
    if (Object.keys(gesture).length === 1) {
      return 1;
    }
    startPoints = [];
    movePoints = [];
    for (id in gesture) {
      touch = gesture[id];
      if (touch.startpoint) {
        startPoints.push(touch.startpoint);
      }
      if (touch.movepoint) {
        movePoints.push(touch.movepoint);
      }
    }
    if (startPoints.length < 2 || movePoints.length < 2) {
      return 1;
    }
    scale = this.calculateDistance(movePoints[0], movePoints[1]) / this.calculateDistance(startPoints[0], startPoints[1]);
    return scale;
  };

  CalculateScale.prototype.calculateDistance = function(origin, destination) {
    var deltaX, deltaY, distance;
    deltaX = destination.x - origin.x;
    deltaY = destination.y - origin.y;
    origin = null;
    destination = null;
    distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    return distance;
  };

  return CalculateScale;

})(noflo.Component);

exports.getComponent = function() {
  return new CalculateScale;
};

});
require.register("noflo-noflo-gestures/components/CardinalRouter.js", function(exports, require, module){
var CardinalRouter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CardinalRouter = (function(_super) {
  __extends(CardinalRouter, _super);

  CardinalRouter.prototype.description = 'Route values based on their cardinal directions';

  CardinalRouter.prototype.icon = 'compass';

  function CardinalRouter() {
    var headings;
    this.inPorts = {
      degrees: new noflo.Port('number')
    };
    this.outPorts = {
      e: new noflo.Port('number'),
      s: new noflo.Port('number'),
      w: new noflo.Port('number'),
      n: new noflo.Port('number')
    };
    headings = ['e', 's', 'w', 'n'];
    this.inPorts.degrees.on('data', (function(_this) {
      return function(degrees) {
        var heading, index;
        index = degrees - 45;
        if (index < 0) {
          index = index + 360;
        }
        index = parseInt(index / 90);
        heading = headings[index];
        if (!_this.outPorts[heading].isAttached()) {
          return;
        }
        _this.outPorts[heading].send(degrees);
        return _this.outPorts[heading].disconnect();
      };
    })(this));
  }

  return CardinalRouter;

})(noflo.Component);

exports.getComponent = function() {
  return new CardinalRouter;
};

});
require.register("noflo-noflo-gestures/components/DegreesToCardinal.js", function(exports, require, module){
var DegreesToCardinal, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DegreesToCardinal = (function(_super) {
  __extends(DegreesToCardinal, _super);

  DegreesToCardinal.prototype.description = 'Convert a heading in degrees to a cardinal direction, e.g. N, S';

  DegreesToCardinal.prototype.icon = 'compass';

  function DegreesToCardinal() {
    var headings;
    this.inPorts = {
      degrees: new noflo.Port('number')
    };
    this.outPorts = {
      heading: new noflo.Port('string')
    };
    headings = ['E', 'S', 'W', 'N'];
    this.inPorts.degrees.on('data', (function(_this) {
      return function(degrees) {
        var index;
        index = degrees - 45;
        if (index < 0) {
          index = index + 360;
        }
        index = parseInt(index / 90);
        return _this.outPorts.heading.send(headings[index]);
      };
    })(this));
    this.inPorts.degrees.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.heading.disconnect();
      };
    })(this));
  }

  return DegreesToCardinal;

})(noflo.Component);

exports.getComponent = function() {
  return new DegreesToCardinal;
};

});
require.register("noflo-noflo-gestures/components/DegreesToCompass.js", function(exports, require, module){
var DegreesToCompass, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DegreesToCompass = (function(_super) {
  __extends(DegreesToCompass, _super);

  DegreesToCompass.prototype.description = 'Convert a heading in degrees to a compass direction, e.g. N, SW';

  DegreesToCompass.prototype.icon = 'compass';

  function DegreesToCompass() {
    var headings;
    this.inPorts = {
      degrees: new noflo.Port('number')
    };
    this.outPorts = {
      heading: new noflo.Port('string')
    };
    headings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
    this.inPorts.degrees.on('data', (function(_this) {
      return function(degrees) {
        var index;
        index = degrees - 22.5;
        if (index < 0) {
          index = index + 360;
        }
        index = parseInt(index / 45);
        return _this.outPorts.heading.send(headings[index]);
      };
    })(this));
    this.inPorts.degrees.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.heading.disconnect();
      };
    })(this));
  }

  return DegreesToCompass;

})(noflo.Component);

exports.getComponent = function() {
  return new DegreesToCompass;
};

});
require.register("noflo-noflo-gestures/components/DetectScratch.js", function(exports, require, module){
var DetectScratch, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DetectScratch = (function(_super) {
  __extends(DetectScratch, _super);

  function DetectScratch() {
    this.minturns = 3;
    this.distance = 20;
    this.minSpeed = 0;
    this.prevPoint = null;
    this.prevAngle = null;
    this.prevTime = null;
    this.speedChecked = false;
    this.turns = 0;
    this.inPorts = {
      "in": new noflo.Port('object'),
      distance: new noflo.Port('number'),
      speed: new noflo.Port('number')
    };
    this.outPorts = {
      pass: new noflo.Port('object'),
      fail: new noflo.Port('object')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (Object.keys(data).length > 1) {
          _this.outPorts.fail.send(data);
          return;
        }
        return _this.detect(data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function(data) {
        _this.outPorts.pass.disconnect();
        return _this.outPorts.fail.disconnect();
      };
    })(this));
    this.inPorts.distance.on('data', (function(_this) {
      return function(distance) {
        _this.distance = distance;
      };
    })(this));
    this.inPorts.speed.on('data', (function(_this) {
      return function(minSpeed) {
        _this.minSpeed = minSpeed;
      };
    })(this));
  }

  DetectScratch.prototype.detect = function(gesture) {
    var angle, distance, elapsed, speed, time, touch, turn;
    touch = gesture[Object.keys(gesture)[0]];
    if (touch.endpoint) {
      this.reset();
      this.outPorts.fail.send(gesture);
      return;
    }
    if (!this.prevPoint) {
      this.prevPoint = touch.startpoint;
      this.prevTime = new Date;
      return;
    }
    distance = this.calculateDistance(this.prevPoint, touch.movepoint);
    if (distance < this.distance) {
      return;
    }
    time = new Date;
    if (!this.speedChecked) {
      elapsed = time.getTime() - this.prevTime.getTime();
      speed = distance / elapsed;
      if (speed < this.minSpeed) {
        this.reset();
        this.outPorts.fail.send(gesture);
        return;
      }
      this.speedChecked = true;
    }
    angle = this.calculateAngle(this.prevPoint, touch.movepoint);
    if (!this.prevAngle) {
      this.prevAngle = angle;
      return;
    }
    turn = Math.abs(this.angleChange(this.prevAngle, angle));
    this.prevPoint = touch.movepoint;
    this.prevAngle = angle;
    if (!(turn > 130)) {
      return;
    }
    this.prevTime = time;
    this.turns++;
    if (this.turns >= this.minturns) {
      this.reset();
      return this.outPorts.pass.send(gesture);
    }
  };

  DetectScratch.prototype.calculateDistance = function(origin, destination) {
    var deltaX, deltaY, distance;
    deltaX = destination.x - origin.x;
    deltaY = destination.y - origin.y;
    distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    return distance;
  };

  DetectScratch.prototype.calculateAngle = function(origin, destination) {
    var angle, deltaX, deltaY;
    deltaX = destination.x - origin.x;
    deltaY = destination.y - origin.y;
    angle = (Math.atan2(deltaY, deltaX) * 180 / Math.PI) + 90;
    if (angle < 0) {
      angle = angle + 360;
    }
    return angle;
  };

  DetectScratch.prototype.angleChange = function(previous, current) {
    var difference;
    difference = current - previous;
    while (difference < -180) {
      difference += 360;
    }
    while (difference > 180) {
      difference -= 360;
    }
    return difference;
  };

  DetectScratch.prototype.reset = function() {
    this.turns = 0;
    this.prevPoint = null;
    this.prevAngle = null;
    this.prevTime = null;
    return this.speedChecked = false;
  };

  return DetectScratch;

})(noflo.Component);

exports.getComponent = function() {
  return new DetectScratch;
};

});
require.register("noflo-noflo-gestures/components/DetectTarget.js", function(exports, require, module){
var DetectTarget, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DetectTarget = (function(_super) {
  __extends(DetectTarget, _super);

  DetectTarget.prototype.describe = 'Verify that the gesture target has the right properties';

  function DetectTarget() {
    this.target = null;
    this.key = 'current';
    this.inPorts = {
      "in": new noflo.Port('object'),
      key: new noflo.Port('string'),
      target: new noflo.Port('string'),
      clear: new noflo.Port('bang')
    };
    this.outPorts = {
      pass: new noflo.Port('object'),
      fail: new noflo.Port('object'),
      target: new noflo.Port('object')
    };
    this.inPorts.target.on('data', (function(_this) {
      return function(data) {
        var parts;
        parts = data.split('=');
        if (!_this.target) {
          _this.target = {};
        }
        return _this.target[parts[0]] = parts[1];
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(key) {
        _this.key = key;
      };
    })(this));
    this.inPorts.clear.on('data', (function(_this) {
      return function() {
        return _this.target = null;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var element, passed, touch;
        if (Object.keys(data).length > 1) {
          passed = true;
          for (touch in data) {
            element = data[touch];
            if (!_this.detectTarget(element)) {
              passed = false;
            }
          }
          if (passed) {
            if (_this.outPorts.target.isAttached()) {
              _this.outPorts.target.send(data[Object.keys(data)[0]][_this.key]);
            }
            _this.outPorts.pass.send(data);
          } else {
            _this.outPorts.fail.send(data);
          }
          return;
        }
        if (_this.detectTarget(data[Object.keys(data)[0]])) {
          if (_this.outPorts.target.isAttached()) {
            _this.outPorts.target.send(data[Object.keys(data)[0]][_this.key]);
          }
          return _this.outPorts.pass.send(data);
        } else {
          return _this.outPorts.fail.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.pass.disconnect();
        _this.outPorts.fail.disconnect();
        if (_this.outPorts.target.isAttached()) {
          return _this.outPorts.target.disconnect();
        }
      };
    })(this));
  }

  DetectTarget.prototype.detectTarget = function(element) {
    var key, value, _ref;
    if (!element[this.key]) {
      return false;
    }
    _ref = this.target;
    for (key in _ref) {
      value = _ref[key];
      if (element[this.key][key] !== value) {
        return false;
      }
    }
    return true;
  };

  return DetectTarget;

})(noflo.Component);

exports.getComponent = function() {
  return new DetectTarget;
};

});
require.register("noflo-noflo-groups/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of groups.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-groups/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-groups","description":"Group Utilities for NoFlo","keywords":["noflo","groups","utilities"],"author":"Kenneth Kan <kenhkan@gmail.com>","version":"0.1.0","repo":"kenhkan/groups","dependencies":{"component/underscore":"*","noflo/noflo":"*"},"scripts":["components/ReadGroups.coffee","components/RemoveGroups.coffee","components/Regroup.coffee","components/Group.coffee","components/GroupZip.coffee","components/FilterByGroup.coffee","components/Objectify.coffee","components/ReadGroup.coffee","components/SendByGroup.coffee","components/CollectGroups.coffee","components/CollectObject.coffee","components/FirstGroup.coffee","components/MapGroup.coffee","components/MergeGroups.coffee","components/GroupByObjectKey.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"tags","components":{"ReadGroups":"components/ReadGroups.coffee","RemoveGroups":"components/RemoveGroups.coffee","Regroup":"components/Regroup.coffee","Group":"components/Group.coffee","GroupZip":"components/GroupZip.coffee","FilterByGroup":"components/FilterByGroup.coffee","Objectify":"components/Objectify.coffee","ReadGroup":"components/ReadGroup.coffee","SendByGroup":"components/SendByGroup.coffee","CollectGroups":"components/CollectGroups.coffee","CollectObject":"components/CollectObject.coffee","FirstGroup":"components/FirstGroup.coffee","MapGroup":"components/MapGroup.coffee","MergeGroups":"components/MergeGroups.coffee","GroupByObjectKey":"components/GroupByObjectKey.coffee"}}}');
});
require.register("noflo-noflo-groups/components/ReadGroups.js", function(exports, require, module){
var ReadGroups, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore');

ReadGroups = (function(_super) {
  __extends(ReadGroups, _super);

  function ReadGroups() {
    this.strip = false;
    this.threshold = Infinity;
    this.inPorts = {
      "in": new noflo.ArrayPort,
      strip: new noflo.Port,
      threshold: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      group: new noflo.Port
    };
    this.inPorts.threshold.on('data', (function(_this) {
      return function(threshold) {
        return _this.threshold = parseInt(threshold);
      };
    })(this));
    this.inPorts.strip.on('data', (function(_this) {
      return function(strip) {
        return _this.strip = strip === 'true';
      };
    })(this));
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        _this.count = 0;
        return _this.groups = [];
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        var beginGroup;
        beginGroup = function() {
          _this.groups.push(group);
          if (_this.outPorts.out.isAttached()) {
            return _this.outPorts.out.beginGroup(group);
          }
        };
        if (_this.count >= _this.threshold) {
          return beginGroup(group);
        } else {
          _this.outPorts.group.send(group);
          if (!_this.strip) {
            beginGroup(group);
          }
          return _this.count++;
        }
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        if (group === _.last(_this.groups)) {
          _this.groups.pop();
          if (_this.outPorts.out.isAttached()) {
            return _this.outPorts.out.endGroup();
          }
        }
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.outPorts.out.isAttached()) {
          _this.outPorts.out.disconnect();
        }
        return _this.outPorts.group.disconnect();
      };
    })(this));
  }

  return ReadGroups;

})(noflo.Component);

exports.getComponent = function() {
  return new ReadGroups;
};

});
require.register("noflo-noflo-groups/components/RemoveGroups.js", function(exports, require, module){
var RemoveGroups, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

RemoveGroups = (function(_super) {
  __extends(RemoveGroups, _super);

  RemoveGroups.prototype.description = "Remove a group given a string or a regex string";

  function RemoveGroups() {
    this.regexp = null;
    this.inPorts = {
      "in": new noflo.Port,
      regexp: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.regexp.on("data", (function(_this) {
      return function(regexp) {
        return _this.regexp = new RegExp(regexp);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        if ((_this.regexp != null) && (group.match(_this.regexp) == null)) {
          return _this.outPorts.out.beginGroup(group);
        }
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        if ((_this.regexp != null) && (group.match(_this.regexp) == null)) {
          return _this.outPorts.out.endGroup();
        }
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return RemoveGroups;

})(noflo.Component);

exports.getComponent = function() {
  return new RemoveGroups;
};

});
require.register("noflo-noflo-groups/components/Regroup.js", function(exports, require, module){
var Regroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

Regroup = (function(_super) {
  __extends(Regroup, _super);

  Regroup.prototype.description = "Forward all the data IPs, strip all groups, and replace them with groups from another connection";

  function Regroup() {
    this.groups = [];
    this.inPorts = {
      "in": new noflo.Port,
      group: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.group.on("connect", (function(_this) {
      return function() {
        return _this.groups = [];
      };
    })(this));
    this.inPorts.group.on("data", (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        var group, _i, _len, _ref, _results;
        _ref = _this.groups;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _results.push(_this.outPorts.out.beginGroup(group));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var group, _i, _len, _ref;
        _ref = _this.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.endGroup();
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Regroup;

})(noflo.Component);

exports.getComponent = function() {
  return new Regroup;
};

});
require.register("noflo-noflo-groups/components/Group.js", function(exports, require, module){
var Group, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

Group = (function(_super) {
  __extends(Group, _super);

  function Group() {
    this.newGroups = [];
    this.inPorts = {
      "in": new noflo.Port,
      group: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        var group, _i, _len, _ref, _results;
        _ref = _this.newGroups;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _results.push(_this.outPorts.out.beginGroup(group));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var group, _i, _len, _ref;
        _ref = _this.newGroups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.endGroup();
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.group.on("connect", (function(_this) {
      return function() {
        return _this.newGroups = [];
      };
    })(this));
    this.inPorts.group.on("data", (function(_this) {
      return function(group) {
        return _this.newGroups.push(group);
      };
    })(this));
  }

  return Group;

})(noflo.Component);

exports.getComponent = function() {
  return new Group;
};

});
require.register("noflo-noflo-groups/components/GroupZip.js", function(exports, require, module){
var GroupZip, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

GroupZip = (function(_super) {
  __extends(GroupZip, _super);

  function GroupZip() {
    this.newGroups = [];
    this.inPorts = {
      "in": new noflo.Port,
      group: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        return _this.count = 0;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        _this.outPorts.out.beginGroup(_this.newGroups[_this.count++]);
        _this.outPorts.out.send(data);
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.group.on("connect", (function(_this) {
      return function() {
        return _this.newGroups = [];
      };
    })(this));
    this.inPorts.group.on("data", (function(_this) {
      return function(group) {
        return _this.newGroups.push(group);
      };
    })(this));
  }

  return GroupZip;

})(noflo.Component);

exports.getComponent = function() {
  return new GroupZip;
};

});
require.register("noflo-noflo-groups/components/FilterByGroup.js", function(exports, require, module){
var FilterByGroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

FilterByGroup = (function(_super) {
  __extends(FilterByGroup, _super);

  FilterByGroup.prototype.description = "Given a RegExp string, filter out groups that do not match and their children data packets/groups. Forward only the content of the matching group.";

  function FilterByGroup() {
    this.regexp = null;
    this.matchedLevel = null;
    this.inPorts = {
      "in": new noflo.Port,
      regexp: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      group: new noflo.Port,
      empty: new noflo.Port
    };
    this.inPorts.regexp.on("data", (function(_this) {
      return function(regexp) {
        return _this.regexp = new RegExp(regexp);
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.level = 0;
        return _this.hasContent = false;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        if (_this.matchedLevel != null) {
          _this.outPorts.out.beginGroup(group);
        }
        _this.level++;
        if ((_this.matchedLevel == null) && (_this.regexp != null) && (group.match(_this.regexp) != null)) {
          _this.matchedLevel = _this.level;
          if (_this.outPorts.group.isAttached()) {
            return _this.outPorts.group.send(group);
          }
        }
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (_this.matchedLevel != null) {
          _this.hasContent = true;
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        if (_this.matchedLevel === _this.level) {
          _this.matchedLevel = null;
        }
        if (_this.matchedLevel != null) {
          _this.outPorts.out.endGroup();
        }
        return _this.level--;
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        if (!_this.hasContent && _this.outPorts.empty.isAttached()) {
          _this.outPorts.empty.send(null);
          _this.outPorts.empty.disconnect();
        }
        if (_this.outPorts.group.isAttached()) {
          _this.outPorts.group.disconnect();
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return FilterByGroup;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterByGroup;
};

});
require.register("noflo-noflo-groups/components/Objectify.js", function(exports, require, module){
var Objectify, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Objectify = (function(_super) {
  __extends(Objectify, _super);

  Objectify.prototype.description = "specify a regexp string, use the first match as the key of an object containing the data";

  function Objectify() {
    this.regexp = null;
    this.match = null;
    this.inPorts = {
      "in": new noflo.Port,
      regexp: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.regexp.on("data", (function(_this) {
      return function(regexp) {
        return _this.regexp = new RegExp(regexp);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        if ((_this.regexp != null) && (group.match(_this.regexp) != null)) {
          _this.match = _.first(group.match(_this.regexp));
        }
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var d;
        if (_this.match != null) {
          d = data;
          data = {};
          data[_this.match] = d;
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Objectify;

})(noflo.Component);

exports.getComponent = function() {
  return new Objectify;
};

});
require.register("noflo-noflo-groups/components/ReadGroup.js", function(exports, require, module){
var ReadGroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ReadGroup = (function(_super) {
  __extends(ReadGroup, _super);

  function ReadGroup() {
    this.groups = [];
    this.inPorts = {
      "in": new noflo.ArrayPort
    };
    this.outPorts = {
      out: new noflo.Port,
      group: new noflo.Port
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        _this.groups.push(group);
        _this.outPorts.group.beginGroup(group);
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.beginGroup(group);
        }
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.outPorts.out.isAttached()) {
          _this.outPorts.out.send(data);
        }
        if (!_this.groups.length) {
          return;
        }
        return _this.outPorts.group.send(_this.groups.join(':'));
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        _this.groups.pop();
        _this.outPorts.group.endGroup();
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.endGroup();
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        return _this.outPorts.group.disconnect();
      };
    })(this));
  }

  return ReadGroup;

})(noflo.Component);

exports.getComponent = function() {
  return new ReadGroup;
};

});
require.register("noflo-noflo-groups/components/SendByGroup.js", function(exports, require, module){
var SendByGroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SendByGroup = (function(_super) {
  __extends(SendByGroup, _super);

  SendByGroup.prototype.description = 'Send packet held in "data" when receiving matching set of groups in "in"';

  SendByGroup.prototype.icon = 'share-square';

  function SendByGroup() {
    this.data = {};
    this.ungrouped = null;
    this.dataGroups = [];
    this.inGroups = [];
    this.inPorts = {
      "in": new noflo.Port('bang'),
      data: new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('all')
    };
    this.inPorts.data.on('begingroup', (function(_this) {
      return function(group) {
        return _this.dataGroups.push(group);
      };
    })(this));
    this.inPorts.data.on('data', (function(_this) {
      return function(data) {
        if (!_this.dataGroups.length) {
          _this.ungrouped = data;
          return;
        }
        return _this.data[_this.groupId(_this.dataGroups)] = data;
      };
    })(this));
    this.inPorts.data.on('endgroup', (function(_this) {
      return function() {
        return _this.dataGroups.pop();
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.inGroups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var id;
        if (!_this.inGroups.length) {
          if (_this.ungrouped !== null) {
            _this.send(_this.ungrouped);
          }
          return;
        }
        id = _this.groupId(_this.inGroups);
        if (!_this.data[id]) {
          return;
        }
        return _this.send(_this.data[id]);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.inGroups.pop();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SendByGroup.prototype.groupId = function(groups) {
    return groups.join(':');
  };

  SendByGroup.prototype.send = function(data) {
    var group, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = this.inGroups;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      this.outPorts.out.beginGroup(group);
    }
    this.outPorts.out.send(data);
    _ref1 = this.inGroups;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      group = _ref1[_j];
      _results.push(this.outPorts.out.endGroup());
    }
    return _results;
  };

  return SendByGroup;

})(noflo.Component);

exports.getComponent = function() {
  return new SendByGroup;
};

});
require.register("noflo-noflo-groups/components/CollectGroups.js", function(exports, require, module){
var CollectGroups, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CollectGroups = (function(_super) {
  __extends(CollectGroups, _super);

  CollectGroups.prototype.description = 'Collect packets into object keyed by its groups';

  function CollectGroups() {
    this.data = {};
    this.groups = [];
    this.parents = [];
    this.inPorts = {
      "in": new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.data = {};
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        if (group === '$data') {
          _this.error('groups cannot be named \'$data\'');
          return;
        }
        _this.parents.push(_this.data);
        _this.groups.push(group);
        return _this.data = {};
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.setData(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        var data;
        data = _this.data;
        _this.data = _this.parents.pop();
        return _this.addChild(_this.data, _this.groups.pop(), data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.out.send(_this.data);
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  CollectGroups.prototype.addChild = function(parent, child, data) {
    if (!(child in parent)) {
      return parent[child] = data;
    }
    if (Array.isArray(parent[child])) {
      return parent[child].push(data);
    }
    return parent[child] = [parent[child], data];
  };

  CollectGroups.prototype.setData = function(data) {
    var _base;
    if ((_base = this.data).$data == null) {
      _base.$data = [];
    }
    return this.data.$data.push(data);
  };

  CollectGroups.prototype.error = function(msg) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(new Error(msg));
      this.outPorts.error.disconnect();
      return;
    }
    throw new Error(msg);
  };

  return CollectGroups;

})(noflo.Component);

exports.getComponent = function() {
  return new CollectGroups;
};

});
require.register("noflo-noflo-groups/components/CollectObject.js", function(exports, require, module){
var CollectObject, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CollectObject = (function(_super) {
  __extends(CollectObject, _super);

  CollectObject.prototype.description = 'Collect packets to an object identified by keys organized by connection';

  function CollectObject() {
    this.keys = [];
    this.allpackets = [];
    this.data = {};
    this.groups = {};
    this.inPorts = {
      keys: new noflo.ArrayPort('string'),
      allpackets: new noflo.ArrayPort('string'),
      collect: new noflo.ArrayPort('all'),
      release: new noflo.Port('bang'),
      clear: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.keys.on('data', (function(_this) {
      return function(key) {
        var keys, _i, _len, _results;
        keys = key.split(',');
        if (keys.length > 1) {
          _this.keys = [];
        }
        _results = [];
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          _results.push(_this.keys.push(key));
        }
        return _results;
      };
    })(this));
    this.inPorts.allpackets.on('data', (function(_this) {
      return function(key) {
        var allpackets, _i, _len, _results;
        allpackets = key.split(',');
        if (allpackets.length > 1) {
          _this.keys = [];
        }
        _results = [];
        for (_i = 0, _len = allpackets.length; _i < _len; _i++) {
          key = allpackets[_i];
          _results.push(_this.allpackets.push(key));
        }
        return _results;
      };
    })(this));
    this.inPorts.collect.once('connect', (function(_this) {
      return function() {
        return _this.subscribeSockets();
      };
    })(this));
    this.inPorts.release.on('data', (function(_this) {
      return function() {
        return _this.release();
      };
    })(this));
    this.inPorts.release.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.clear.on('data', (function(_this) {
      return function() {
        return _this.clear();
      };
    })(this));
  }

  CollectObject.prototype.release = function() {
    this.outPorts.out.send(this.data);
    return this.data = this.clone(this.data);
  };

  CollectObject.prototype.subscribeSockets = function() {
    return this.inPorts.collect.sockets.forEach((function(_this) {
      return function(socket, idx) {
        return _this.subscribeSocket(socket, idx);
      };
    })(this));
  };

  CollectObject.prototype.subscribeSocket = function(socket, id) {
    socket.on('begingroup', (function(_this) {
      return function(group) {
        if (!_this.groups[id]) {
          _this.groups[id] = [];
        }
        return _this.groups[id].push(group);
      };
    })(this));
    socket.on('data', (function(_this) {
      return function(data) {
        var groupId;
        if (!_this.keys[id]) {
          return;
        }
        groupId = _this.groupId(_this.groups[id]);
        if (!_this.data[groupId]) {
          _this.data[groupId] = {};
        }
        if (_this.allpackets.indexOf(_this.keys[id]) !== -1) {
          if (!_this.data[groupId][_this.keys[id]]) {
            _this.data[groupId][_this.keys[id]] = [];
          }
          _this.data[groupId][_this.keys[id]].push(data);
          return;
        }
        return _this.data[groupId][_this.keys[id]] = data;
      };
    })(this));
    return socket.on('endgroup', (function(_this) {
      return function() {
        if (!_this.groups[id]) {
          return;
        }
        return _this.groups[id].pop();
      };
    })(this));
  };

  CollectObject.prototype.groupId = function(groups) {
    if (!groups.length) {
      return 'ungrouped';
    }
    return groups[0];
  };

  CollectObject.prototype.clone = function(data) {
    var groupName, groupedData, name, newData, value;
    newData = {};
    for (groupName in data) {
      groupedData = data[groupName];
      newData[groupName] = {};
      for (name in groupedData) {
        value = groupedData[name];
        if (!groupedData.hasOwnProperty(name)) {
          continue;
        }
        newData[groupName][name] = value;
      }
    }
    return newData;
  };

  CollectObject.prototype.clear = function() {
    this.data = {};
    return this.groups = {};
  };

  return CollectObject;

})(noflo.Component);

exports.getComponent = function() {
  return new CollectObject;
};

});
require.register("noflo-noflo-groups/components/FirstGroup.js", function(exports, require, module){
var FirstGroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

FirstGroup = (function(_super) {
  __extends(FirstGroup, _super);

  function FirstGroup() {
    this.depth = 0;
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        if (_this.depth === 0) {
          _this.outPorts.out.beginGroup(group);
        }
        return _this.depth++;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        _this.depth--;
        if (_this.depth === 0) {
          return _this.outPorts.out.endGroup();
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.depth = 0;
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return FirstGroup;

})(noflo.Component);

exports.getComponent = function() {
  return new FirstGroup;
};

});
require.register("noflo-noflo-groups/components/MapGroup.js", function(exports, require, module){
var MapGroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MapGroup = (function(_super) {
  __extends(MapGroup, _super);

  function MapGroup() {
    this.map = {};
    this.regexps = {};
    this.inPorts = {
      map: new noflo.ArrayPort(),
      regexp: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.map.on('data', (function(_this) {
      return function(data) {
        return _this.prepareMap(data);
      };
    })(this));
    this.inPorts.regexp.on('data', (function(_this) {
      return function(data) {
        return _this.prepareRegExp(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.mapGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  MapGroup.prototype.prepareMap = function(map) {
    var mapParts;
    if (typeof map === 'object') {
      this.map = map;
      return;
    }
    mapParts = map.split('=');
    return this.map[mapParts[0]] = mapParts[1];
  };

  MapGroup.prototype.prepareRegExp = function(map) {
    var mapParts;
    mapParts = map.split('=');
    return this.regexps[mapParts[0]] = mapParts[1];
  };

  MapGroup.prototype.mapGroup = function(group) {
    var expression, matched, regexp, replacement, _ref;
    if (this.map[group]) {
      this.outPorts.out.beginGroup(this.map[group]);
      return;
    }
    _ref = this.regexps;
    for (expression in _ref) {
      replacement = _ref[expression];
      regexp = new RegExp(expression);
      matched = regexp.exec(group);
      if (!matched) {
        continue;
      }
      group = group.replace(regexp, replacement);
    }
    return this.outPorts.out.beginGroup(group);
  };

  return MapGroup;

})(noflo.Component);

exports.getComponent = function() {
  return new MapGroup;
};

});
require.register("noflo-noflo-groups/components/MergeGroups.js", function(exports, require, module){
var MergeGroups, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore')._;

MergeGroups = (function(_super) {
  __extends(MergeGroups, _super);

  function MergeGroups() {
    this.groups = {};
    this.data = {};
    this.inPorts = {
      "in": new noflo.ArrayPort
    };
    this.outPorts = {
      out: new noflo.ArrayPort
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group, socket) {
        return _this.addGroup(socket, group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data, socket) {
        _this.registerData(socket, data);
        return _this.checkBuffer(socket);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group, socket) {
        _this.checkBuffer(socket);
        return _this.removeGroup(socket);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function(socket, socketId) {
        return _this.checkBuffer(socketId);
      };
    })(this));
  }

  MergeGroups.prototype.addGroup = function(socket, group) {
    if (!this.groups[socket]) {
      this.groups[socket] = [];
    }
    return this.groups[socket].push(group);
  };

  MergeGroups.prototype.removeGroup = function(socket) {
    return this.groups[socket].pop();
  };

  MergeGroups.prototype.groupId = function(socket) {
    if (!this.groups[socket]) {
      return null;
    }
    return this.groups[socket].join(':');
  };

  MergeGroups.prototype.registerData = function(socket, data) {
    var id;
    id = this.groupId(socket);
    if (!id) {
      return;
    }
    if (!this.data[id]) {
      this.data[id] = {};
    }
    return this.data[id][socket] = data;
  };

  MergeGroups.prototype.checkBuffer = function(socket) {
    var id, socketId, _i, _len, _ref;
    id = this.groupId(socket);
    if (!id) {
      return;
    }
    if (!this.data[id]) {
      return;
    }
    _ref = this.inPorts["in"].sockets;
    for (socketId = _i = 0, _len = _ref.length; _i < _len; socketId = ++_i) {
      socket = _ref[socketId];
      if (!this.data[id][socketId]) {
        return;
      }
    }
    this.outPorts.out.beginGroup(id);
    this.outPorts.out.send(this.data[id]);
    this.outPorts.out.endGroup();
    this.outPorts.out.disconnect();
    return delete this.data[id];
  };

  return MergeGroups;

})(noflo.Component);

exports.getComponent = function() {
  return new MergeGroups;
};

});
require.register("noflo-noflo-groups/components/GroupByObjectKey.js", function(exports, require, module){
var GroupByObjectKey, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GroupByObjectKey = (function(_super) {
  __extends(GroupByObjectKey, _super);

  function GroupByObjectKey() {
    this.data = [];
    this.key = null;
    this.inPorts = {
      "in": new noflo.Port(),
      key: new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.data = [];
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.key) {
          return _this.getKey(data);
        }
        return _this.data.push(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        var data, _i, _len, _ref;
        if (!_this.data.length) {
          _this.outPorts.out.disconnect();
          return;
        }
        if (!_this.key) {
          return;
        }
        _ref = _this.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          _this.getKey(data);
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        return _this.key = data;
      };
    })(this));
    this.inPorts.key.on('disconnect', (function(_this) {
      return function() {
        var data, _i, _len, _ref;
        if (!_this.data.length) {
          return;
        }
        _ref = _this.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          _this.getKey(data);
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  GroupByObjectKey.prototype.getKey = function(data) {
    var group;
    if (!this.key) {
      throw new Error('Key not defined');
    }
    if (typeof data !== 'object') {
      throw new Error('Data is not an object');
    }
    group = data[this.key];
    if (typeof data[this.key] !== 'string') {
      group = 'undefined';
    }
    if (typeof data[this.key] === 'boolean') {
      if (data[this.key]) {
        group = this.key;
      }
    }
    this.outPorts.out.beginGroup(group);
    this.outPorts.out.send(data);
    return this.outPorts.out.endGroup();
  };

  return GroupByObjectKey;

})(noflo.Component);

exports.getComponent = function() {
  return new GroupByObjectKey;
};

});
require.register("noflo-noflo-interaction/index.js", function(exports, require, module){
/*
 * This file can be used for general library features that are exposed as CommonJS modules
 * that the components then utilize
 */

});
require.register("noflo-noflo-interaction/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-interaction","description":"User interaction components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-interaction","version":"0.0.1","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/ListenChange.coffee","components/ListenDrag.coffee","components/ListenHash.coffee","components/ListenKeyboard.coffee","components/ListenMouse.coffee","components/ListenPointer.coffee","components/ListenResize.coffee","components/ListenScroll.coffee","components/ListenSpeech.coffee","components/ListenTouch.coffee","components/SetHash.coffee","components/ReadCoordinates.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"user","components":{"ListenChange":"components/ListenChange.coffee","ListenDrag":"components/ListenDrag.coffee","ListenHash":"components/ListenHash.coffee","ListenKeyboard":"components/ListenKeyboard.coffee","ListenMouse":"components/ListenMouse.coffee","ListenPointer":"components/ListenPointer.coffee","ListenResize":"components/ListenResize.coffee","ListenScroll":"components/ListenScroll.coffee","ListenSpeech":"components/ListenSpeech.coffee","ListenTouch":"components/ListenTouch.coffee","ReadCoordinates":"components/ReadCoordinates.coffee","SetHash":"components/SetHash.coffee"}}}');
});
require.register("noflo-noflo-interaction/components/ListenChange.js", function(exports, require, module){
var ListenChange, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenChange = (function(_super) {
  __extends(ListenChange, _super);

  ListenChange.prototype.description = 'Listen to mouse events on a DOM element';

  function ListenChange() {
    this.change = __bind(this.change, this);
    this.inPorts = {
      element: new noflo.Port('object')
    };
    this.outPorts = {
      value: new noflo.ArrayPort('all')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
  }

  ListenChange.prototype.subscribe = function(element) {
    return element.addEventListener('change', this.change, false);
  };

  ListenChange.prototype.change = function(event) {
    if (!this.outPorts.value.sockets.length) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.value.send(event.target.value);
    return this.outPorts.value.disconnect();
  };

  return ListenChange;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenChange;
};

});
require.register("noflo-noflo-interaction/components/ListenDrag.js", function(exports, require, module){
var ListenDrag, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenDrag = (function(_super) {
  __extends(ListenDrag, _super);

  ListenDrag.prototype.description = 'Listen to drag events on a DOM element';

  function ListenDrag() {
    this.dragend = __bind(this.dragend, this);
    this.dragmove = __bind(this.dragmove, this);
    this.dragstart = __bind(this.dragstart, this);
    this.inPorts = {
      element: new noflo.Port('object')
    };
    this.outPorts = {
      start: new noflo.ArrayPort('object'),
      movex: new noflo.ArrayPort('number'),
      movey: new noflo.ArrayPort('number'),
      end: new noflo.ArrayPort('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
  }

  ListenDrag.prototype.subscribe = function(element) {
    element.addEventListener('dragstart', this.dragstart, false);
    element.addEventListener('drag', this.dragmove, false);
    return element.addEventListener('dragend', this.dragend, false);
  };

  ListenDrag.prototype.dragstart = function(event) {
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.start.send(event);
    return this.outPorts.start.disconnect();
  };

  ListenDrag.prototype.dragmove = function(event) {
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.movex.send(event.clientX);
    return this.outPorts.movey.send(event.clientY);
  };

  ListenDrag.prototype.dragend = function(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.outPorts.movex.isConnected()) {
      this.outPorts.movex.disconnect();
    }
    if (this.outPorts.movey.isConnected()) {
      this.outPorts.movey.disconnect();
    }
    this.outPorts.end.send(event);
    return this.outPorts.end.disconnect();
  };

  return ListenDrag;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenDrag;
};

});
require.register("noflo-noflo-interaction/components/ListenHash.js", function(exports, require, module){
var ListenHash, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenHash = (function(_super) {
  __extends(ListenHash, _super);

  ListenHash.prototype.description = 'Listen for hash changes in browser\'s URL bar';

  function ListenHash() {
    this.hashChange = __bind(this.hashChange, this);
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      initial: new noflo.Port('string'),
      change: new noflo.Port('string')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        return _this.subscribe();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.unsubscribe();
      };
    })(this));
  }

  ListenHash.prototype.subscribe = function() {
    var initialHash;
    window.addEventListener('hashchange', this.hashChange, false);
    if (this.outPorts.initial.isAttached()) {
      initialHash = window.location.hash.substr(1);
      this.outPorts.initial.send(initialHash);
      return this.outPorts.initial.disconnect();
    }
  };

  ListenHash.prototype.unsubscribe = function() {
    window.removeEventListener('hashchange', this.hashChange, false);
    return this.outPorts.change.disconnect();
  };

  ListenHash.prototype.hashChange = function(event) {
    var newHash, oldHash;
    oldHash = event.oldURL.split('#')[1];
    newHash = event.newURL.split('#')[1];
    if (!newHash) {
      newHash = '';
    }
    if (oldHash) {
      this.outPorts.change.beginGroup(oldHash);
    }
    this.outPorts.change.send(newHash);
    if (oldHash) {
      return this.outPorts.change.endGroup(oldHash);
    }
  };

  ListenHash.prototype.shutdown = function() {
    return this.unsubscribe();
  };

  return ListenHash;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenHash;
};

});
require.register("noflo-noflo-interaction/components/ListenKeyboard.js", function(exports, require, module){
var ListenKeyboard, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenKeyboard = (function(_super) {
  __extends(ListenKeyboard, _super);

  ListenKeyboard.prototype.description = 'Listen for key presses on a given DOM element';

  ListenKeyboard.prototype.icon = 'keyboard-o';

  function ListenKeyboard() {
    this.keypress = __bind(this.keypress, this);
    this.elements = [];
    this.inPorts = {
      element: new noflo.Port('object'),
      stop: new noflo.Port('object')
    };
    this.outPorts = {
      keypress: new noflo.Port('integer')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function(element) {
        return _this.unsubscribe(element);
      };
    })(this));
  }

  ListenKeyboard.prototype.subscribe = function(element) {
    element.addEventListener('keypress', this.keypress, false);
    return this.elements.push(element);
  };

  ListenKeyboard.prototype.unsubscribe = function(element) {
    if (-1 === this.elements.indexOf(element)) {
      return;
    }
    element.removeEventListener('keypress', this.keypress, false);
    return this.elements.splice(this.elements.indexOf(element), 1);
  };

  ListenKeyboard.prototype.keypress = function(event) {
    if (!this.outPorts.keypress.isAttached()) {
      return;
    }
    this.outPorts.keypress.send(event.keyCode);
    return this.outPorts.keypress.disconnect();
  };

  ListenKeyboard.prototype.shutdown = function() {
    var element, _i, _len, _ref, _results;
    _ref = this.elements;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      _results.push(this.unsubscribe(element));
    }
    return _results;
  };

  return ListenKeyboard;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenKeyboard;
};

});
require.register("noflo-noflo-interaction/components/ListenMouse.js", function(exports, require, module){
var ListenMouse, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenMouse = (function(_super) {
  __extends(ListenMouse, _super);

  ListenMouse.prototype.description = 'Listen to mouse events on a DOM element';

  function ListenMouse() {
    this.dblclick = __bind(this.dblclick, this);
    this.click = __bind(this.click, this);
    this.inPorts = {
      element: new noflo.Port('object')
    };
    this.outPorts = {
      click: new noflo.ArrayPort('object'),
      dblclick: new noflo.ArrayPort('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
  }

  ListenMouse.prototype.subscribe = function(element) {
    element.addEventListener('click', this.click, false);
    return element.addEventListener('dblclick', this.dblclick, false);
  };

  ListenMouse.prototype.click = function(event) {
    if (!this.outPorts.click.sockets.length) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.click.send(event);
    this.outPorts.click.disconnect();
    return this.updateIcon();
  };

  ListenMouse.prototype.dblclick = function(event) {
    if (!this.outPorts.dblclick.sockets.length) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.dblclick.send(event);
    this.outPorts.dblclick.disconnect();
    return this.updateIcon();
  };

  ListenMouse.prototype.updateIcon = function() {
    if (!this.setIcon) {
      return;
    }
    if (this.timeout) {
      return;
    }
    this.originalIcon = this.getIcon();
    this.setIcon('exclamation-circle');
    return this.timeout = setTimeout((function(_this) {
      return function() {
        _this.setIcon(_this.originalIcon);
        return _this.timeout = null;
      };
    })(this), 200);
  };

  return ListenMouse;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenMouse;
};

});
require.register("noflo-noflo-interaction/components/ListenPointer.js", function(exports, require, module){
var ListenPointer, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenPointer = (function(_super) {
  __extends(ListenPointer, _super);

  ListenPointer.prototype.description = 'Listen to pointer events on a DOM element';

  function ListenPointer() {
    this.pointerLeave = __bind(this.pointerLeave, this);
    this.pointerEnter = __bind(this.pointerEnter, this);
    this.pointerOut = __bind(this.pointerOut, this);
    this.pointerOver = __bind(this.pointerOver, this);
    this.pointerMove = __bind(this.pointerMove, this);
    this.pointerCancel = __bind(this.pointerCancel, this);
    this.pointerUp = __bind(this.pointerUp, this);
    this.pointerDown = __bind(this.pointerDown, this);
    this.action = 'none';
    this.capture = false;
    this.propagate = false;
    this.elements = [];
    this.inPorts = {
      element: new noflo.Port('object'),
      action: new noflo.Port('string'),
      capture: new noflo.Port('boolean'),
      propagate: new noflo.Port('boolean')
    };
    this.outPorts = {
      down: new noflo.Port('object'),
      up: new noflo.Port('object'),
      cancel: new noflo.Port('object'),
      move: new noflo.Port('object'),
      over: new noflo.Port('object'),
      out: new noflo.Port('object'),
      enter: new noflo.Port('object'),
      leave: new noflo.Port('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
    this.inPorts.action.on('data', (function(_this) {
      return function(action) {
        _this.action = action;
      };
    })(this));
    this.inPorts.capture.on('data', (function(_this) {
      return function(capture) {
        _this.capture = capture;
      };
    })(this));
    this.inPorts.propagate.on('data', (function(_this) {
      return function(propagate) {
        _this.propagate = propagate;
      };
    })(this));
  }

  ListenPointer.prototype.subscribe = function(element) {
    if (element.setAttribute) {
      element.setAttribute('touch-action', this.action);
    }
    element.addEventListener('pointerdown', this.pointerDown, this.capture);
    element.addEventListener('pointerup', this.pointerUp, this.capture);
    element.addEventListener('pointercancel', this.pointerCancel, this.capture);
    element.addEventListener('pointermove', this.pointerMove, this.capture);
    element.addEventListener('pointerover', this.pointerOver, this.capture);
    element.addEventListener('pointerout', this.pointerOut, this.capture);
    element.addEventListener('pointerenter', this.pointerEnter, this.capture);
    element.addEventListener('pointerleave', this.pointerLeave, this.capture);
    return this.elements.push(element);
  };

  ListenPointer.prototype.unsubscribe = function(element) {
    var name, port, _ref, _results;
    if (element.removeAttribute) {
      element.removeAttribute('touch-action');
    }
    element.removeEventListener('pointerdown', this.pointerDown, this.capture);
    element.removeEventListener('pointerup', this.pointerUp, this.capture);
    element.removeEventListener('pointercancel', this.pointerCancel, this.capture);
    element.removeEventListener('pointermove', this.pointerMove, this.capture);
    element.removeEventListener('pointerover', this.pointerOver, this.capture);
    element.removeEventListener('pointerout', this.pointerOut, this.capture);
    element.removeEventListener('pointerenter', this.pointerEnter, this.capture);
    element.removeEventListener('pointerleave', this.pointerLeave, this.capture);
    _ref = this.outPorts;
    _results = [];
    for (name in _ref) {
      port = _ref[name];
      if (!port.isAttached()) {
        continue;
      }
      _results.push(port.disconnect());
    }
    return _results;
  };

  ListenPointer.prototype.shutdown = function() {
    var element, _i, _len, _ref;
    _ref = this.elements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      this.unsubscribe(element);
    }
    return this.elements = [];
  };

  ListenPointer.prototype.pointerDown = function(event) {
    return this.handle(event, 'down');
  };

  ListenPointer.prototype.pointerUp = function(event) {
    return this.handle(event, 'up');
  };

  ListenPointer.prototype.pointerCancel = function(event) {
    return this.handle(event, 'cancel');
  };

  ListenPointer.prototype.pointerMove = function(event) {
    return this.handle(event, 'move');
  };

  ListenPointer.prototype.pointerOver = function(event) {
    return this.handle(event, 'over');
  };

  ListenPointer.prototype.pointerOut = function(event) {
    return this.handle(event, 'out');
  };

  ListenPointer.prototype.pointerEnter = function(event) {
    return this.handle(event, 'enter');
  };

  ListenPointer.prototype.pointerLeave = function(event) {
    return this.handle(event, 'leave');
  };

  ListenPointer.prototype.handle = function(event, type) {
    var name, port, _ref, _results;
    event.preventDefault();
    if (!this.propagate) {
      event.stopPropagation();
    }
    if (!this.outPorts[type].isAttached()) {
      return;
    }
    this.outPorts[type].beginGroup(event.pointerId);
    this.outPorts[type].send(event);
    this.outPorts[type].endGroup();
    if (type === 'up' || type === 'cancel' || type === 'leave') {
      _ref = this.outPorts;
      _results = [];
      for (name in _ref) {
        port = _ref[name];
        if (!port.isAttached()) {
          continue;
        }
        _results.push(port.disconnect());
      }
      return _results;
    }
  };

  return ListenPointer;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenPointer;
};

});
require.register("noflo-noflo-interaction/components/ListenResize.js", function(exports, require, module){
var ListenResize, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenResize = (function(_super) {
  __extends(ListenResize, _super);

  ListenResize.prototype.description = 'Listen to window resize events';

  ListenResize.prototype.icon = 'desktop';

  function ListenResize() {
    this.sendSize = __bind(this.sendSize, this);
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      width: new noflo.Port('number'),
      height: new noflo.Port('number')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        _this.sendSize();
        return _this.subscribe();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.unsubscribe();
      };
    })(this));
  }

  ListenResize.prototype.subscribe = function() {
    return window.addEventListener('resize', this.sendSize, false);
  };

  ListenResize.prototype.unsubscribe = function() {
    return window.removeEventListener('resize', this.sendSize, false);
  };

  ListenResize.prototype.sendSize = function() {
    if (this.outPorts.width.isAttached()) {
      this.outPorts.width.send(window.innerWidth);
      this.outPorts.width.disconnect();
    }
    if (this.outPorts.height.isAttached()) {
      this.outPorts.height.send(window.innerHeight);
      return this.outPorts.height.disconnect();
    }
  };

  ListenResize.prototype.shutdown = function() {
    return this.unsubscribe();
  };

  return ListenResize;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenResize;
};

});
require.register("noflo-noflo-interaction/components/ListenScroll.js", function(exports, require, module){
var ListenScroll, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenScroll = (function(_super) {
  __extends(ListenScroll, _super);

  ListenScroll.prototype.description = 'Listen to scroll events on the browser window';

  function ListenScroll() {
    this.scroll = __bind(this.scroll, this);
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      top: new noflo.Port('number'),
      bottom: new noflo.Port('number'),
      left: new noflo.Port('number'),
      right: new noflo.Port('number')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        return _this.subscribe();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.unsubscribe();
      };
    })(this));
  }

  ListenScroll.prototype.subscribe = function() {
    return window.addEventListener('scroll', this.scroll, false);
  };

  ListenScroll.prototype.unsubscribe = function() {
    return window.removeEventListenr('scroll', this.scroll, false);
  };

  ListenScroll.prototype.scroll = function(event) {
    var bottom, left, right, top;
    top = window.scrollY;
    left = window.scrollX;
    if (this.outPorts.top.isAttached()) {
      this.outPorts.top.send(top);
      this.outPorts.top.disconnect();
    }
    if (this.outPorts.bottom.isAttached()) {
      bottom = top + window.innerHeight;
      this.outPorts.bottom.send(bottom);
      this.outPorts.bottom.disconnect();
    }
    if (this.outPorts.left.isAttached()) {
      this.outPorts.left.send(left);
      this.outPorts.left.disconnect();
    }
    if (this.outPorts.right.isAttached()) {
      right = left + window.innerWidth;
      this.outPorts.right.send(right);
      return this.outPorts.right.disconnect();
    }
  };

  ListenScroll.prototype.shutdown = function() {
    return this.unsubscribe();
  };

  return ListenScroll;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenScroll;
};

});
require.register("noflo-noflo-interaction/components/ListenSpeech.js", function(exports, require, module){
var ListenSpeech, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenSpeech = (function(_super) {
  __extends(ListenSpeech, _super);

  ListenSpeech.prototype.description = 'Listen for user\'s microphone and recognize phrases';

  function ListenSpeech() {
    this.handleError = __bind(this.handleError, this);
    this.handleResult = __bind(this.handleResult, this);
    this.recognition = false;
    this.sent = [];
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      result: new noflo.Port('string'),
      error: new noflo.Port('object')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        return _this.startListening();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.stopListening();
      };
    })(this));
  }

  ListenSpeech.prototype.startListening = function() {
    if (!window.webkitSpeechRecognition) {
      this.handleError(new Error('Speech recognition support not available'));
    }
    this.recognition = new window.webkitSpeechRecognition;
    this.recognition.continuous = true;
    this.recognition.start();
    this.outPorts.result.connect();
    this.recognition.onresult = this.handleResult;
    return this.recognition.onerror = this.handleError;
  };

  ListenSpeech.prototype.handleResult = function(event) {
    var idx, result, _i, _len, _ref, _results;
    _ref = event.results;
    _results = [];
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      result = _ref[idx];
      if (!result.isFinal) {
        continue;
      }
      if (this.sent.indexOf(idx) !== -1) {
        continue;
      }
      this.outPorts.result.send(result[0].transcript);
      _results.push(this.sent.push(idx));
    }
    return _results;
  };

  ListenSpeech.prototype.handleError = function(error) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(error);
      this.outPorts.error.disconnect();
      return;
    }
    throw error;
  };

  ListenSpeech.prototype.stopListening = function() {
    if (!this.recognition) {
      return;
    }
    this.outPorts.result.disconnect();
    this.recognition.stop();
    this.recognition = null;
    return this.sent = [];
  };

  ListenSpeech.prototype.shutdown = function() {
    return this.stopListening();
  };

  return ListenSpeech;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenSpeech;
};

});
require.register("noflo-noflo-interaction/components/ListenTouch.js", function(exports, require, module){
var ListenTouch, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenTouch = (function(_super) {
  __extends(ListenTouch, _super);

  ListenTouch.prototype.description = 'Listen to touch events on a DOM element';

  function ListenTouch() {
    this.touchend = __bind(this.touchend, this);
    this.touchmove = __bind(this.touchmove, this);
    this.touchstart = __bind(this.touchstart, this);
    this.inPorts = {
      element: new noflo.Port('object')
    };
    this.outPorts = {
      start: new noflo.ArrayPort('object'),
      movex: new noflo.ArrayPort('number'),
      movey: new noflo.ArrayPort('number'),
      end: new noflo.ArrayPort('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
  }

  ListenTouch.prototype.subscribe = function(element) {
    element.addEventListener('touchstart', this.touchstart, false);
    element.addEventListener('touchmove', this.touchmove, false);
    return element.addEventListener('touchend', this.touchend, false);
  };

  ListenTouch.prototype.touchstart = function(event) {
    var idx, touch, _i, _len, _ref;
    event.preventDefault();
    event.stopPropagation();
    if (!event.changedTouches) {
      return;
    }
    if (!event.changedTouches.length) {
      return;
    }
    _ref = event.changedTouches;
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      touch = _ref[idx];
      this.outPorts.start.beginGroup(idx);
      this.outPorts.start.send(event);
      this.outPorts.start.endGroup();
    }
    return this.outPorts.start.disconnect();
  };

  ListenTouch.prototype.touchmove = function(event) {
    var idx, touch, _i, _len, _ref, _results;
    event.preventDefault();
    event.stopPropagation();
    if (!event.changedTouches) {
      return;
    }
    if (!event.changedTouches.length) {
      return;
    }
    _ref = event.changedTouches;
    _results = [];
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      touch = _ref[idx];
      this.outPorts.movex.beginGroup(idx);
      this.outPorts.movex.send(touch.pageX);
      this.outPorts.movex.endGroup();
      this.outPorts.movey.beginGroup(idx);
      this.outPorts.movey.send(touch.pageY);
      _results.push(this.outPorts.movey.endGroup());
    }
    return _results;
  };

  ListenTouch.prototype.touchend = function(event) {
    var idx, touch, _i, _len, _ref;
    event.preventDefault();
    event.stopPropagation();
    if (!event.changedTouches) {
      return;
    }
    if (!event.changedTouches.length) {
      return;
    }
    if (this.outPorts.movex.isConnected()) {
      this.outPorts.movex.disconnect();
    }
    if (this.outPorts.movey.isConnected()) {
      this.outPorts.movey.disconnect();
    }
    _ref = event.changedTouches;
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      touch = _ref[idx];
      this.outPorts.end.beginGroup(idx);
      this.outPorts.end.send(event);
      this.outPorts.end.endGroup();
    }
    return this.outPorts.end.disconnect();
  };

  return ListenTouch;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenTouch;
};

});
require.register("noflo-noflo-interaction/components/SetHash.js", function(exports, require, module){
var SetHash, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetHash = (function(_super) {
  __extends(SetHash, _super);

  function SetHash() {
    this.inPorts = {
      hash: new noflo.ArrayPort('string')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.hash.on('data', (function(_this) {
      return function(data) {
        window.location.hash = "#" + data;
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts.hash.on('disconnect', (function(_this) {
      return function() {
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.disconnect();
        }
      };
    })(this));
  }

  return SetHash;

})(noflo.Component);

exports.getComponent = function() {
  return new SetHash;
};

});
require.register("noflo-noflo-interaction/components/ReadCoordinates.js", function(exports, require, module){
var ReadCoordinates, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ReadCoordinates = (function(_super) {
  __extends(ReadCoordinates, _super);

  ReadCoordinates.prototype.description = 'Read the coordinates from a DOM event';

  function ReadCoordinates() {
    this.inPorts = {
      event: new noflo.Port('object')
    };
    this.outPorts = {
      screen: new noflo.Port('object'),
      client: new noflo.Port('object'),
      page: new noflo.Port('object')
    };
    this.inPorts.event.on('begingroup', (function(_this) {
      return function(group) {
        if (_this.outPorts.screen.isAttached()) {
          _this.outPorts.screen.beginGroup(group);
        }
        if (_this.outPorts.client.isAttached()) {
          _this.outPorts.client.beginGroup(group);
        }
        if (_this.outPorts.page.isAttached()) {
          return _this.outPorts.page.beginGroup(group);
        }
      };
    })(this));
    this.inPorts.event.on('data', (function(_this) {
      return function(data) {
        return _this.read(data);
      };
    })(this));
    this.inPorts.event.on('endgroup', (function(_this) {
      return function() {
        if (_this.outPorts.screen.isAttached()) {
          _this.outPorts.screen.endGroup();
        }
        if (_this.outPorts.client.isAttached()) {
          _this.outPorts.client.endGroup();
        }
        if (_this.outPorts.page.isAttached()) {
          return _this.outPorts.page.endGroup();
        }
      };
    })(this));
    this.inPorts.event.on('disconnect', (function(_this) {
      return function() {
        if (_this.outPorts.screen.isAttached()) {
          _this.outPorts.screen.disconnect();
        }
        if (_this.outPorts.client.isAttached()) {
          _this.outPorts.client.disconnect();
        }
        if (_this.outPorts.page.isAttached()) {
          return _this.outPorts.page.disconnect();
        }
      };
    })(this));
  }

  ReadCoordinates.prototype.read = function(event) {
    if (!event) {
      return;
    }
    if (this.outPorts.screen.isAttached() && event.screenX !== void 0) {
      this.outPorts.screen.send({
        x: event.screenX,
        y: event.screenY
      });
    }
    if (this.outPorts.client.isAttached() && event.clientX !== void 0) {
      this.outPorts.client.send({
        x: event.clientX,
        y: event.clientY
      });
    }
    if (this.outPorts.page.isAttached() && event.pageX !== void 0) {
      return this.outPorts.page.send({
        x: event.pageX,
        y: event.pageY
      });
    }
  };

  return ReadCoordinates;

})(noflo.Component);

exports.getComponent = function() {
  return new ReadCoordinates;
};

});
require.register("noflo-noflo-localstorage/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-localstorage.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-localstorage/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-localstorage","description":"LocalStorage components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-localstorage","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/GetItem.coffee","components/ListenRemoteChanges.coffee","components/ListAdd.coffee","components/ListGet.coffee","components/ListRemove.coffee","components/RemoveItem.coffee","components/SetItem.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"html5","components":{"GetItem":"components/GetItem.coffee","ListenRemoteChanges":"components/ListenRemoteChanges.coffee","ListAdd":"components/ListAdd.coffee","ListGet":"components/ListGet.coffee","ListRemove":"components/ListRemove.coffee","RemoveItem":"components/RemoveItem.coffee","SetItem":"components/SetItem.coffee"}}}');
});
require.register("noflo-noflo-localstorage/components/GetItem.js", function(exports, require, module){
var GetItem, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetItem = (function(_super) {
  __extends(GetItem, _super);

  function GetItem() {
    this.inPorts = {
      key: new noflo.Port('string')
    };
    this.outPorts = {
      item: new noflo.Port('string'),
      error: new noflo.Port('object')
    };
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        var value;
        value = localStorage.getItem(data);
        if (!value) {
          if (_this.outPorts.error.isAttached()) {
            _this.outPorts.error.send(new Error("" + data + " not found"));
            _this.outPorts.error.disconnect();
          }
          return;
        }
        _this.outPorts.item.beginGroup(data);
        _this.outPorts.item.send(value);
        return _this.outPorts.item.endGroup();
      };
    })(this));
    this.inPorts.key.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.item.disconnect();
      };
    })(this));
  }

  return GetItem;

})(noflo.Component);

exports.getComponent = function() {
  return new GetItem;
};

});
require.register("noflo-noflo-localstorage/components/ListenRemoteChanges.js", function(exports, require, module){
var ListenChanges, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenChanges = (function(_super) {
  __extends(ListenChanges, _super);

  function ListenChanges() {
    var listener;
    this.listening = false;
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      changed: new noflo.Port('string'),
      removed: new noflo.Port('string')
    };
    listener = (function(_this) {
      return function(event) {
        if (event.newValue === null && _this.outPorts.removed.isAttached()) {
          _this.outPorts.removed.beginGroup(event.key);
          _this.outPorts.removed.send(null);
          _this.outPorts.removed.endGroup();
          return;
        }
        _this.outPorts.changed.beginGroup(event.key);
        _this.outPorts.changed.send(event.newValue);
        return _this.outPorts.changed.endGroup();
      };
    })(this);
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        if (_this.listening) {
          return;
        }
        window.addEventListener('storage', listener, false);
        return _this.listening = true;
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        if (!_this.listening) {
          return;
        }
        window.removeEventListener('storage', listener, false);
        _this.listening = false;
        _this.outPorts.changed.disconnect();
        return _this.outPorts.removed.disconnect();
      };
    })(this));
  }

  return ListenChanges;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenChanges;
};

});
require.register("noflo-noflo-localstorage/components/ListAdd.js", function(exports, require, module){
var ListAdd, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListAdd = (function(_super) {
  __extends(ListAdd, _super);

  function ListAdd() {
    this.listKey = null;
    this.key = null;
    this.inPorts = {
      list: new noflo.Port('string'),
      key: new noflo.Port('string')
    };
    this.outPorts = {
      key: new noflo.Port('string')
    };
    this.inPorts.list.on('data', (function(_this) {
      return function(listKey) {
        _this.listKey = listKey;
        return _this.add();
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(key) {
        _this.key = key;
        return _this.add();
      };
    })(this));
  }

  ListAdd.prototype.add = function() {
    var items, list;
    if (!(this.listKey && this.key)) {
      return;
    }
    list = localStorage.getItem(this.listKey);
    if (list) {
      items = list.split(',');
    } else {
      items = [];
    }
    if (items.indexOf(this.key) === -1) {
      items.push(this.key);
      localStorage.setItem(this.listKey, items.join(','));
    }
    if (this.outPorts.key.isAttached()) {
      this.outPorts.key.send(this.key);
      this.outPorts.key.disconnect();
    }
    return this.key = null;
  };

  return ListAdd;

})(noflo.Component);

exports.getComponent = function() {
  return new ListAdd;
};

});
require.register("noflo-noflo-localstorage/components/ListGet.js", function(exports, require, module){
var ListGet, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListGet = (function(_super) {
  __extends(ListGet, _super);

  function ListGet() {
    this.inPorts = {
      key: new noflo.Port('string')
    };
    this.outPorts = {
      items: new noflo.Port('string'),
      error: new noflo.Port('object')
    };
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        var val, vals, value, _i, _len;
        value = localStorage.getItem(data);
        if (!value) {
          if (_this.outPorts.error.isAttached()) {
            _this.outPorts.error.send(new Error("" + data + " not found"));
            _this.outPorts.error.disconnect();
          }
          return;
        }
        vals = value.split(',');
        _this.outPorts.items.beginGroup(data);
        for (_i = 0, _len = vals.length; _i < _len; _i++) {
          val = vals[_i];
          _this.outPorts.items.send(val);
        }
        return _this.outPorts.items.endGroup();
      };
    })(this));
    this.inPorts.key.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.items.disconnect();
      };
    })(this));
  }

  return ListGet;

})(noflo.Component);

exports.getComponent = function() {
  return new ListGet;
};

});
require.register("noflo-noflo-localstorage/components/ListRemove.js", function(exports, require, module){
var ListRemove, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListRemove = (function(_super) {
  __extends(ListRemove, _super);

  function ListRemove() {
    this.listKey = null;
    this.key = null;
    this.inPorts = {
      list: new noflo.Port('string'),
      key: new noflo.Port('string')
    };
    this.outPorts = {
      key: new noflo.Port('string')
    };
    this.inPorts.list.on('data', (function(_this) {
      return function(listKey) {
        _this.listKey = listKey;
        return _this.remove();
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(key) {
        _this.key = key;
        return _this.remove();
      };
    })(this));
  }

  ListRemove.prototype.remove = function() {
    var items, list;
    if (!(this.listKey && this.key)) {
      return;
    }
    list = localStorage.getItem(this.listKey);
    if (list) {
      items = list.split(',');
      if (items.indexOf(this.key) !== -1) {
        items.splice(items.indexOf(this.key), 1);
        localStorage.setItem(this.listKey, items.join(','));
      }
    }
    if (this.outPorts.key.isAttached()) {
      this.outPorts.key.send(this.key);
      this.outPorts.key.disconnect();
    }
    return this.key = null;
  };

  return ListRemove;

})(noflo.Component);

exports.getComponent = function() {
  return new ListRemove;
};

});
require.register("noflo-noflo-localstorage/components/RemoveItem.js", function(exports, require, module){
var RemoveItem, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RemoveItem = (function(_super) {
  __extends(RemoveItem, _super);

  function RemoveItem() {
    this.inPorts = {
      key: new noflo.Port('string')
    };
    this.outPorts = {
      item: new noflo.Port('string')
    };
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        localStorage.removeItem(data);
        _this.outPorts.item.beginGroup(data);
        _this.outPorts.item.send(null);
        _this.outPorts.item.endGroup();
        return _this.outPorts.item.disconnect();
      };
    })(this));
  }

  return RemoveItem;

})(noflo.Component);

exports.getComponent = function() {
  return new RemoveItem;
};

});
require.register("noflo-noflo-localstorage/components/SetItem.js", function(exports, require, module){
var SetItem, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetItem = (function(_super) {
  __extends(SetItem, _super);

  function SetItem() {
    this.key = null;
    this.value = null;
    this.inPorts = {
      key: new noflo.Port('string'),
      value: new noflo.Port('string')
    };
    this.outPorts = {
      item: new noflo.Port('string')
    };
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        if (!data) {
          return;
        }
        _this.key = data;
        if (_this.value) {
          return _this.setItem();
        }
      };
    })(this));
    this.inPorts.value.on('data', (function(_this) {
      return function(data) {
        _this.value = data;
        if (_this.key) {
          return _this.setItem();
        }
      };
    })(this));
  }

  SetItem.prototype.setItem = function() {
    localStorage.setItem(this.key, this.value);
    if (this.outPorts.item.isAttached()) {
      this.outPorts.item.beginGroup(this.key);
      this.outPorts.item.send(this.value);
      this.outPorts.item.endGroup();
      this.outPorts.item.disconnect();
    }
    this.key = null;
    return this.value = null;
  };

  return SetItem;

})(noflo.Component);

exports.getComponent = function() {
  return new SetItem;
};

});
require.register("noflo-noflo-math/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-math.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-math/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-math","description":"Mathematical components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-math","version":"0.0.1","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Add.coffee","components/Subtract.coffee","components/Multiply.coffee","components/Divide.coffee","components/Floor.coffee","components/CalculateAngle.coffee","components/CalculateDistance.coffee","components/Compare.coffee","components/CountSum.coffee","lib/MathComponent.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"plus-circle","components":{"Add":"components/Add.coffee","Subtract":"components/Subtract.coffee","Multiply":"components/Multiply.coffee","Divide":"components/Divide.coffee","Floor":"components/Floor.coffee","CalculateAngle":"components/CalculateAngle.coffee","CalculateDistance":"components/CalculateDistance.coffee","Compare":"components/Compare.coffee","CountSum":"components/CountSum.coffee"}}}');
});
require.register("noflo-noflo-math/components/Add.js", function(exports, require, module){
var Add, MathComponent,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

Add = (function(_super) {
  __extends(Add, _super);

  Add.prototype.icon = 'plus';

  function Add() {
    Add.__super__.constructor.call(this, 'augend', 'addend', 'sum');
  }

  Add.prototype.calculate = function(augend, addend) {
    return Number(augend) + Number(addend);
  };

  return Add;

})(MathComponent);

exports.getComponent = function() {
  return new Add;
};

});
require.register("noflo-noflo-math/components/Subtract.js", function(exports, require, module){
var MathComponent, Subtract,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

Subtract = (function(_super) {
  __extends(Subtract, _super);

  Subtract.prototype.icon = 'minus';

  function Subtract() {
    Subtract.__super__.constructor.call(this, 'minuend', 'subtrahend', 'difference');
  }

  Subtract.prototype.calculate = function(minuend, subtrahend) {
    return minuend - subtrahend;
  };

  return Subtract;

})(MathComponent);

exports.getComponent = function() {
  return new Subtract;
};

});
require.register("noflo-noflo-math/components/Multiply.js", function(exports, require, module){
var MathComponent, Multiply,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

Multiply = (function(_super) {
  __extends(Multiply, _super);

  Multiply.prototype.icon = 'asterisk';

  function Multiply() {
    Multiply.__super__.constructor.call(this, 'multiplicand', 'multiplier', 'product');
  }

  Multiply.prototype.calculate = function(multiplicand, multiplier) {
    return multiplicand * multiplier;
  };

  return Multiply;

})(MathComponent);

exports.getComponent = function() {
  return new Multiply;
};

});
require.register("noflo-noflo-math/components/Divide.js", function(exports, require, module){
var Divide, MathComponent,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

Divide = (function(_super) {
  __extends(Divide, _super);

  function Divide() {
    Divide.__super__.constructor.call(this, 'dividend', 'divisor', 'quotient');
  }

  Divide.prototype.calculate = function(dividend, divisor) {
    return dividend / divisor;
  };

  return Divide;

})(MathComponent);

exports.getComponent = function() {
  return new Divide;
};

});
require.register("noflo-noflo-math/components/Floor.js", function(exports, require, module){
var Floor, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Floor = (function(_super) {
  __extends(Floor, _super);

  function Floor() {
    this.inPorts = {
      "in": new noflo.Port('number')
    };
    this.outPorts = {
      out: new noflo.Port('integer')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(Math.floor(data));
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Floor;

})(noflo.Component);

exports.getComponent = function() {
  return new Floor;
};

});
require.register("noflo-noflo-math/components/CalculateAngle.js", function(exports, require, module){
var CalculateAngle, MathComponent,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

CalculateAngle = (function(_super) {
  __extends(CalculateAngle, _super);

  CalculateAngle.prototype.description = 'Calculate the angle between two points';

  CalculateAngle.prototype.icon = 'compass';

  function CalculateAngle() {
    CalculateAngle.__super__.constructor.call(this, 'origin', 'destination', 'angle', 'object');
  }

  CalculateAngle.prototype.calculate = function(origin, destination) {
    var angle, deltaX, deltaY;
    deltaX = destination.x - origin.x;
    deltaY = destination.y - origin.y;
    origin = null;
    destination = null;
    angle = (Math.atan2(deltaY, deltaX) * 180 / Math.PI) + 90;
    if (angle < 0) {
      angle = angle + 360;
    }
    return angle;
  };

  return CalculateAngle;

})(MathComponent);

exports.getComponent = function() {
  return new CalculateAngle;
};

});
require.register("noflo-noflo-math/components/CalculateDistance.js", function(exports, require, module){
var CalculateDistance, MathComponent,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

CalculateDistance = (function(_super) {
  __extends(CalculateDistance, _super);

  CalculateDistance.prototype.icon = 'arrow-right';

  CalculateDistance.prototype.description = 'Calculate the distance between two points';

  function CalculateDistance() {
    CalculateDistance.__super__.constructor.call(this, 'origin', 'destination', 'distance', 'object');
  }

  CalculateDistance.prototype.calculate = function(origin, destination) {
    var deltaX, deltaY, distance;
    deltaX = destination.x - origin.x;
    deltaY = destination.y - origin.y;
    origin = null;
    destination = null;
    distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    return distance;
  };

  return CalculateDistance;

})(MathComponent);

exports.getComponent = function() {
  return new CalculateDistance;
};

});
require.register("noflo-noflo-math/components/Compare.js", function(exports, require, module){
var Compare, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Compare = (function(_super) {
  __extends(Compare, _super);

  Compare.prototype.description = 'Compare two numbers';

  Compare.prototype.icon = 'check';

  function Compare() {
    this.operator = '==';
    this.value = null;
    this.comparison = null;
    this.inPorts = {
      value: new noflo.Port('number'),
      comparison: new noflo.Port('number'),
      operator: new noflo.Port('string')
    };
    this.outPorts = {
      pass: new noflo.Port('number'),
      fail: new noflo.Port('number')
    };
    this.inPorts.operator.on('data', (function(_this) {
      return function(operator) {
        _this.operator = operator;
      };
    })(this));
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.value = value;
        if (_this.comparison) {
          return _this.compare();
        }
      };
    })(this));
    this.inPorts.value.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.pass.disconnect();
      };
    })(this));
    this.inPorts.comparison.on('data', (function(_this) {
      return function(comparison) {
        _this.comparison = comparison;
        if (_this.value) {
          return _this.compare();
        }
      };
    })(this));
  }

  Compare.prototype.compare = function() {
    switch (this.operator) {
      case 'eq':
      case '==':
        if (this.value === this.comparison) {
          return this.send(this.value);
        }
        break;
      case 'ne':
      case '!=':
        if (this.value !== this.comparison) {
          return this.send(this.value);
        }
        break;
      case 'gt':
      case '>':
        if (this.value > this.comparison) {
          return this.send(this.value);
        }
        break;
      case 'lt':
      case '<':
        if (this.value < this.comparison) {
          return this.send(this.value);
        }
        break;
      case 'ge':
      case '>=':
        if (this.value >= this.comparison) {
          return this.send(this.value);
        }
        break;
      case 'le':
      case '<=':
        if (this.value <= this.comparison) {
          return this.send(this.value);
        }
    }
    if (!this.outPorts.fail.isAttached()) {
      return;
    }
    this.outPorts.fail.send(this.value);
    return this.outPorts.fail.disconnect();
  };

  Compare.prototype.send = function(val) {
    return this.outPorts.pass.send(this.value);
  };

  return Compare;

})(noflo.Component);

exports.getComponent = function() {
  return new Compare;
};

});
require.register("noflo-noflo-math/components/CountSum.js", function(exports, require, module){
var CountSum, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CountSum = (function(_super) {
  __extends(CountSum, _super);

  function CountSum() {
    this.portCounts = {};
    this.inPorts = {
      "in": new noflo.ArrayPort('number')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('number')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data, portId) {
        return _this.count(portId, data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function(socket, portId) {
        var _i, _len, _ref;
        _ref = _this.inPorts["in"].sockets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          socket = _ref[_i];
          if (socket.isConnected()) {
            return;
          }
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  CountSum.prototype.count = function(port, data) {
    var id, socket, sum, _i, _len, _ref;
    sum = 0;
    this.portCounts[port] = data;
    _ref = this.inPorts["in"].sockets;
    for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
      socket = _ref[id];
      if (typeof this.portCounts[id] === 'undefined') {
        this.portCounts[id] = 0;
      }
      sum += this.portCounts[id];
    }
    return this.outPorts.out.send(sum);
  };

  return CountSum;

})(noflo.Component);

exports.getComponent = function() {
  return new CountSum;
};

});
require.register("noflo-noflo-math/lib/MathComponent.js", function(exports, require, module){
var MathComponent, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MathComponent = (function(_super) {
  __extends(MathComponent, _super);

  function MathComponent(primary, secondary, res, inputType) {
    var calculate;
    if (inputType == null) {
      inputType = 'number';
    }
    this.inPorts = {};
    this.outPorts = {};
    this.inPorts[primary] = new noflo.Port(inputType);
    this.inPorts[secondary] = new noflo.Port(inputType);
    this.inPorts.clear = new noflo.Port('bang');
    this.outPorts[res] = new noflo.Port('number');
    this.primary = {
      value: null,
      group: [],
      disconnect: false
    };
    this.secondary = null;
    this.groups = [];
    calculate = (function(_this) {
      return function() {
        var group, _i, _j, _len, _len1, _ref, _ref1;
        _ref = _this.primary.group;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts[res].beginGroup(group);
        }
        _this.outPorts[res].send(_this.calculate(_this.primary.value, _this.secondary));
        _ref1 = _this.primary.group;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          _this.outPorts[res].endGroup();
        }
        if (_this.primary.disconnect) {
          return _this.outPorts[res].disconnect();
        }
      };
    })(this);
    this.inPorts[primary].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts[primary].on('data', (function(_this) {
      return function(data) {
        _this.primary = {
          value: data,
          group: _this.groups.slice(0),
          disconnect: false
        };
        if (_this.secondary !== null) {
          return calculate();
        }
      };
    })(this));
    this.inPorts[primary].on('endgroup', (function(_this) {
      return function() {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts[primary].on('disconnect', (function(_this) {
      return function() {
        _this.primary.disconnect = true;
        return _this.outPorts[res].disconnect();
      };
    })(this));
    this.inPorts[secondary].on('data', (function(_this) {
      return function(data) {
        _this.secondary = data;
        if (_this.primary.value !== null) {
          return calculate();
        }
      };
    })(this));
    this.inPorts.clear.on('data', (function(_this) {
      return function(data) {
        var group, _i, _len, _ref;
        if (_this.outPorts[res].isConnected()) {
          _ref = _this.primary.group;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            group = _ref[_i];
            _this.outPorts[res].endGroup();
          }
          if (_this.primary.disconnect) {
            _this.outPorts[res].disconnect();
          }
        }
        _this.primary = {
          value: null,
          group: [],
          disconnect: false
        };
        _this.secondary = null;
        return _this.groups = [];
      };
    })(this));
  }

  return MathComponent;

})(noflo.Component);

exports.MathComponent = MathComponent;

});
require.register("noflo-noflo-objects/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of objects.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-objects/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-objects","description":"Object Utilities for NoFlo","version":"0.1.0","keywords":["noflo","objects","utilities"],"author":"Kenneth Kan <kenhkan@gmail.com>","repo":"noflo/objects","dependencies":{"noflo/noflo":"*","component/underscore":"*"},"scripts":["components/Extend.coffee","components/MergeObjects.coffee","components/SplitObject.coffee","components/ReplaceKey.coffee","components/Keys.coffee","components/Size.coffee","components/Values.coffee","components/Join.coffee","components/ExtractProperty.coffee","components/InsertProperty.coffee","components/SliceArray.coffee","components/SplitArray.coffee","components/FilterPropertyValue.coffee","components/FlattenObject.coffee","components/MapProperty.coffee","components/RemoveProperty.coffee","components/MapPropertyValue.coffee","components/GetObjectKey.coffee","components/UniqueArray.coffee","components/SetProperty.coffee","components/SimplifyObject.coffee","components/DuplicateProperty.coffee","components/CreateObject.coffee","components/CreateDate.coffee","components/SetPropertyValue.coffee","components/CallMethod.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"list","components":{"Extend":"components/Extend.coffee","MergeObjects":"components/MergeObjects.coffee","SplitObject":"components/SplitObject.coffee","ReplaceKey":"components/ReplaceKey.coffee","Keys":"components/Keys.coffee","Size":"components/Size.coffee","Values":"components/Values.coffee","Join":"components/Join.coffee","ExtractProperty":"components/ExtractProperty.coffee","InsertProperty":"components/InsertProperty.coffee","SliceArray":"components/SliceArray.coffee","SplitArray":"components/SplitArray.coffee","FilterPropertyValue":"components/FilterPropertyValue.coffee","FlattenObject":"components/FlattenObject.coffee","MapProperty":"components/MapProperty.coffee","RemoveProperty":"components/RemoveProperty.coffee","MapPropertyValue":"components/MapPropertyValue.coffee","GetObjectKey":"components/GetObjectKey.coffee","UniqueArray":"components/UniqueArray.coffee","SetProperty":"components/SetProperty.coffee","SimplifyObject":"components/SimplifyObject.coffee","DuplicateProperty":"components/DuplicateProperty.coffee","CreateObject":"components/CreateObject.coffee","CreateDate":"components/CreateDate.coffee","SetPropertyValue":"components/SetPropertyValue.coffee","CallMethod":"components/CallMethod.coffee"}}}');
});
require.register("noflo-noflo-objects/components/Extend.js", function(exports, require, module){
var Extend, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

noflo = require("noflo");

Extend = (function(_super) {
  __extends(Extend, _super);

  Extend.prototype.description = "Extend an incoming object to some predefined objects, optionally by a certain property";

  function Extend() {
    this.bases = [];
    this.mergedBase = {};
    this.key = null;
    this.reverse = false;
    this.inPorts = {
      "in": new noflo.Port,
      base: new noflo.Port,
      key: new noflo.Port,
      reverse: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.base.on("connect", (function(_this) {
      return function() {
        return _this.bases = [];
      };
    })(this));
    this.inPorts.base.on("data", (function(_this) {
      return function(base) {
        if (base != null) {
          return _this.bases.push(base);
        }
      };
    })(this));
    this.inPorts.key.on("data", (function(_this) {
      return function(key) {
        _this.key = key;
      };
    })(this));
    this.inPorts.reverse.on("data", (function(_this) {
      return function(reverse) {
        return _this.reverse = reverse === 'true';
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function(group) {};
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(incoming) {
        var base, out, _i, _len, _ref;
        out = {};
        _ref = _this.bases;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          base = _ref[_i];
          if ((_this.key == null) || (incoming[_this.key] != null) && incoming[_this.key] === base[_this.key]) {
            _.extend(out, base);
          }
        }
        if (_this.reverse) {
          return _this.outPorts.out.send(_.extend({}, incoming, out));
        } else {
          return _this.outPorts.out.send(_.extend(out, incoming));
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Extend;

})(noflo.Component);

exports.getComponent = function() {
  return new Extend;
};

});
require.register("noflo-noflo-objects/components/MergeObjects.js", function(exports, require, module){
var MergeObjects, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

noflo = require("noflo");

MergeObjects = (function(_super) {
  __extends(MergeObjects, _super);

  MergeObjects.prototype.description = "merges all incoming objects into one";

  function MergeObjects() {
    this.merge = _.bind(this.merge, this);
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.groups = [];
        return _this.objects = [];
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(object) {
        return _this.objects.push(object);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.out.send(_.reduce(_this.objects, _this.merge, {}));
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  MergeObjects.prototype.merge = function(origin, object) {
    var key, oValue, value;
    for (key in object) {
      value = object[key];
      oValue = origin[key];
      if (oValue != null) {
        switch (toString.call(oValue)) {
          case "[object Array]":
            origin[key].push.apply(origin[key], value);
            break;
          case "[object Object]":
            origin[key] = this.merge(oValue, value);
            break;
          default:
            origin[key] = value;
        }
      } else {
        origin[key] = value;
      }
    }
    return origin;
  };

  return MergeObjects;

})(noflo.Component);

exports.getComponent = function() {
  return new MergeObjects;
};

});
require.register("noflo-noflo-objects/components/SplitObject.js", function(exports, require, module){
var SplitObject, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

SplitObject = (function(_super) {
  __extends(SplitObject, _super);

  SplitObject.prototype.description = "splits a single object into multiple IPs, wrapped with the key as the group";

  function SplitObject() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var key, value, _results;
        _results = [];
        for (key in data) {
          value = data[key];
          _this.outPorts.out.beginGroup(key);
          _this.outPorts.out.send(value);
          _results.push(_this.outPorts.out.endGroup());
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return SplitObject;

})(noflo.Component);

exports.getComponent = function() {
  return new SplitObject;
};

});
require.register("noflo-noflo-objects/components/ReplaceKey.js", function(exports, require, module){
var ReplaceKey, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

ReplaceKey = (function(_super) {
  __extends(ReplaceKey, _super);

  ReplaceKey.prototype.description = "given a regexp matching any key of an incoming object as a data IP, replace the key with the provided string";

  function ReplaceKey() {
    this.patterns = {};
    this.inPorts = {
      "in": new noflo.Port,
      pattern: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.pattern.on("data", (function(_this) {
      return function(patterns) {
        _this.patterns = patterns;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var key, newKey, pattern, replace, value, _ref;
        newKey = null;
        for (key in data) {
          value = data[key];
          _ref = _this.patterns;
          for (pattern in _ref) {
            replace = _ref[pattern];
            pattern = new RegExp(pattern);
            if (key.match(pattern) != null) {
              newKey = key.replace(pattern, replace);
              data[newKey] = value;
              delete data[key];
            }
          }
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.pattern = null;
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return ReplaceKey;

})(noflo.Component);

exports.getComponent = function() {
  return new ReplaceKey;
};

});
require.register("noflo-noflo-objects/components/Keys.js", function(exports, require, module){
var Keys, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Keys = (function(_super) {
  __extends(Keys, _super);

  Keys.prototype.description = "gets only the keys of an object and forward them as an array";

  function Keys() {
    this.inPorts = {
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var key, _i, _len, _ref, _results;
        _ref = _.keys(data);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          _results.push(_this.outPorts.out.send(key));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Keys;

})(noflo.Component);

exports.getComponent = function() {
  return new Keys;
};

});
require.register("noflo-noflo-objects/components/Size.js", function(exports, require, module){
var Size, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Size = (function(_super) {
  __extends(Size, _super);

  Size.prototype.description = "gets the size of an object and sends that out as a number";

  function Size() {
    this.inPorts = {
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('integer')
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(_.size(data));
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Size;

})(noflo.Component);

exports.getComponent = function() {
  return new Size;
};

});
require.register("noflo-noflo-objects/components/Values.js", function(exports, require, module){
var Values, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Values = (function(_super) {
  __extends(Values, _super);

  Values.prototype.description = "gets only the values of an object and forward them as an array";

  function Values() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var value, _i, _len, _ref, _results;
        _ref = _.values(data);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          value = _ref[_i];
          _results.push(_this.outPorts.out.send(value));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Values;

})(noflo.Component);

exports.getComponent = function() {
  return new Values;
};

});
require.register("noflo-noflo-objects/components/Join.js", function(exports, require, module){
var Join, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

noflo = require("noflo");

Join = (function(_super) {
  __extends(Join, _super);

  Join.prototype.description = "Join all values of a passed packet together as a string with a predefined delimiter";

  function Join() {
    this.delimiter = ",";
    this.inPorts = {
      "in": new noflo.Port,
      delimiter: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.delimiter.on("data", (function(_this) {
      return function(delimiter) {
        _this.delimiter = delimiter;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(object) {
        if (_.isObject(object)) {
          return _this.outPorts.out.send(_.values(object).join(_this.delimiter));
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Join;

})(noflo.Component);

exports.getComponent = function() {
  return new Join;
};

});
require.register("noflo-noflo-objects/components/ExtractProperty.js", function(exports, require, module){
var ExtractProperty, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

ExtractProperty = (function(_super) {
  __extends(ExtractProperty, _super);

  ExtractProperty.prototype.description = "Given a key, return only the value matching that key in the incoming object";

  function ExtractProperty() {
    this.inPorts = {
      "in": new noflo.Port,
      key: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.key.on("connect", (function(_this) {
      return function() {
        return _this.keys = [];
      };
    })(this));
    this.inPorts.key.on("data", (function(_this) {
      return function(key) {
        return _this.keys.push(key);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var key, value, _i, _len, _ref;
        if ((_this.keys != null) && _.isObject(data)) {
          value = data;
          _ref = _this.keys;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            value = value[key];
          }
          return _this.outPorts.out.send(value);
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return ExtractProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new ExtractProperty;
};

});
require.register("noflo-noflo-objects/components/InsertProperty.js", function(exports, require, module){
var InsertProperty, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

InsertProperty = (function(_super) {
  __extends(InsertProperty, _super);

  InsertProperty.prototype.description = "Insert a property into incoming objects.";

  function InsertProperty() {
    this.properties = {};
    this.inPorts = {
      "in": new noflo.Port,
      property: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.property.on("connect", (function(_this) {
      return function() {
        return _this.properties = {};
      };
    })(this));
    this.inPorts.property.on("begingroup", (function(_this) {
      return function(key) {
        _this.key = key;
      };
    })(this));
    this.inPorts.property.on("data", (function(_this) {
      return function(value) {
        if (_this.key != null) {
          return _this.properties[_this.key] = value;
        }
      };
    })(this));
    this.inPorts.property.on("endgroup", (function(_this) {
      return function() {
        return _this.key = null;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var key, value, _ref;
        if (!_.isObject(data)) {
          data = {};
        }
        _ref = _this.properties;
        for (key in _ref) {
          value = _ref[key];
          data[key] = value;
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return InsertProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new InsertProperty;
};

});
require.register("noflo-noflo-objects/components/SliceArray.js", function(exports, require, module){
var SliceArray, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SliceArray = (function(_super) {
  __extends(SliceArray, _super);

  function SliceArray() {
    this.begin = 0;
    this.end = null;
    this.inPorts = {
      "in": new noflo.Port(),
      begin: new noflo.Port(),
      end: new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port(),
      error: new noflo.Port()
    };
    this.inPorts.begin.on('data', (function(_this) {
      return function(data) {
        return _this.begin = data;
      };
    })(this));
    this.inPorts.end.on('data', (function(_this) {
      return function(data) {
        return _this.end = data;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.sliceData(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SliceArray.prototype.sliceData = function(data) {
    var sliced;
    if (!data.slice) {
      return this.outPorts.error.send("Data " + (typeof data) + " cannot be sliced");
    }
    if (this.end !== null) {
      sliced = data.slice(this.begin, this.end);
    }
    if (this.end === null) {
      sliced = data.slice(this.begin);
    }
    return this.outPorts.out.send(sliced);
  };

  return SliceArray;

})(noflo.Component);

exports.getComponent = function() {
  return new SliceArray;
};

});
require.register("noflo-noflo-objects/components/SplitArray.js", function(exports, require, module){
var SplitArray, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SplitArray = (function(_super) {
  __extends(SplitArray, _super);

  function SplitArray() {
    this.inPorts = {
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.ArrayPort()
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var item, key, _i, _len, _results;
        if (toString.call(data) !== '[object Array]') {
          for (key in data) {
            item = data[key];
            _this.outPorts.out.beginGroup(key);
            _this.outPorts.out.send(item);
            _this.outPorts.out.endGroup();
          }
          return;
        }
        _results = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          _results.push(_this.outPorts.out.send(item));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function(data) {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return SplitArray;

})(noflo.Component);

exports.getComponent = function() {
  return new SplitArray;
};

});
require.register("noflo-noflo-objects/components/FilterPropertyValue.js", function(exports, require, module){
var FilterPropertyValue, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

FilterPropertyValue = (function(_super) {
  __extends(FilterPropertyValue, _super);

  FilterPropertyValue.prototype.icon = 'filter';

  function FilterPropertyValue() {
    this.accepts = {};
    this.regexps = {};
    this.inPorts = {
      accept: new noflo.ArrayPort('all'),
      regexp: new noflo.ArrayPort('string'),
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('object'),
      missed: new noflo.Port('object')
    };
    this.inPorts.accept.on('data', (function(_this) {
      return function(data) {
        return _this.prepareAccept(data);
      };
    })(this));
    this.inPorts.regexp.on('data', (function(_this) {
      return function(data) {
        return _this.prepareRegExp(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.filtering()) {
          return _this.filterData(data);
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  FilterPropertyValue.prototype.filtering = function() {
    return (Object.keys(this.accepts)).length > 0 || (Object.keys(this.regexps)).length > 0;
  };

  FilterPropertyValue.prototype.prepareAccept = function(map) {
    var e, mapParts;
    if (typeof map === 'object') {
      this.accepts = map;
      return;
    }
    mapParts = map.split('=');
    try {
      return this.accepts[mapParts[0]] = eval(mapParts[1]);
    } catch (_error) {
      e = _error;
      if (e instanceof ReferenceError) {
        return this.accepts[mapParts[0]] = mapParts[1];
      } else {
        throw e;
      }
    }
  };

  FilterPropertyValue.prototype.prepareRegExp = function(map) {
    var mapParts;
    mapParts = map.split('=');
    return this.regexps[mapParts[0]] = mapParts[1];
  };

  FilterPropertyValue.prototype.filterData = function(object) {
    var match, newData, property, regexp, value;
    newData = {};
    match = false;
    for (property in object) {
      value = object[property];
      if (this.accepts[property]) {
        if (this.accepts[property] !== value) {
          continue;
        }
        match = true;
      }
      if (this.regexps[property]) {
        regexp = new RegExp(this.regexps[property]);
        if (!regexp.exec(value)) {
          continue;
        }
        match = true;
      }
      newData[property] = value;
      continue;
    }
    if (!match) {
      if (!this.outPorts.missed.isAttached()) {
        return;
      }
      this.outPorts.missed.send(object);
      this.outPorts.missed.disconnect();
      return;
    }
    return this.outPorts.out.send(newData);
  };

  return FilterPropertyValue;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterPropertyValue;
};

});
require.register("noflo-noflo-objects/components/FlattenObject.js", function(exports, require, module){
var FlattenObject, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

FlattenObject = (function(_super) {
  __extends(FlattenObject, _super);

  function FlattenObject() {
    this.map = {};
    this.inPorts = {
      map: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.map.on('data', (function(_this) {
      return function(data) {
        return _this.prepareMap(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var object, _i, _len, _ref, _results;
        _ref = _this.flattenObject(data);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          object = _ref[_i];
          _results.push(_this.outPorts.out.send(_this.mapKeys(object)));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  FlattenObject.prototype.prepareMap = function(map) {
    var mapParts;
    if (typeof map === 'object') {
      this.map = map;
      return;
    }
    mapParts = map.split('=');
    return this.map[mapParts[0]] = mapParts[1];
  };

  FlattenObject.prototype.mapKeys = function(object) {
    var key, map, _ref;
    _ref = this.map;
    for (key in _ref) {
      map = _ref[key];
      object[map] = object.flattenedKeys[key];
    }
    delete object.flattenedKeys;
    return object;
  };

  FlattenObject.prototype.flattenObject = function(object) {
    var flattened, flattenedValue, key, val, value, _i, _len;
    flattened = [];
    for (key in object) {
      value = object[key];
      if (typeof value === 'object') {
        flattenedValue = this.flattenObject(value);
        for (_i = 0, _len = flattenedValue.length; _i < _len; _i++) {
          val = flattenedValue[_i];
          val.flattenedKeys.push(key);
          flattened.push(val);
        }
        continue;
      }
      flattened.push({
        flattenedKeys: [key],
        value: value
      });
    }
    return flattened;
  };

  return FlattenObject;

})(noflo.Component);

exports.getComponent = function() {
  return new FlattenObject;
};

});
require.register("noflo-noflo-objects/components/MapProperty.js", function(exports, require, module){
var MapProperty, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MapProperty = (function(_super) {
  __extends(MapProperty, _super);

  function MapProperty() {
    this.map = {};
    this.regexps = {};
    this.inPorts = {
      map: new noflo.ArrayPort(),
      regexp: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.map.on('data', (function(_this) {
      return function(data) {
        return _this.prepareMap(data);
      };
    })(this));
    this.inPorts.regexp.on('data', (function(_this) {
      return function(data) {
        return _this.prepareRegExp(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.mapData(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  MapProperty.prototype.prepareMap = function(map) {
    var mapParts;
    if (typeof map === 'object') {
      this.map = map;
      return;
    }
    mapParts = map.split('=');
    return this.map[mapParts[0]] = mapParts[1];
  };

  MapProperty.prototype.prepareRegExp = function(map) {
    var mapParts;
    mapParts = map.split('=');
    return this.regexps[mapParts[0]] = mapParts[1];
  };

  MapProperty.prototype.mapData = function(data) {
    var expression, matched, newData, property, regexp, replacement, value, _ref;
    newData = {};
    for (property in data) {
      value = data[property];
      if (property in this.map) {
        property = this.map[property];
      }
      _ref = this.regexps;
      for (expression in _ref) {
        replacement = _ref[expression];
        regexp = new RegExp(expression);
        matched = regexp.exec(property);
        if (!matched) {
          continue;
        }
        property = property.replace(regexp, replacement);
      }
      if (property in newData) {
        if (Array.isArray(newData[property])) {
          newData[property].push(value);
        } else {
          newData[property] = [newData[property], value];
        }
      } else {
        newData[property] = value;
      }
    }
    return this.outPorts.out.send(newData);
  };

  return MapProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new MapProperty;
};

});
require.register("noflo-noflo-objects/components/RemoveProperty.js", function(exports, require, module){
var RemoveProperty, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore');

RemoveProperty = (function(_super) {
  __extends(RemoveProperty, _super);

  RemoveProperty.prototype.icon = 'ban';

  function RemoveProperty() {
    this.properties = [];
    this.inPorts = {
      "in": new noflo.Port(),
      property: new noflo.ArrayPort()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.property.on('data', (function(_this) {
      return function(data) {
        return _this.properties.push(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(_this.removeProperties(data));
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  RemoveProperty.prototype.removeProperties = function(object) {
    var property, _i, _len, _ref;
    object = _.clone(object);
    _ref = this.properties;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      property = _ref[_i];
      delete object[property];
    }
    return object;
  };

  return RemoveProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new RemoveProperty;
};

});
require.register("noflo-noflo-objects/components/MapPropertyValue.js", function(exports, require, module){
var MapPropertyValue, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MapPropertyValue = (function(_super) {
  __extends(MapPropertyValue, _super);

  function MapPropertyValue() {
    this.mapAny = {};
    this.map = {};
    this.regexpAny = {};
    this.regexp = {};
    this.inPorts = {
      map: new noflo.ArrayPort(),
      regexp: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.map.on('data', (function(_this) {
      return function(data) {
        return _this.prepareMap(data);
      };
    })(this));
    this.inPorts.regexp.on('data', (function(_this) {
      return function(data) {
        return _this.prepareRegExp(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.mapData(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  MapPropertyValue.prototype.prepareMap = function(map) {
    var mapParts;
    if (typeof map === 'object') {
      this.mapAny = map;
      return;
    }
    mapParts = map.split('=');
    if (mapParts.length === 3) {
      this.map[mapParts[0]] = {
        from: mapParts[1],
        to: mapParts[2]
      };
      return;
    }
    return this.mapAny[mapParts[0]] = mapParts[1];
  };

  MapPropertyValue.prototype.prepareRegExp = function(map) {
    var mapParts;
    mapParts = map.split('=');
    if (mapParts.length === 3) {
      this.regexp[mapParts[0]] = {
        from: mapParts[1],
        to: mapParts[2]
      };
      return;
    }
    return this.regexpAny[mapParts[0]] = mapParts[1];
  };

  MapPropertyValue.prototype.mapData = function(data) {
    var expression, matched, property, regexp, replacement, value, _ref;
    for (property in data) {
      value = data[property];
      if (this.map[property] && this.map[property].from === value) {
        data[property] = this.map[property].to;
      }
      if (this.mapAny[value]) {
        data[property] = this.mapAny[value];
      }
      if (this.regexp[property]) {
        regexp = new RegExp(this.regexp[property].from);
        matched = regexp.exec(value);
        if (matched) {
          data[property] = value.replace(regexp, this.regexp[property].to);
        }
      }
      _ref = this.regexpAny;
      for (expression in _ref) {
        replacement = _ref[expression];
        regexp = new RegExp(expression);
        matched = regexp.exec(value);
        if (!matched) {
          continue;
        }
        data[property] = value.replace(regexp, replacement);
      }
    }
    return this.outPorts.out.send(data);
  };

  return MapPropertyValue;

})(noflo.Component);

exports.getComponent = function() {
  return new MapPropertyValue;
};

});
require.register("noflo-noflo-objects/components/GetObjectKey.js", function(exports, require, module){
var GetObjectKey, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetObjectKey = (function(_super) {
  __extends(GetObjectKey, _super);

  GetObjectKey.prototype.icon = 'indent';

  function GetObjectKey() {
    this.sendGroup = true;
    this.data = [];
    this.key = [];
    this.inPorts = {
      "in": new noflo.Port('object'),
      key: new noflo.ArrayPort('string'),
      sendgroup: new noflo.Port('boolean')
    };
    this.outPorts = {
      out: new noflo.Port('all'),
      object: new noflo.Port('object'),
      missed: new noflo.Port('object')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.data = [];
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.key.length) {
          return _this.getKey(data);
        }
        return _this.data.push(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        var data, _i, _len, _ref;
        if (!_this.data.length) {
          _this.outPorts.out.disconnect();
          return;
        }
        if (!_this.key.length) {
          return;
        }
        _ref = _this.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          _this.getKey(data);
        }
        _this.outPorts.out.disconnect();
        if (_this.outPorts.object.isAttached()) {
          return _this.outPorts.object.disconnect();
        }
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        return _this.key.push(data);
      };
    })(this));
    this.inPorts.key.on('disconnect', (function(_this) {
      return function() {
        var data, _i, _len, _ref;
        if (!_this.data.length) {
          return;
        }
        _ref = _this.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          _this.getKey(data);
        }
        _this.data = [];
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.sendgroup.on('data', (function(_this) {
      return function(data) {
        return _this.sendGroup = String(data) === 'true';
      };
    })(this));
  }

  GetObjectKey.prototype.error = function(data, error) {
    if (this.outPorts.missed.isAttached()) {
      this.outPorts.missed.send(data);
      this.outPorts.missed.disconnect();
      return;
    }
    throw error;
  };

  GetObjectKey.prototype.getKey = function(data) {
    var key, _i, _len, _ref;
    if (!this.key.length) {
      this.error(data, new Error('Key not defined'));
      return;
    }
    if (typeof data !== 'object') {
      this.error(data, new Error('Data is not an object'));
      return;
    }
    if (data === null) {
      this.error(data, new Error('Data is NULL'));
      return;
    }
    _ref = this.key;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (data[key] === void 0) {
        this.error(data, new Error("Object has no key " + key));
        continue;
      }
      if (this.sendGroup) {
        this.outPorts.out.beginGroup(key);
      }
      this.outPorts.out.send(data[key]);
      if (this.sendGroup) {
        this.outPorts.out.endGroup();
      }
    }
    if (!this.outPorts.object.isAttached()) {
      return;
    }
    return this.outPorts.object.send(data);
  };

  return GetObjectKey;

})(noflo.Component);

exports.getComponent = function() {
  return new GetObjectKey;
};

});
require.register("noflo-noflo-objects/components/UniqueArray.js", function(exports, require, module){
var UniqueArray, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

UniqueArray = (function(_super) {
  __extends(UniqueArray, _super);

  function UniqueArray() {
    this.inPorts = {
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(_this.unique(data));
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  UniqueArray.prototype.unique = function(array) {
    var member, newArray, seen, _i, _len;
    seen = {};
    newArray = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      member = array[_i];
      seen[member] = member;
    }
    for (member in seen) {
      newArray.push(member);
    }
    return newArray;
  };

  return UniqueArray;

})(noflo.Component);

exports.getComponent = function() {
  return new UniqueArray;
};

});
require.register("noflo-noflo-objects/components/SetProperty.js", function(exports, require, module){
var SetProperty, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetProperty = (function(_super) {
  __extends(SetProperty, _super);

  function SetProperty() {
    this.properties = {};
    this.inPorts = {
      property: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.property.on('data', (function(_this) {
      return function(data) {
        return _this.setProperty(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.addProperties(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SetProperty.prototype.setProperty = function(prop) {
    var propParts;
    if (typeof prop === 'object') {
      this.prop = prop;
      return;
    }
    propParts = prop.split('=');
    return this.properties[propParts[0]] = propParts[1];
  };

  SetProperty.prototype.addProperties = function(object) {
    var property, value, _ref;
    _ref = this.properties;
    for (property in _ref) {
      value = _ref[property];
      object[property] = value;
    }
    return this.outPorts.out.send(object);
  };

  return SetProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new SetProperty;
};

});
require.register("noflo-noflo-objects/components/SimplifyObject.js", function(exports, require, module){
var SimplifyObject, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore')._;

SimplifyObject = (function(_super) {
  __extends(SimplifyObject, _super);

  function SimplifyObject() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on('beginGroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(_this.simplify(data));
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SimplifyObject.prototype.simplify = function(data) {
    if (_.isArray(data)) {
      if (data.length === 1) {
        return data[0];
      }
      return data;
    }
    if (!_.isObject(data)) {
      return data;
    }
    return this.simplifyObject(data);
  };

  SimplifyObject.prototype.simplifyObject = function(data) {
    var keys, simplified;
    keys = _.keys(data);
    if (keys.length === 1 && keys[0] === '$data') {
      return this.simplify(data['$data']);
    }
    simplified = {};
    _.each(data, (function(_this) {
      return function(value, key) {
        return simplified[key] = _this.simplify(value);
      };
    })(this));
    return simplified;
  };

  return SimplifyObject;

})(noflo.Component);

exports.getComponent = function() {
  return new SimplifyObject;
};

});
require.register("noflo-noflo-objects/components/DuplicateProperty.js", function(exports, require, module){
var DuplicateProperty, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DuplicateProperty = (function(_super) {
  __extends(DuplicateProperty, _super);

  function DuplicateProperty() {
    this.properties = {};
    this.separator = '/';
    this.inPorts = {
      property: new noflo.ArrayPort(),
      separator: new noflo.Port(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.property.on('data', (function(_this) {
      return function(data) {
        return _this.setProperty(data);
      };
    })(this));
    this.inPorts.separator.on('data', (function(_this) {
      return function(data) {
        return _this.separator = data;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.addProperties(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  DuplicateProperty.prototype.setProperty = function(prop) {
    var propParts;
    if (typeof prop === 'object') {
      this.prop = prop;
      return;
    }
    propParts = prop.split('=');
    if (propParts.length > 2) {
      this.properties[propParts.pop()] = propParts;
      return;
    }
    return this.properties[propParts[1]] = propParts[0];
  };

  DuplicateProperty.prototype.addProperties = function(object) {
    var newValues, newprop, original, originalProp, _i, _len, _ref;
    _ref = this.properties;
    for (newprop in _ref) {
      original = _ref[newprop];
      if (typeof original === 'string') {
        object[newprop] = object[original];
        continue;
      }
      newValues = [];
      for (_i = 0, _len = original.length; _i < _len; _i++) {
        originalProp = original[_i];
        newValues.push(object[originalProp]);
      }
      object[newprop] = newValues.join(this.separator);
    }
    return this.outPorts.out.send(object);
  };

  return DuplicateProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new DuplicateProperty;
};

});
require.register("noflo-noflo-objects/components/CreateObject.js", function(exports, require, module){
var CreateObject, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CreateObject = (function(_super) {
  __extends(CreateObject, _super);

  function CreateObject() {
    this.inPorts = {
      start: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.start.on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts.start.on("data", (function(_this) {
      return function() {
        return _this.outPorts.out.send({});
      };
    })(this));
    this.inPorts.start.on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts.start.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return CreateObject;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateObject;
};

});
require.register("noflo-noflo-objects/components/CreateDate.js", function(exports, require, module){
var CreateDate, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

CreateDate = (function(_super) {
  __extends(CreateDate, _super);

  CreateDate.prototype.description = 'Create a new Date object from string';

  CreateDate.prototype.icon = 'clock-o';

  function CreateDate() {
    this.inPorts = {
      "in": new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var date;
        if (data === "now" || data === null || data === true) {
          date = new Date;
        } else {
          date = new Date(data);
        }
        return _this.outPorts.out.send(date);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return CreateDate;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateDate;
};

});
require.register("noflo-noflo-objects/components/SetPropertyValue.js", function(exports, require, module){
var SetPropertyValue, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetPropertyValue = (function(_super) {
  __extends(SetPropertyValue, _super);

  function SetPropertyValue() {
    this.property = null;
    this.value = null;
    this.data = [];
    this.groups = [];
    this.keep = false;
    this.inPorts = {
      property: new noflo.Port('string'),
      value: new noflo.Port('all'),
      "in": new noflo.Port('object'),
      keep: new noflo.Port('boolean')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.keep.on('data', (function(_this) {
      return function(keep) {
        return _this.keep = String(keep) === 'true';
      };
    })(this));
    this.inPorts.property.on('data', (function(_this) {
      return function(data) {
        _this.property = data;
        if (_this.value && _this.data.length) {
          return _this.addProperties();
        }
      };
    })(this));
    this.inPorts.value.on('data', (function(_this) {
      return function(data) {
        _this.value = data;
        if (_this.property && _this.data.length) {
          return _this.addProperties();
        }
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.property && _this.value) {
          _this.addProperty({
            data: data,
            group: _this.groups.slice(0)
          });
          return;
        }
        return _this.data.push({
          data: data,
          group: _this.groups.slice(0)
        });
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.property && _this.value) {
          _this.outPorts.out.disconnect();
        }
        if (!_this.keep) {
          return _this.value = null;
        }
      };
    })(this));
  }

  SetPropertyValue.prototype.addProperty = function(object) {
    var group, _i, _j, _len, _len1, _ref, _ref1, _results;
    object.data[this.property] = this.value;
    _ref = object.group;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      this.outPorts.out.beginGroup(group);
    }
    this.outPorts.out.send(object.data);
    _ref1 = object.group;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      group = _ref1[_j];
      _results.push(this.outPorts.out.endGroup());
    }
    return _results;
  };

  SetPropertyValue.prototype.addProperties = function() {
    var object, _i, _len, _ref;
    _ref = this.data;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      this.addProperty(object);
    }
    this.data = [];
    return this.outPorts.out.disconnect();
  };

  return SetPropertyValue;

})(noflo.Component);

exports.getComponent = function() {
  return new SetPropertyValue;
};

});
require.register("noflo-noflo-objects/components/CallMethod.js", function(exports, require, module){
var CallMethod, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

CallMethod = (function(_super) {
  __extends(CallMethod, _super);

  CallMethod.prototype.description = "call a method on an object";

  CallMethod.prototype.icon = 'gear';

  function CallMethod() {
    this.method = null;
    this.args = [];
    this.inPorts = {
      "in": new noflo.Port('object'),
      method: new noflo.Port('string'),
      "arguments": new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.Port('all'),
      error: new noflo.Port('string')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var msg;
        if (!_this.method) {
          return;
        }
        if (!data[_this.method]) {
          msg = "Method '" + _this.method + "' not available";
          if (_this.outPorts.error.isAttached()) {
            _this.outPorts.error.send(msg);
            _this.outPorts.error.disconnect();
            return;
          }
          throw new Error(msg);
        }
        _this.outPorts.out.send(data[_this.method].apply(data, _this.args));
        return _this.args = [];
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.method.on("data", (function(_this) {
      return function(data) {
        return _this.method = data;
      };
    })(this));
    this.inPorts["arguments"].on('connect', (function(_this) {
      return function() {
        return _this.args = [];
      };
    })(this));
    this.inPorts["arguments"].on('data', (function(_this) {
      return function(data) {
        return _this.args.push(data);
      };
    })(this));
  }

  return CallMethod;

})(noflo.Component);

exports.getComponent = function() {
  return new CallMethod;
};

});
require.register("noflo-noflo-packets/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of packets.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-packets/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-packets","description":"The best project ever.","version":"0.0.8","author":"Kenneth Kan <kenhkan@gmail.com>","repo":"kenhkan/packets","keywords":[],"dependencies":{"noflo/noflo":"*","component/underscore":"*"},"scripts":["components/CountPackets.coffee","components/Unzip.coffee","components/Defaults.coffee","components/DoNotDisconnect.coffee","components/OnlyDisconnect.coffee","components/SplitPacket.coffee","components/Range.coffee","components/Flatten.coffee","components/Compact.coffee","components/Zip.coffee","components/SendWith.coffee","components/FilterPackets.coffee","components/FilterByValue.coffee","components/FilterByPosition.coffee","components/FilterPacket.coffee","components/UniquePacket.coffee","components/GroupByPacket.coffee","components/LastPacket.coffee","components/Counter.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"dropbox","components":{"CountPackets":"components/CountPackets.coffee","Unzip":"components/Unzip.coffee","Defaults":"components/Defaults.coffee","DoNotDisconnect":"components/DoNotDisconnect.coffee","OnlyDisconnect":"components/OnlyDisconnect.coffee","SplitPacket":"components/SplitPacket.coffee","Range":"components/Range.coffee","Flatten":"components/Flatten.coffee","Compact":"components/Compact.coffee","Zip":"components/Zip.coffee","SendWith":"components/SendWith.coffee","FilterPackets":"components/FilterPackets.coffee","FilterByValue":"components/FilterByValue.coffee","FilterByPosition":"components/FilterByPosition.coffee","FilterPacket":"components/FilterPacket.coffee","UniquePacket":"components/UniquePacket.coffee","GroupByPacket":"components/GroupByPacket.coffee","LastPacket":"components/LastPacket.coffee","Counter":"components/Counter.coffee"}}}');
});
require.register("noflo-noflo-packets/components/CountPackets.js", function(exports, require, module){
var CountPackets, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

CountPackets = (function(_super) {
  __extends(CountPackets, _super);

  CountPackets.prototype.description = "count number of data IPs";

  CountPackets.prototype.icon = 'sort-numeric-asc';

  function CountPackets() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      count: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        var count;
        _this.counts = [0];
        return count = _.last(_this.counts);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        _this.counts.push(0);
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var count;
        _this.counts[_this.counts.length - 1]++;
        count = _.last(_this.counts);
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        var count;
        count = _.last(_this.counts);
        _this.outPorts.count.send(count);
        _this.counts.pop();
        return _this.outPorts.out.endGroup(group);
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var count;
        count = _.last(_this.counts);
        _this.outPorts.count.send(count);
        _this.outPorts.count.disconnect();
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return CountPackets;

})(noflo.Component);

exports.getComponent = function() {
  return new CountPackets;
};

});
require.register("noflo-noflo-packets/components/Unzip.js", function(exports, require, module){
var Unzip, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

noflo = require("noflo");

Unzip = (function(_super) {
  __extends(Unzip, _super);

  Unzip.prototype.description = "Send packets whose position upon receipt is even to the EVEN port, otherwise the ODD port.";

  function Unzip() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      odd: new noflo.Port,
      even: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function(group) {
        return _this.count = 0;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var port;
        _this.count++;
        port = _this.count % 2 === 0 ? "even" : "odd";
        return _this.outPorts[port].send(data);
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.odd.disconnect();
        return _this.outPorts.even.disconnect();
      };
    })(this));
  }

  return Unzip;

})(noflo.Component);

exports.getComponent = function() {
  return new Unzip;
};

});
require.register("noflo-noflo-packets/components/Defaults.js", function(exports, require, module){
var Defaults, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Defaults = (function(_super) {
  __extends(Defaults, _super);

  Defaults.prototype.description = "if incoming is short of the length of the default packets, send the default packets.";

  function Defaults() {
    this.defaults = [];
    this.inPorts = {
      "in": new noflo.Port,
      "default": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["default"].on("connect", (function(_this) {
      return function() {
        return _this.defaults = [];
      };
    })(this));
    this.inPorts["default"].on("data", (function(_this) {
      return function(data) {
        return _this.defaults.push(data);
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        return _this.counts = [0];
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        _this.counts.push(0);
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var count;
        count = _.last(_this.counts);
        if (data == null) {
          data = _this.defaults[count];
        }
        _this.outPorts.out.send(data);
        return _this.counts[_this.counts.length - 1]++;
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        _this.padPackets(_.last(_this.counts));
        _this.counts.pop();
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.padPackets(_this.counts[0]);
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  Defaults.prototype.padPackets = function(count) {
    var _results;
    _results = [];
    while (count < this.defaults.length) {
      this.outPorts.out.send(this.defaults[count]);
      _results.push(count++);
    }
    return _results;
  };

  return Defaults;

})(noflo.Component);

exports.getComponent = function() {
  return new Defaults;
};

});
require.register("noflo-noflo-packets/components/DoNotDisconnect.js", function(exports, require, module){
var DoNotDisconnect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

DoNotDisconnect = (function(_super) {
  __extends(DoNotDisconnect, _super);

  DoNotDisconnect.prototype.description = "forwards everything but never disconnect";

  function DoNotDisconnect() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
  }

  return DoNotDisconnect;

})(noflo.Component);

exports.getComponent = function() {
  return new DoNotDisconnect;
};

});
require.register("noflo-noflo-packets/components/OnlyDisconnect.js", function(exports, require, module){
var OnlyDisconnect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

OnlyDisconnect = (function(_super) {
  __extends(OnlyDisconnect, _super);

  OnlyDisconnect.prototype.description = "the inverse of DoNotDisconnect";

  function OnlyDisconnect() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.out.connect();
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return OnlyDisconnect;

})(noflo.Component);

exports.getComponent = function() {
  return new OnlyDisconnect;
};

});
require.register("noflo-noflo-packets/components/SplitPacket.js", function(exports, require, module){
var SplitPacket, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

SplitPacket = (function(_super) {
  __extends(SplitPacket, _super);

  SplitPacket.prototype.description = "splits each incoming packet into its own connection";

  function SplitPacket() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        return _this.groups = [];
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var group, _i, _j, _len, _len1, _ref, _ref1;
        _this.outPorts.out.connect();
        _ref = _this.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.beginGroup(group);
        }
        _this.outPorts.out.send(data);
        _ref1 = _this.groups;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          _this.outPorts.out.endGroup();
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.groups.pop();
      };
    })(this));
  }

  return SplitPacket;

})(noflo.Component);

exports.getComponent = function() {
  return new SplitPacket;
};

});
require.register("noflo-noflo-packets/components/Range.js", function(exports, require, module){
var Range, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Range = (function(_super) {
  __extends(Range, _super);

  Range.prototype.description = "only forward a specified number of packets in a connection";

  function Range() {
    this.start = -Infinity;
    this.end = +Infinity;
    this.length = +Infinity;
    this.inPorts = {
      "in": new noflo.Port,
      start: new noflo.Port,
      end: new noflo.Port,
      length: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.start.on("data", (function(_this) {
      return function(start) {
        return _this.start = parseInt(start);
      };
    })(this));
    this.inPorts.end.on("data", (function(_this) {
      return function(end) {
        return _this.end = parseInt(end);
      };
    })(this));
    this.inPorts.length.on("data", (function(_this) {
      return function(length) {
        return _this.length = parseInt(length);
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.totalCount = 0;
        return _this.sentCount = 0;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        _this.totalCount++;
        if (_this.totalCount > _this.start && _this.totalCount < _this.end && _this.sentCount < _this.length) {
          _this.sentCount++;
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Range;

})(noflo.Component);

exports.getComponent = function() {
  return new Range;
};

});
require.register("noflo-noflo-packets/components/Flatten.js", function(exports, require, module){
var Flatten, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Flatten = (function(_super) {
  __extends(Flatten, _super);

  Flatten.prototype.description = "Flatten the IP structure but preserve all groups (i.e. all groups are at the top level)";

  function Flatten() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.groups = [];
        return _this.cache = [];
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        var loc;
        loc = _this.locate();
        loc[group] = [];
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var loc;
        loc = _this.locate();
        return loc.push(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var nodes, packets, _ref;
        _ref = _this.flatten(_this.cache), packets = _ref.packets, nodes = _ref.nodes;
        _this.flush(_.extend(packets, nodes));
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  Flatten.prototype.locate = function() {
    return _.reduce(this.groups, (function(loc, group) {
      return loc[group];
    }), this.cache);
  };

  Flatten.prototype.flatten = function(node) {
    var group, groups, nodes, packets, subnodes, _i, _len, _ref;
    groups = this.getNonArrayKeys(node);
    if (groups.length === 0) {
      return {
        packets: node,
        nodes: {}
      };
    } else {
      subnodes = {};
      for (_i = 0, _len = groups.length; _i < _len; _i++) {
        group = groups[_i];
        _ref = this.flatten(node[group]), packets = _ref.packets, nodes = _ref.nodes;
        delete node[group];
        subnodes[group] = packets;
        _.extend(subnodes, nodes);
      }
      return {
        packets: node,
        nodes: subnodes
      };
    }
  };

  Flatten.prototype.getNonArrayKeys = function(node) {
    return _.compact(_.filter(_.keys(node), function(key) {
      return isNaN(parseInt(key));
    }));
  };

  Flatten.prototype.flush = function(node) {
    var group, packet, _i, _j, _len, _len1, _ref, _results;
    for (_i = 0, _len = node.length; _i < _len; _i++) {
      packet = node[_i];
      this.outPorts.out.send(packet);
    }
    _ref = this.getNonArrayKeys(node);
    _results = [];
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      group = _ref[_j];
      this.outPorts.out.beginGroup(group);
      this.flush(node[group]);
      _results.push(this.outPorts.out.endGroup());
    }
    return _results;
  };

  return Flatten;

})(noflo.Component);

exports.getComponent = function() {
  return new Flatten;
};

});
require.register("noflo-noflo-packets/components/Compact.js", function(exports, require, module){
var Compact, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Compact = (function(_super) {
  __extends(Compact, _super);

  Compact.prototype.description = "Remove null";

  function Compact() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (data == null) {
          return;
        }
        if (data.length === 0) {
          return;
        }
        if (_.isObject(data) && _.isEmpty(data)) {
          return;
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Compact;

})(noflo.Component);

exports.getComponent = function() {
  return new Compact;
};

});
require.register("noflo-noflo-packets/components/Zip.js", function(exports, require, module){
var Zip, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Zip = (function(_super) {
  __extends(Zip, _super);

  Zip.prototype.description = "zip through multiple IPs and output a series of zipped IPs just like how _.zip() works in Underscore.js";

  function Zip() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function(group) {
        return _this.packets = [];
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (_.isArray(data)) {
          return _this.packets.push(data);
        }
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        if (_.isEmpty(_this.packets)) {
          _this.outPorts.out.send([]);
        } else {
          _this.outPorts.out.send(_.zip.apply(_, _this.packets));
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Zip;

})(noflo.Component);

exports.getComponent = function() {
  return new Zip;
};

});
require.register("noflo-noflo-packets/components/SendWith.js", function(exports, require, module){
var SendWith, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

SendWith = (function(_super) {
  __extends(SendWith, _super);

  SendWith.prototype.description = "Always send the specified packets with incoming packets.";

  function SendWith() {
    this["with"] = [];
    this.inPorts = {
      "in": new noflo.Port,
      "with": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["with"].on("connect", (function(_this) {
      return function() {
        return _this["with"] = [];
      };
    })(this));
    this.inPorts["with"].on("data", (function(_this) {
      return function(data) {
        return _this["with"].push(data);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var packet, _i, _len, _ref;
        _ref = _this["with"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          packet = _ref[_i];
          _this.outPorts.out.send(packet);
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return SendWith;

})(noflo.Component);

exports.getComponent = function() {
  return new SendWith;
};

});
require.register("noflo-noflo-packets/components/FilterPackets.js", function(exports, require, module){
var FilterPackets, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

FilterPackets = (function(_super) {
  __extends(FilterPackets, _super);

  FilterPackets.prototype.description = "Filter packets matching some RegExp strings";

  function FilterPackets() {
    this.regexps = [];
    this.inPorts = {
      "in": new noflo.Port,
      regexp: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      missed: new noflo.Port,
      passthru: new noflo.Port
    };
    this.inPorts.regexp.on("connect", (function(_this) {
      return function() {
        return _this.regexps = [];
      };
    })(this));
    this.inPorts.regexp.on("data", (function(_this) {
      return function(regexp) {
        return _this.regexps.push(new RegExp(regexp));
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (_.any(_this.regexps, (function(regexp) {
          return data.match(regexp);
        }))) {
          _this.outPorts.out.send(data);
        } else {
          _this.outPorts.missed.send(data);
        }
        if (_this.outPorts.passthru.isAttached()) {
          return _this.outPorts.passthru.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        _this.outPorts.missed.disconnect();
        if (_this.outPorts.passthru.isAttached()) {
          return _this.outPorts.passthru.disconnect();
        }
      };
    })(this));
  }

  return FilterPackets;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterPackets;
};

});
require.register("noflo-noflo-packets/components/FilterByValue.js", function(exports, require, module){
var FilterByValue, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

FilterByValue = (function(_super) {
  __extends(FilterByValue, _super);

  FilterByValue.prototype.description = "Filter packets based on their value";

  function FilterByValue() {
    this.filterValue = null;
    this.inPorts = {
      "in": new noflo.Port,
      filtervalue: new noflo.Port
    };
    this.outPorts = {
      lower: new noflo.Port,
      higher: new noflo.Port,
      equal: new noflo.Port
    };
    this.inPorts.filtervalue.on('data', (function(_this) {
      return function(data) {
        return _this.filterValue = data;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (data < _this.filterValue) {
          return _this.outPorts.lower.send(data);
        } else if (data > _this.filterValue) {
          return _this.outPorts.higher.send(data);
        } else if (data === _this.filterValue) {
          return _this.outPorts.equal.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.outPorts.lower.isConnected()) {
          _this.outPorts.lower.disconnect();
        }
        if (_this.outPorts.higher.isConnected()) {
          _this.outPorts.higher.disconnect();
        }
        if (_this.outPorts.equal.isConnected()) {
          return _this.outPorts.equal.disconnect();
        }
      };
    })(this));
  }

  return FilterByValue;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterByValue;
};

});
require.register("noflo-noflo-packets/components/FilterByPosition.js", function(exports, require, module){
var FilterByPosition, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

FilterByPosition = (function(_super) {
  __extends(FilterByPosition, _super);

  FilterByPosition.prototype.description = "Filter packets based on their positions";

  function FilterByPosition() {
    this.filters = [];
    this.inPorts = {
      "in": new noflo.Port,
      filter: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.filter.on("connect", (function(_this) {
      return function() {
        return _this.filters = [];
      };
    })(this));
    this.inPorts.filter.on("data", (function(_this) {
      return function(filter) {
        return _this.filters.push(filter);
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        return _this.count = 0;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (_this.filters[_this.count]) {
          _this.outPorts.out.send(data);
        }
        return _this.count++;
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return FilterByPosition;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterByPosition;
};

});
require.register("noflo-noflo-packets/components/FilterPacket.js", function(exports, require, module){
var FilterPacket, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

FilterPacket = (function(_super) {
  __extends(FilterPacket, _super);

  function FilterPacket() {
    this.regexps = [];
    this.inPorts = {
      regexp: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port(),
      missed: new noflo.Port()
    };
    this.inPorts.regexp.on('data', (function(_this) {
      return function(data) {
        return _this.regexps.push(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.regexps.length) {
          return _this.filterData(data);
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        return _this.outPorts.missed.disconnect();
      };
    })(this));
  }

  FilterPacket.prototype.filterData = function(data) {
    var expression, match, regexp, _i, _len, _ref;
    match = false;
    _ref = this.regexps;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      expression = _ref[_i];
      regexp = new RegExp(expression);
      if (!regexp.exec(data)) {
        continue;
      }
      match = true;
    }
    if (!match) {
      if (this.outPorts.missed.isAttached()) {
        this.outPorts.missed.send(data);
      }
      return;
    }
    return this.outPorts.out.send(data);
  };

  return FilterPacket;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterPacket;
};

});
require.register("noflo-noflo-packets/components/UniquePacket.js", function(exports, require, module){
var UniquePacket, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

UniquePacket = (function(_super) {
  __extends(UniquePacket, _super);

  function UniquePacket() {
    this.seen = [];
    this.groups = [];
    this.inPorts = {
      "in": new noflo.Port('all'),
      clear: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('all'),
      duplicate: new noflo.Port('all')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var group, _i, _j, _len, _len1, _ref, _ref1, _results;
        if (!_this.unique(data)) {
          if (!_this.outPorts.duplicate.isAttached()) {
            return;
          }
          _this.outPorts.duplicate.send(data);
          return;
        }
        _ref = _this.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.beginGroup(group);
        }
        _this.outPorts.out.send(data);
        _ref1 = _this.groups;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          _results.push(_this.outPorts.out.endGroup());
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        if (!_this.outPorts.duplicate.isAttached()) {
          return;
        }
        return _this.outPorts.duplicate.disconnect();
      };
    })(this));
    this.inPorts.clear.on('data', (function(_this) {
      return function() {
        _this.seen = [];
        return _this.groups = [];
      };
    })(this));
  }

  UniquePacket.prototype.unique = function(packet) {
    if (this.seen.indexOf(packet) !== -1) {
      return false;
    }
    this.seen.push(packet);
    return true;
  };

  return UniquePacket;

})(noflo.Component);

exports.getComponent = function() {
  return new UniquePacket;
};

});
require.register("noflo-noflo-packets/components/GroupByPacket.js", function(exports, require, module){
var GroupByPacket, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GroupByPacket = (function(_super) {
  __extends(GroupByPacket, _super);

  function GroupByPacket() {
    this.packets = 0;
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        _this.outPorts.out.beginGroup(group);
        return _this.packets = 0;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        _this.outPorts.out.beginGroup(_this.packets);
        _this.outPorts.out.send(data);
        _this.outPorts.out.endGroup();
        return _this.packets++;
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.packets = 0;
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return GroupByPacket;

})(noflo.Component);

exports.getComponent = function() {
  return new GroupByPacket;
};

});
require.register("noflo-noflo-packets/components/LastPacket.js", function(exports, require, module){
var LastPacket, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

LastPacket = (function(_super) {
  __extends(LastPacket, _super);

  function LastPacket() {
    this.packets = null;
    this.inPorts = {
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.packets = [];
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.packets.push(data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.packets.length === 0) {
          return;
        }
        _this.outPorts.out.send(_this.packets.pop());
        _this.outPorts.out.disconnect();
        return _this.packets = null;
      };
    })(this));
  }

  return LastPacket;

})(noflo.Component);

exports.getComponent = function() {
  return new LastPacket;
};

});
require.register("noflo-noflo-packets/components/Counter.js", function(exports, require, module){
var Counter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Counter = (function(_super) {
  __extends(Counter, _super);

  Counter.prototype.description = 'The count component receives input on a single input port, and sends the number of data packets received to the output port when the input disconnects';

  Counter.prototype.icon = 'sort-numeric-asc';

  function Counter() {
    this.count = null;
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      count: new noflo.Port,
      out: new noflo.Port
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.count === null) {
          _this.count = 0;
        }
        _this.count++;
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.count.send(_this.count);
        _this.outPorts.count.disconnect();
        if (_this.outPorts.out.isAttached()) {
          _this.outPorts.out.disconnect();
        }
        return _this.count = null;
      };
    })(this));
  }

  return Counter;

})(noflo.Component);

exports.getComponent = function() {
  return new Counter;
};

});
require.register("noflo-noflo-physics/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-physics.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-physics/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-physics","description":"Physics components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-physics","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Spring.coffee","index.js"],"json":["component.json"],"noflo":{"components":{"Spring":"components/Spring.coffee"}}}');
});
require.register("noflo-noflo-physics/components/Spring.js", function(exports, require, module){
var Spring, noflo, requestAnimFrame,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof process === 'object' && process.title === 'node') {
  noflo = require("noflo");
  requestAnimFrame = process.nextTick;
} else {
  noflo = require('noflo');
  requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
    return setTimeout(callback, 1);
  };
}

Spring = (function(_super) {
  __extends(Spring, _super);

  Spring.prototype.description = 'Animates a directional spring';

  function Spring() {
    this.step = __bind(this.step, this);
    this.massPosition = 0;
    this.anchorPosition = 0;
    this.stiffness = 120;
    this.mass = 10;
    this.friction = 3;
    this.speed = 0;
    this.inPorts = {
      anchor: new noflo.Port('number'),
      "in": new noflo.Port('number'),
      stiffness: new noflo.Port('int'),
      mass: new noflo.Port('int'),
      friction: new noflo.Port('int')
    };
    this.outPorts = {
      out: new noflo.Port('number')
    };
    this.inPorts.anchor.on('data', (function(_this) {
      return function(anchorPosition) {
        _this.anchorPosition = anchorPosition;
      };
    })(this));
    this.inPorts.stiffness.on('data', (function(_this) {
      return function(stiffness) {
        _this.stiffness = stiffness;
      };
    })(this));
    this.inPorts.mass.on('data', (function(_this) {
      return function(mass) {
        _this.mass = mass;
      };
    })(this));
    this.inPorts.friction.on('data', (function(_this) {
      return function(friction) {
        _this.friction = friction;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(massPosition) {
        _this.massPosition = massPosition;
        return _this.step();
      };
    })(this));
  }

  Spring.prototype.step = function() {
    var acceleration, dampingForce, distance, previousPosition, springForce, totalForce;
    distance = this.massPosition - this.anchorPosition;
    dampingForce = -this.friction * this.speed;
    springForce = -this.stiffness * distance;
    totalForce = springForce + dampingForce;
    acceleration = totalForce / this.mass;
    this.speed += acceleration;
    previousPosition = this.massPosition;
    this.massPosition += this.speed / 100;
    if (Math.round(this.massPosition) !== Math.round(previousPosition)) {
      this.outPorts.out.send(Math.round(this.massPosition));
    }
    if (Math.round(this.massPosition) === this.anchorPosition && Math.abs(this.speed) < 0.2) {
      return this.outPorts.out.disconnect();
    } else {
      if (this.massPosition === 0) {
        return;
      }
      return requestAnimFrame(this.step);
    }
  };

  return Spring;

})(noflo.Component);

exports.getComponent = function() {
  return new Spring;
};

});
require.register("noflo-noflo-routers/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of routers.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-routers/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-routers","description":"Routing Packets in NoFlo","keywords":["noflo","routing"],"author":"Kenneth Kan <kenhkan@gmail.com>","version":"0.1.0","dependencies":{"noflo/noflo":"*","component/underscore":"*"},"scripts":["components/ControlledSequence.coffee","components/KickRouter.coffee","components/PacketRouter.coffee","components/RegexpRouter.coffee","components/SplitInSequence.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"code-fork","components":{"ControlledSequence":"components/ControlledSequence.coffee","KickRouter":"components/KickRouter.coffee","PacketRouter":"components/PacketRouter.coffee","RegexpRouter":"components/RegexpRouter.coffee","SplitInSequence":"components/SplitInSequence.coffee"}},"repo":"https://raw.github.com/noflo/noflo-routers"}');
});
require.register("noflo-noflo-routers/components/ControlledSequence.js", function(exports, require, module){
var ControlledSequence, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ControlledSequence = (function(_super) {
  __extends(ControlledSequence, _super);

  function ControlledSequence() {
    this.current = 0;
    this.inPorts = {
      "in": new noflo.Port('all'),
      next: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('all')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group, _this.current);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data, _this.current);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup(_this.current);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect(_this.current);
      };
    })(this));
    this.inPorts.next.on('data', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect(_this.current);
        if (_this.current < _this.outPorts.out.sockets.length - 1) {
          _this.current++;
          return;
        }
        return _this.current = 0;
      };
    })(this));
  }

  return ControlledSequence;

})(noflo.Component);

exports.getComponent = function() {
  return new ControlledSequence;
};

});
require.register("noflo-noflo-routers/components/KickRouter.js", function(exports, require, module){
var KickRouter, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

KickRouter = (function(_super) {
  __extends(KickRouter, _super);

  KickRouter.prototype.description = "Holds an IP and send it to a specified port or previous/next";

  function KickRouter() {
    this.sendToIndex = __bind(this.sendToIndex, this);
    this.data = null;
    this.current = 0;
    this.inPorts = {
      "in": new noflo.Port('all'),
      index: new noflo.Port('int'),
      prev: new noflo.Port('bang'),
      next: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('all')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.data = data;
      };
    })(this));
    this.inPorts.index.on('data', (function(_this) {
      return function(index) {
        return _this.sendToIndex(_this.data, index);
      };
    })(this));
    this.inPorts.prev.on('data', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect(_this.current);
        if (_this.current > 0) {
          _this.current--;
        } else {
          _this.current = _this.outPorts.out.sockets.length - 1;
        }
        return _this.sendToIndex(_this.data, _this.current);
      };
    })(this));
    this.inPorts.next.on('data', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect(_this.current);
        if (_this.current < _this.outPorts.out.sockets.length - 1) {
          _this.current++;
        } else {
          _this.current = 0;
        }
        return _this.sendToIndex(_this.data, _this.current);
      };
    })(this));
  }

  KickRouter.prototype.sendToIndex = function(data, index) {
    if (this.outPorts.out.isAttached(index)) {
      this.current = index;
      return this.outPorts.out.send(data, index);
    }
  };

  return KickRouter;

})(noflo.Component);

exports.getComponent = function() {
  return new KickRouter;
};

});
require.register("noflo-noflo-routers/components/PacketRouter.js", function(exports, require, module){
var PacketRouter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

PacketRouter = (function(_super) {
  __extends(PacketRouter, _super);

  PacketRouter.prototype.description = "Routes IPs based on position in an incoming IP stream";

  function PacketRouter() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.ArrayPort,
      missed: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.count = 0;
        return _this.outPortCount = _this.outPorts.out.sockets.length;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (_this.count < _this.outPortCount) {
          _this.outPorts.out.send(data, _this.count++);
          return _this.outPorts.out.disconnect();
        } else if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var i, _i, _ref, _ref1;
        if (_this.count < _this.outPortCount) {
          for (i = _i = _ref = _this.count, _ref1 = _this.outPortCount; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
            _this.outPorts.out.send(null, i);
            _this.outPorts.out.disconnect();
          }
        }
        if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.disconnect();
        }
      };
    })(this));
  }

  return PacketRouter;

})(noflo.Component);

exports.getComponent = function() {
  return new PacketRouter;
};

});
require.register("noflo-noflo-routers/components/RegexpRouter.js", function(exports, require, module){
var RegexpRouter, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

RegexpRouter = (function(_super) {
  __extends(RegexpRouter, _super);

  RegexpRouter.prototype.description = "Route IPs based on RegExp (top-level only). The position of the RegExp determines which port to forward to.";

  function RegexpRouter() {
    this.routes = [];
    this.inPorts = {
      "in": new noflo.Port,
      route: new noflo.ArrayPort,
      reset: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.ArrayPort,
      missed: new noflo.Port,
      route: new noflo.Port
    };
    this.inPorts.reset.on("disconnect", (function(_this) {
      return function() {
        return _this.routes = [];
      };
    })(this));
    this.inPorts.route.on("data", (function(_this) {
      return function(regexp) {
        if (_.isString(regexp)) {
          return _this.routes.push(new RegExp(regexp));
        } else {
          throw new Error({
            message: "Route must be a string",
            source: regexp
          });
        }
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.matchedRouteIndex = null;
        return _this.level = 0;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        var i, index, route, _i, _len, _ref;
        index = _this.matchedRouteIndex;
        if (_this.level === 0) {
          _ref = _this.routes;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            route = _ref[i];
            if (group.match(route) != null) {
              _this.matchedRouteIndex = i;
              if (_this.outPorts.route.isAttached()) {
                _this.outPorts.route.send(group);
                _this.outPorts.route.disconnect();
              }
              break;
            }
          }
        } else if ((index != null) && _this.outPorts.out.isAttached(index)) {
          _this.outPorts.out.beginGroup(group, index);
        } else if (_this.outPorts.missed.isAttached()) {
          _this.outPorts.missed.beginGroup(group);
        }
        return _this.level++;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if ((_this.matchedRouteIndex != null) && _this.outPorts.out.isAttached(_this.matchedRouteIndex)) {
          return _this.outPorts.out.send(data, _this.matchedRouteIndex);
        } else if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        _this.level--;
        if (_this.level === 0 && (_this.matchedRouteIndex != null)) {
          _this.matchedRouteIndex = null;
        }
        if ((_this.matchedRouteIndex != null) && _this.outPorts.out.isAttached(_this.matchedRouteIndex)) {
          return _this.outPorts.out.endGroup(_this.matchedRouteIndex);
        } else if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.endGroup();
        }
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.disconnect();
        }
      };
    })(this));
  }

  return RegexpRouter;

})(noflo.Component);

exports.getComponent = function() {
  return new RegexpRouter;
};

});
require.register("noflo-noflo-routers/components/SplitInSequence.js", function(exports, require, module){
var SplitInSequence, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SplitInSequence = (function(_super) {
  __extends(SplitInSequence, _super);

  function SplitInSequence() {
    this.lastSent = null;
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.ArrayPort
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.sendToPort(_this.portId(), data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SplitInSequence.prototype.portId = function() {
    var next;
    if (this.lastSent === null) {
      return 0;
    }
    next = this.lastSent + 1;
    if (next > this.outPorts.out.sockets.length - 1) {
      return 0;
    }
    return next;
  };

  SplitInSequence.prototype.sendToPort = function(portId, data) {
    this.outPorts.out.send(data, portId);
    return this.lastSent = portId;
  };

  return SplitInSequence;

})(noflo.Component);

exports.getComponent = function() {
  return new SplitInSequence;
};

});
require.register("noflo-noflo-strings/index.js", function(exports, require, module){
/*
 * This file can be used for general library features that are exposed as CommonJS modules
 * that the components then utilize
 */

});
require.register("noflo-noflo-strings/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-strings","description":"String Utilities for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-strings","version":"0.0.1","keywords":[],"dependencies":{"noflo/noflo":"*","component/underscore":"*"},"scripts":["components/CompileString.coffee","components/Filter.coffee","components/SendString.coffee","components/SplitStr.coffee","components/StringTemplate.coffee","components/Replace.coffee","components/Jsonify.coffee","components/ParseJson.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"font","components":{"CompileString":"components/CompileString.coffee","Filter":"components/Filter.coffee","SendString":"components/SendString.coffee","SplitStr":"components/SplitStr.coffee","StringTemplate":"components/StringTemplate.coffee","Replace":"components/Replace.coffee","Jsonify":"components/Jsonify.coffee","ParseJson":"components/ParseJson.coffee"}}}');
});
require.register("noflo-noflo-strings/components/CompileString.js", function(exports, require, module){
var CompileString, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CompileString = (function(_super) {
  __extends(CompileString, _super);

  function CompileString() {
    this.delimiter = "\n";
    this.data = [];
    this.onGroupEnd = true;
    this.inPorts = {
      delimiter: new noflo.Port,
      "in": new noflo.ArrayPort,
      ongroup: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.delimiter.on('data', (function(_this) {
      return function(data) {
        return _this.delimiter = data;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.data.push(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        if (_this.data.length && _this.onGroupEnd) {
          _this.outPorts.out.send(_this.data.join(_this.delimiter));
        }
        _this.outPorts.out.endGroup();
        return _this.data = [];
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.data.length) {
          _this.outPorts.out.send(_this.data.join(_this.delimiter));
        }
        _this.data = [];
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.ongroup.on("data", (function(_this) {
      return function(data) {
        if (typeof data === 'string') {
          if (data.toLowerCase() === 'false') {
            _this.onGroupEnd = false;
            return;
          }
          _this.onGroupEnd = true;
          return;
        }
        return _this.onGroupEnd = data;
      };
    })(this));
  }

  return CompileString;

})(noflo.Component);

exports.getComponent = function() {
  return new CompileString;
};

});
require.register("noflo-noflo-strings/components/Filter.js", function(exports, require, module){
var Filter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

Filter = (function(_super) {
  __extends(Filter, _super);

  Filter.prototype.description = "filters an IP which is a string using a regex";

  function Filter() {
    this.regex = null;
    this.inPorts = {
      "in": new noflo.Port('string'),
      pattern: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('string'),
      missed: new noflo.Port('string')
    };
    this.inPorts.pattern.on("data", (function(_this) {
      return function(data) {
        return _this.regex = new RegExp(data);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (typeof data !== 'string') {
          data = data.toString();
        }
        if ((_this.regex != null) && ((data != null ? typeof data.match === "function" ? data.match(_this.regex) : void 0 : void 0) != null)) {
          _this.outPorts.out.send(data);
          return;
        }
        if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.disconnect();
        }
      };
    })(this));
  }

  return Filter;

})(noflo.Component);

exports.getComponent = function() {
  return new Filter;
};

});
require.register("noflo-noflo-strings/components/SendString.js", function(exports, require, module){
var SendString, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SendString = (function(_super) {
  __extends(SendString, _super);

  function SendString() {
    this.data = {
      string: null,
      group: []
    };
    this.groups = [];
    this.inPorts = {
      string: new noflo.Port('string'),
      "in": new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.string.on('data', (function(_this) {
      return function(data) {
        return _this.data.string = data;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        _this.data.group = _this.groups.slice(0);
        return _this.sendString(_this.data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SendString.prototype.sendString = function(data) {
    var group, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = data.group;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      this.outPorts.out.beginGroup(group);
    }
    this.outPorts.out.send(data.string);
    _ref1 = data.group;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      group = _ref1[_j];
      _results.push(this.outPorts.out.endGroup());
    }
    return _results;
  };

  return SendString;

})(noflo.Component);

exports.getComponent = function() {
  return new SendString;
};

});
require.register("noflo-noflo-strings/components/SplitStr.js", function(exports, require, module){
var SplitStr, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SplitStr = (function(_super) {
  __extends(SplitStr, _super);

  SplitStr.prototype.description = ' The SplitStr component receives a string in the in port, splits it by string specified in the delimiter port, and send each part as a separate packet to the out port';

  function SplitStr() {
    this.delimiterString = "\n";
    this.strings = [];
    this.groups = [];
    this.inPorts = {
      "in": new noflo.Port(),
      delimiter: new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.delimiter.on('data', (function(_this) {
      return function(data) {
        var first, last;
        first = data.substr(0, 1);
        last = data.substr(data.length - 1, 1);
        if (first === '/' && last === '/' && data.length > 1) {
          data = new RegExp(data.substr(1, data.length - 2));
        }
        return _this.delimiterString = data;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.strings.push(data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function(data) {
        var group, _i, _j, _len, _len1, _ref, _ref1;
        if (_this.strings.length === 0) {
          return _this.outPorts.out.disconnect();
        }
        _ref = _this.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.beginGroup(group);
        }
        _this.strings.join(_this.delimiterString).split(_this.delimiterString).forEach(function(line) {
          return _this.outPorts.out.send(line);
        });
        _ref1 = _this.groups;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          _this.outPorts.out.endGroup();
        }
        _this.outPorts.out.disconnect();
        _this.strings = [];
        return _this.groups = [];
      };
    })(this));
  }

  return SplitStr;

})(noflo.Component);

exports.getComponent = function() {
  return new SplitStr();
};

});
require.register("noflo-noflo-strings/components/StringTemplate.js", function(exports, require, module){
var StringTemplate, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore');

StringTemplate = (function(_super) {
  __extends(StringTemplate, _super);

  function StringTemplate() {
    this.template = null;
    this.inPorts = {
      template: new noflo.Port('string'),
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.template.on('data', (function(_this) {
      return function(data) {
        return _this.template = _.template(data);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(_this.template(data));
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return StringTemplate;

})(noflo.Component);

exports.getComponent = function() {
  return new StringTemplate;
};

});
require.register("noflo-noflo-strings/components/Replace.js", function(exports, require, module){
var Replace, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Replace = (function(_super) {
  __extends(Replace, _super);

  Replace.prototype.description = 'Given a fixed pattern and its replacement, replace all occurrences in the incoming template.';

  function Replace() {
    this.pattern = null;
    this.replacement = '';
    this.inPorts = {
      "in": new noflo.Port('string'),
      pattern: new noflo.Port('string'),
      replacement: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.pattern.on('data', (function(_this) {
      return function(data) {
        return _this.pattern = new RegExp(data, 'g');
      };
    })(this));
    this.inPorts.replacement.on('data', (function(_this) {
      return function(data) {
        return _this.replacement = data.replace('\\\\n', "\n");
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var string;
        string = data;
        if (_this.pattern != null) {
          string = ("" + data).replace(_this.pattern, _this.replacement);
        }
        return _this.outPorts.out.send(string);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Replace;

})(noflo.Component);

exports.getComponent = function() {
  return new Replace;
};

});
require.register("noflo-noflo-strings/components/Jsonify.js", function(exports, require, module){
var Jsonify, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore');

Jsonify = (function(_super) {
  __extends(Jsonify, _super);

  Jsonify.prototype.description = "JSONify all incoming, unless a raw flag is set to exclude data packets that are pure strings";

  function Jsonify() {
    this.raw = false;
    this.inPorts = {
      "in": new noflo.Port('object'),
      raw: new noflo.Port('boolean')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.raw.on('data', (function(_this) {
      return function(raw) {
        return _this.raw = String(raw) === 'true';
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.raw && _.isString(data)) {
          _this.outPorts.out.send(data);
          return;
        }
        return _this.outPorts.out.send(JSON.stringify(data));
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Jsonify;

})(noflo.Component);

exports.getComponent = function() {
  return new Jsonify;
};

});
require.register("noflo-noflo-strings/components/ParseJson.js", function(exports, require, module){
var ParseJson, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

ParseJson = (function(_super) {
  __extends(ParseJson, _super);

  function ParseJson() {
    this["try"] = false;
    this.inPorts = {
      "in": new noflo.Port(),
      "try": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts["try"].on("data", (function(_this) {
      return function(data) {
        if (data === "true") {
          return _this["try"] = true;
        }
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var e;
        try {
          data = JSON.parse(data);
        } catch (_error) {
          e = _error;
          if (!_this["try"]) {
            data = JSON.parse(data);
          }
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return ParseJson;

})(noflo.Component);

exports.getComponent = function() {
  return new ParseJson;
};

});
require.register("noflo-noflo-websocket/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-websocket.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-websocket/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-websocket","description":"WebSocket components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-websocket","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Connect.coffee","components/SendMessage.coffee","components/ListenMessages.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"comments","components":{"Connect":"components/Connect.coffee","SendMessage":"components/SendMessage.coffee","ListenMessages":"components/ListenMessages.coffee"}}}');
});
require.register("noflo-noflo-websocket/components/Connect.js", function(exports, require, module){
var Connect, WsClient, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

if (noflo.isBrowser()) {
  WsClient = WebSocket;
} else {
  WsClient = require('websocket').client;
}

Connect = (function(_super) {
  __extends(Connect, _super);

  function Connect() {
    this.handleError = __bind(this.handleError, this);
    this.protocol = 'noflo';
    this.inPorts = {
      url: new noflo.Port('string'),
      protocol: new noflo.Port('string')
    };
    this.outPorts = {
      connection: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.url.on('data', (function(_this) {
      return function(data) {
        return _this.connect(data);
      };
    })(this));
    this.inPorts.protocol.on('data', (function(_this) {
      return function(protocol) {
        _this.protocol = protocol;
      };
    })(this));
  }

  Connect.prototype.connect = function(url) {
    var client;
    if (noflo.isBrowser()) {
      client = new WsClient(url, this.protocol);
      client.onerror = this.handleError;
      client.onopen = (function(_this) {
        return function() {
          return _this.outPorts.connection.send(client);
        };
      })(this);
      return;
    }
    client = new WsClient;
    client.on('connect', (function(_this) {
      return function(connection) {
        _this.outPorts.connection.send(connection);
        return connection.on('error', _this.handleError);
      };
    })(this));
    client.on('connectFailed', this.handleError);
    return client.connect(url, this.protocol);
  };

  Connect.prototype.handleError = function(err) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(err);
      this.outPorts.error.disconnect();
      return;
    }
    throw err;
  };

  return Connect;

})(noflo.Component);

exports.getComponent = function() {
  return new Connect;
};

});
require.register("noflo-noflo-websocket/components/SendMessage.js", function(exports, require, module){
var SendMessage, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SendMessage = (function(_super) {
  __extends(SendMessage, _super);

  function SendMessage() {
    this.connection = null;
    this.buffer = [];
    this.inPorts = {
      connection: new noflo.Port('object'),
      string: new noflo.Port('string')
    };
    this.outPorts = {};
    this.inPorts.connection.on('data', (function(_this) {
      return function(connection) {
        _this.connection = connection;
        if (_this.buffer.length) {
          return _this.clearBuffer();
        }
      };
    })(this));
    this.inPorts.string.on('data', (function(_this) {
      return function(data) {
        if (_this.connection) {
          return _this.send(data);
        }
        return _this.buffer.push(data);
      };
    })(this));
  }

  SendMessage.prototype.send = function(message) {
    if (noflo.isBrowser()) {
      this.connection.send(message);
      return;
    }
    return this.connection.sendUTF(message);
  };

  SendMessage.prototype.clearBuffer = function() {
    var message, _i, _len, _ref;
    _ref = this.buffer;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      message = _ref[_i];
      this.send(message);
    }
    return this.buffer = [];
  };

  return SendMessage;

})(noflo.Component);

exports.getComponent = function() {
  return new SendMessage;
};

});
require.register("noflo-noflo-websocket/components/ListenMessages.js", function(exports, require, module){
var ListenMessages, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenMessages = (function(_super) {
  __extends(ListenMessages, _super);

  function ListenMessages() {
    this.inPorts = {
      connection: new noflo.Port('object')
    };
    this.outPorts = {
      string: new noflo.Port('string'),
      binary: new noflo.Port('binary')
    };
    this.inPorts.connection.on('data', (function(_this) {
      return function(data) {
        return _this.subscribe(data);
      };
    })(this));
  }

  ListenMessages.prototype.subscribe = function(connection) {
    if (noflo.isBrowser()) {
      if (!this.outPorts.string.isAttached()) {
        return;
      }
      connection.addEventListener('message', (function(_this) {
        return function(message) {
          return _this.outPorts.string.send(message.data);
        };
      })(this), false);
      connection.addEventListener('close', (function(_this) {
        return function(message) {
          return _this.outPorts.string.disconnect();
        };
      })(this), false);
      return;
    }
    connection.on('message', (function(_this) {
      return function(message) {
        if (message.type === 'utf8' && _this.outPorts.string.isAttached()) {
          _this.outPorts.string.send(message.utf8Data);
          return;
        }
        if (message.type === 'binary' && _this.outPorts.binary.isAttached()) {
          _this.outPorts.binary.send(message.binaryData);
        }
      };
    })(this));
    return connection.on('close', (function(_this) {
      return function() {
        if (_this.outPorts.string.isAttached()) {
          _this.outPorts.string.disconnect();
        }
        if (_this.outPorts.binary.isAttached()) {
          return _this.outPorts.binary.disconnect();
        }
      };
    })(this));
  };

  return ListenMessages;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenMessages;
};

});
require.register("noflo-noflo-indexeddb/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-indexeddb.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-indexeddb/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-indexeddb","description":"IndexedDB components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-indexeddb","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Open.coffee","components/Close.coffee","components/DeleteDatabase.coffee","components/CreateStore.coffee","components/CreateIndex.coffee","components/DeleteStore.coffee","components/UpgradeRouter.coffee","components/BeginTransaction.coffee","components/AbortTransaction.coffee","components/GetStore.coffee","components/GetIndex.coffee","components/Query.coffee","components/QueryOnly.coffee","components/QueryFrom.coffee","components/QueryTo.coffee","components/Put.coffee","components/Get.coffee","components/Delete.coffee","index.js"],"json":["component.json"],"files":["vendor/IndexedDBShim.min.js"],"noflo":{"icon":"bitbucket","components":{"Open":"components/Open.coffee","Close":"components/Close.coffee","DeleteDatabase":"components/DeleteDatabase.coffee","CreateStore":"components/CreateStore.coffee","CreateIndex":"components/CreateIndex.coffee","DeleteStore":"components/DeleteStore.coffee","UpgradeRouter":"components/UpgradeRouter.coffee","BeginTransaction":"components/BeginTransaction.coffee","AbortTransaction":"components/AbortTransaction.coffee","GetStore":"components/GetStore.coffee","GetIndex":"components/GetIndex.coffee","Query":"components/Query.coffee","QueryOnly":"components/QueryOnly.coffee","QueryFrom":"components/QueryFrom.coffee","QueryTo":"components/QueryTo.coffee","Put":"components/Put.coffee","Get":"components/Get.coffee","Delete":"components/Delete.coffee"}}}');
});
require.register("noflo-noflo-indexeddb/components/Open.js", function(exports, require, module){
var Open, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Open = (function(_super) {
  __extends(Open, _super);

  function Open() {
    this.name = null;
    this.version = null;
    this.inPorts = {
      name: new noflo.Port('name'),
      version: new noflo.Port('number')
    };
    this.outPorts = {
      upgrade: new noflo.Port('object'),
      db: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.open();
      };
    })(this));
    this.inPorts.version.on('data', (function(_this) {
      return function(version) {
        _this.version = version;
        return _this.open();
      };
    })(this));
  }

  Open.prototype.open = function() {
    var req, version;
    if (!(this.name && this.version)) {
      return;
    }
    req = indexedDB.open(this.name, parseInt(this.version));
    this.name = null;
    version = this.version;
    this.version = null;
    req.onupgradeneeded = (function(_this) {
      return function(e) {
        _this.outPorts.upgrade.beginGroup(_this.name);
        _this.outPorts.upgrade.send({
          oldVersion: e.oldVersion,
          newVersion: version,
          db: e.target.result
        });
        _this.outPorts.upgrade.endGroup();
        return _this.outPorts.upgrade.disconnect();
      };
    })(this);
    req.onsuccess = (function(_this) {
      return function(e) {
        _this.outPorts.db.beginGroup(_this.name);
        _this.outPorts.db.send(e.target.result);
        _this.outPorts.db.endGroup();
        return _this.outPorts.db.disconnect();
      };
    })(this);
    return req.onerror = this.error.bind(this);
  };

  return Open;

})(noflo.Component);

exports.getComponent = function() {
  return new Open;
};

});
require.register("noflo-noflo-indexeddb/components/Close.js", function(exports, require, module){
var Close, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Close = (function(_super) {
  __extends(Close, _super);

  function Close() {
    this.inPorts = {
      db: new noflo.Port('object')
    };
    this.inPorts.db.on('data', function(db) {
      return db.close();
    });
  }

  return Close;

})(noflo.Component);

exports.getComponent = function() {
  return new Close;
};

});
require.register("noflo-noflo-indexeddb/components/DeleteDatabase.js", function(exports, require, module){
var DeleteDatabase, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DeleteDatabase = (function(_super) {
  __extends(DeleteDatabase, _super);

  function DeleteDatabase() {
    this.inPorts = {
      name: new noflo.Port('string')
    };
    this.outPorts = {
      deleted: new noflo.Port('bang'),
      error: new noflo.Port('object')
    };
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        return _this.deleteDb(name);
      };
    })(this));
  }

  DeleteDatabase.prototype.deleteDb = function(name) {
    var req;
    req = indexedDB.deleteDatabase(name);
    req.onsuccess = (function(_this) {
      return function() {
        _this.outPorts.deleted.send(true);
        return _this.outPorts.deleted.disconnect();
      };
    })(this);
    return req.onerror = this.error;
  };

  return DeleteDatabase;

})(noflo.Component);

exports.getComponent = function() {
  return new DeleteDatabase;
};

});
require.register("noflo-noflo-indexeddb/components/CreateStore.js", function(exports, require, module){
var CreateStore, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CreateStore = (function(_super) {
  __extends(CreateStore, _super);

  function CreateStore() {
    this.name = null;
    this.db = null;
    this.keyPath = '';
    this.autoIncrement = false;
    this.inPorts = {
      name: new noflo.Port('name'),
      db: new noflo.Port('object'),
      keypath: new noflo.Port('name'),
      autoincrement: new noflo.Port('boolean')
    };
    this.outPorts = {
      store: new noflo.Port('object'),
      db: new noflo.Port('object'),
      error: new noflo.Port('error')
    };
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.create();
      };
    })(this));
    this.inPorts.db.on('data', (function(_this) {
      return function(db) {
        _this.db = db;
        return _this.create();
      };
    })(this));
    this.inPorts.keypath.on('data', (function(_this) {
      return function(keyPath) {
        _this.keyPath = keyPath;
      };
    })(this));
    this.inPorts.autoincrement.on('data', (function(_this) {
      return function(autoIncrement) {
        _this.autoIncrement = autoIncrement;
      };
    })(this));
  }

  CreateStore.prototype.create = function() {
    var store;
    if (!(this.name && this.db)) {
      return;
    }
    this.db.transaction.onerror = this.error;
    store = this.db.createObjectStore(this.name, {
      keyPath: this.keyPath,
      autoIncrement: this.autoIncrement
    });
    if (store && this.outPorts.store.isAttached()) {
      this.outPorts.store.beginGroup(this.name);
      this.outPorts.store.send(store);
      this.outPorts.store.endGroup();
      this.outPorts.store.disconnect();
    }
    this.db.transaction.onerror = null;
    if (this.outPorts.db.isAttached()) {
      this.outPorts.db.send(this.db);
      this.outPorts.db.disconnect();
    }
    this.db = null;
    return this.name = null;
  };

  return CreateStore;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateStore;
};

});
require.register("noflo-noflo-indexeddb/components/CreateIndex.js", function(exports, require, module){
var CreateIndex, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CreateIndex = (function(_super) {
  __extends(CreateIndex, _super);

  function CreateIndex() {
    this.store = null;
    this.name = null;
    this.keyPath = null;
    this.unique = false;
    this.multiEntry = false;
    this.inPorts = {
      store: new noflo.Port('object'),
      name: new noflo.Port('string'),
      keypath: new noflo.Port('string'),
      unique: new noflo.Port('boolean'),
      multientry: new noflo.Port('boolean')
    };
    this.outPorts = {
      index: new noflo.Port('object'),
      store: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.create();
      };
    })(this));
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.create();
      };
    })(this));
    this.inPorts.keypath.on('data', (function(_this) {
      return function(keyPath) {
        _this.keyPath = keyPath;
        return _this.create();
      };
    })(this));
    this.inPorts.unique.on('data', (function(_this) {
      return function(unique) {
        _this.unique = unique;
      };
    })(this));
    this.inPorts.multientry.on('data', (function(_this) {
      return function(multiEntry) {
        _this.multiEntry = multiEntry;
      };
    })(this));
  }

  CreateIndex.prototype.create = function() {
    var index;
    if (!(this.store && this.name && this.keyPath)) {
      return;
    }
    this.store.onerror = this.error.bind(this);
    index = this.store.createIndex(this.name, this.keyPath, {
      unique: this.unique,
      multiEntry: this.multiEntry
    });
    this.store.onerror = null;
    this.name = null;
    this.keyPath = null;
    if (this.outPorts.index.isAttached()) {
      this.outPorts.index.beginGroup(index.name);
      this.outPorts.index.send(index);
      this.outPorts.index.endGroup();
      this.outPorts.index.disconnect();
    }
    if (this.outPorts.store.isAttached()) {
      this.outPorts.store.send(this.store);
      this.outPorts.store.disconnect();
    }
    return this.store = null;
  };

  return CreateIndex;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateIndex;
};

});
require.register("noflo-noflo-indexeddb/components/DeleteStore.js", function(exports, require, module){
var DeleteStore, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DeleteStore = (function(_super) {
  __extends(DeleteStore, _super);

  function DeleteStore() {
    this.name = null;
    this.db = null;
    this.inPorts = {
      name: new noflo.Port('name'),
      db: new noflo.Port('object')
    };
    this.outPorts = {
      db: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.deleteStore();
      };
    })(this));
    this.inPorts.db.on('data', (function(_this) {
      return function(db) {
        _this.db = db;
        return _this.deleteStore();
      };
    })(this));
  }

  DeleteStore.prototype.deleteStore = function() {
    if (!(this.name && this.db)) {
      return;
    }
    this.db.transaction.onerror = this.error;
    this.db.deleteObjectStore(this.name);
    this.db.transaction.onerror = null;
    if (this.outPorts.db.isAttached()) {
      this.outPorts.db.send(this.db);
      this.outPorts.db.disconnect();
    }
    this.db = null;
    return this.name = null;
  };

  return DeleteStore;

})(noflo.Component);

exports.getComponent = function() {
  return new DeleteStore;
};

});
require.register("noflo-noflo-indexeddb/components/UpgradeRouter.js", function(exports, require, module){
var UpgradeRouter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

UpgradeRouter = (function(_super) {
  __extends(UpgradeRouter, _super);

  function UpgradeRouter() {
    this.groups = [];
    this.inPorts = {
      upgrade: new noflo.Port('object')
    };
    this.outPorts = {
      versions: new noflo.ArrayPort('object'),
      missed: new noflo.Port('object')
    };
    this.inPorts.upgrade.on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts.upgrade.on('data', (function(_this) {
      return function(upgrade) {
        return _this.route(upgrade);
      };
    })(this));
    this.inPorts.upgrade.on('endgroup', (function(_this) {
      return function() {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts.upgrade.on('disconnect', (function(_this) {
      return function() {
        return _this.groups = [];
      };
    })(this));
  }

  UpgradeRouter.prototype.route = function(upgrade) {
    var group, migration, upgraded, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    upgraded = false;
    migration = 0;
    while (migration < upgrade.newVersion) {
      if (migration < upgrade.oldVersion) {
        migration++;
        continue;
      }
      if (!this.outPorts.versions.isAttached(migration)) {
        migration++;
        continue;
      }
      _ref = this.groups;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        group = _ref[_i];
        this.outPorts.versions.beginGroup(group, migration);
      }
      this.outPorts.versions.send(upgrade.db, migration);
      _ref1 = this.groups;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        group = _ref1[_j];
        this.outPorts.versions.endGroup(migration);
      }
      this.outPorts.versions.disconnect(migration);
      upgraded = true;
      migration++;
    }
    if (upgraded) {
      return;
    }
    if (!this.outPorts.missed.isAttached()) {
      return;
    }
    _ref2 = this.groups;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      group = _ref2[_k];
      this.outPorts.missed.beginGroup(group);
    }
    this.outPorts.missed.send(upgrade.db);
    _ref3 = this.groups;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      group = _ref3[_l];
      this.outPorts.missed.endGroup();
    }
    return this.outPorts.missed.disconnect();
  };

  return UpgradeRouter;

})(noflo.Component);

exports.getComponent = function() {
  return new UpgradeRouter;
};

});
require.register("noflo-noflo-indexeddb/components/BeginTransaction.js", function(exports, require, module){
var BeginTransaction, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

BeginTransaction = (function(_super) {
  __extends(BeginTransaction, _super);

  function BeginTransaction() {
    this.stores = null;
    this.db = null;
    this.mode = 'readwrite';
    this.inPorts = {
      stores: new noflo.Port('string'),
      db: new noflo.Port('object'),
      mode: new noflo.Port('string')
    };
    this.outPorts = {
      transaction: new noflo.Port('object'),
      db: new noflo.Port('object'),
      error: new noflo.Port('error'),
      complete: new noflo.Port('bang')
    };
    this.inPorts.stores.on('data', (function(_this) {
      return function(data) {
        _this.stores = data.split(',');
        return _this.begin();
      };
    })(this));
    this.inPorts.db.on('data', (function(_this) {
      return function(db) {
        _this.db = db;
        return _this.begin();
      };
    })(this));
    this.inPorts.mode.on('data', (function(_this) {
      return function(mode) {
        _this.mode = mode;
      };
    })(this));
  }

  BeginTransaction.prototype.begin = function() {
    var transaction;
    if (!(this.db && this.stores)) {
      return;
    }
    transaction = this.db.transaction(this.stores, this.mode);
    transaction.oncomplete = (function(_this) {
      return function() {
        if (_this.outPorts.complete.isAttached()) {
          _this.outPorts.complete.send(true);
          _this.outPorts.complete.disconnect();
        }
        transaction.onerror = null;
        return transaction.oncomplete = null;
      };
    })(this);
    transaction.onerror = this.error.bind(this);
    this.outPorts.transaction.send(transaction);
    this.outPorts.transaction.disconnect();
    if (this.outPorts.db.isAttached()) {
      this.outPorts.db.send(this.db);
      this.outPorts.db.disconnect();
    }
    return this.stores = null;
  };

  return BeginTransaction;

})(noflo.Component);

exports.getComponent = function() {
  return new BeginTransaction;
};

});
require.register("noflo-noflo-indexeddb/components/AbortTransaction.js", function(exports, require, module){
var AbortTransaction, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

AbortTransaction = (function(_super) {
  __extends(AbortTransaction, _super);

  function AbortTransaction() {
    this.inPorts = {
      transaction: new noflo.Port('object')
    };
    this.outPorts = {
      error: new noflo.Port('object')
    };
    this.inPorts.transaction.on('data', (function(_this) {
      return function(transaction) {
        transaction.onerror = _this.error.bind(_this);
        return transaction.abort();
      };
    })(this));
  }

  return AbortTransaction;

})(noflo.Component);

exports.getComponent = function() {
  return new AbortTransaction;
};

});
require.register("noflo-noflo-indexeddb/components/GetStore.js", function(exports, require, module){
var GetStore, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetStore = (function(_super) {
  __extends(GetStore, _super);

  function GetStore() {
    this.transaction = null;
    this.name = null;
    this.inPorts = {
      name: new noflo.Port('string'),
      transaction: new noflo.Port('object')
    };
    this.outPorts = {
      store: new noflo.Port('object'),
      transaction: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.get();
      };
    })(this));
    this.inPorts.transaction.on('data', (function(_this) {
      return function(transaction) {
        _this.transaction = transaction;
        return _this.get();
      };
    })(this));
  }

  GetStore.prototype.get = function() {
    var store;
    if (!(this.name && this.transaction)) {
      return;
    }
    this.transaction.onerror = this.error;
    store = this.transaction.objectStore(this.name);
    this.transaction.onerror = null;
    this.outPorts.store.beginGroup(this.name);
    this.outPorts.store.send(store);
    this.outPorts.store.endGroup();
    this.outPorts.store.disconnect();
    if (this.outPorts.transaction.isAttached()) {
      this.outPorts.transaction.send(this.transaction);
      this.outPorts.transaction.disconnect();
    }
    this.transaction = null;
    return this.name = null;
  };

  return GetStore;

})(noflo.Component);

exports.getComponent = function() {
  return new GetStore;
};

});
require.register("noflo-noflo-indexeddb/components/GetIndex.js", function(exports, require, module){
var GetIndex, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetIndex = (function(_super) {
  __extends(GetIndex, _super);

  function GetIndex() {
    this.store = null;
    this.name = null;
    this.inPorts = {
      store: new noflo.Port('object'),
      name: new noflo.Port('string')
    };
    this.outPorts = {
      index: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.get();
      };
    })(this));
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.get();
      };
    })(this));
  }

  GetIndex.prototype.get = function() {
    var index;
    if (!(this.store && this.name)) {
      return;
    }
    this.store.onerror = this.error;
    index = this.store.index(this.name);
    this.store.onerror = null;
    this.outPorts.index.beginGroup(this.name);
    this.outPorts.index.send(index);
    this.outPorts.index.endGroup();
    this.outPorts.index.disconnect();
    this.store = null;
    return this.name = null;
  };

  return GetIndex;

})(noflo.Component);

exports.getComponent = function() {
  return new GetIndex;
};

});
require.register("noflo-noflo-indexeddb/components/Query.js", function(exports, require, module){
var Query, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Query = (function(_super) {
  __extends(Query, _super);

  function Query() {
    this.step = __bind(this.step, this);
    this.store = null;
    this.range = null;
    this.all = false;
    this.inPorts = {
      store: new noflo.Port('object'),
      range: new noflo.Port('object'),
      all: new noflo.Port('bang')
    };
    this.outPorts = {
      item: new noflo.Port('all'),
      range: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.query();
      };
    })(this));
    this.inPorts.range.on('data', (function(_this) {
      return function(range) {
        _this.range = range;
        return _this.query();
      };
    })(this));
    this.inPorts.all.on('data', (function(_this) {
      return function() {
        _this.all = true;
        return _this.query();
      };
    })(this));
  }

  Query.prototype.query = function() {
    var req;
    if (!this.store) {
      return;
    }
    if (this.all) {
      req = this.store.openCursor();
      this.store = null;
      this.all = false;
      req.onsuccess = this.step;
      req.onerror = this.error;
      return;
    }
    if (this.range) {
      req = this.store.openCursor(this.range);
      this.store = null;
      if (this.outPorts.range.isAttached()) {
        this.outPorts.range.send(this.range);
        this.outPorts.range.disconnect();
      }
      this.range = null;
      req.onsuccess = this.step;
      return req.onerror = this.error;
    }
  };

  Query.prototype.step = function(e) {
    var cursor;
    cursor = e.target.result;
    if (!cursor) {
      this.outPorts.item.disconnect();
      return;
    }
    this.outPorts.item.beginGroup(cursor.key);
    this.outPorts.item.send(cursor.value);
    this.outPorts.item.endGroup();
    return cursor["continue"]();
  };

  return Query;

})(noflo.Component);

exports.getComponent = function() {
  return new Query;
};

});
require.register("noflo-noflo-indexeddb/components/QueryOnly.js", function(exports, require, module){
var QueryOnly, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

QueryOnly = (function(_super) {
  __extends(QueryOnly, _super);

  function QueryOnly() {
    this.inPorts = {
      value: new noflo.Port('all')
    };
    this.outPorts = {
      range: new noflo.Port('object')
    };
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.outPorts.range.send(IDBKeyRange.only(value));
        return _this.outPorts.range.disconnect();
      };
    })(this));
  }

  return QueryOnly;

})(noflo.Component);

exports.getComponent = function() {
  return new QueryOnly;
};

});
require.register("noflo-noflo-indexeddb/components/QueryFrom.js", function(exports, require, module){
var QueryFrom, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

QueryFrom = (function(_super) {
  __extends(QueryFrom, _super);

  function QueryFrom() {
    this.including = false;
    this.inPorts = {
      value: new noflo.Port('all'),
      including: new noflo.Port('boolean')
    };
    this.outPorts = {
      range: new noflo.Port('object')
    };
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.outPorts.range.send(IDBKeyRange.lowerBound(value, _this.including));
        return _this.outPorts.range.disconnect();
      };
    })(this));
    this.inPorts.including.on('data', (function(_this) {
      return function(including) {
        _this.including = including;
      };
    })(this));
  }

  return QueryFrom;

})(noflo.Component);

exports.getComponent = function() {
  return new QueryFrom;
};

});
require.register("noflo-noflo-indexeddb/components/QueryTo.js", function(exports, require, module){
var QueryTo, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

QueryTo = (function(_super) {
  __extends(QueryTo, _super);

  function QueryTo() {
    this.including = false;
    this.inPorts = {
      value: new noflo.Port('all'),
      including: new noflo.Port('boolean')
    };
    this.outPorts = {
      range: new noflo.Port('object')
    };
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.outPorts.range.send(IDBKeyRange.upperBound(value, _this.including));
        return _this.outPorts.range.disconnect();
      };
    })(this));
    this.inPorts.including.on('data', (function(_this) {
      return function(including) {
        _this.including = including;
      };
    })(this));
  }

  return QueryTo;

})(noflo.Component);

exports.getComponent = function() {
  return new QueryTo;
};

});
require.register("noflo-noflo-indexeddb/components/Put.js", function(exports, require, module){
var Put, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Put = (function(_super) {
  __extends(Put, _super);

  function Put() {
    this.store = null;
    this.value = null;
    this.inPorts = {
      store: new noflo.Port('object'),
      value: new noflo.Port('all')
    };
    this.outPorts = {
      store: new noflo.Port('object'),
      key: new noflo.Port('all'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.put();
      };
    })(this));
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.value = value;
        return _this.put();
      };
    })(this));
  }

  Put.prototype.put = function() {
    var req;
    if (!(this.store && this.value)) {
      return;
    }
    req = this.store.put(this.value);
    this.value = null;
    if (this.outPorts.store.isAttached()) {
      this.outPorts.store.send(this.store);
      this.outPorts.store.disconnect();
    }
    this.store = null;
    req.onsuccess = (function(_this) {
      return function(e) {
        if (_this.outPorts.key.isAttached()) {
          _this.outPorts.key.send(e.target.result);
          return _this.outPorts.key.disconnect();
        }
      };
    })(this);
    return req.onerror = this.error.bind(this);
  };

  return Put;

})(noflo.Component);

exports.getComponent = function() {
  return new Put;
};

});
require.register("noflo-noflo-indexeddb/components/Get.js", function(exports, require, module){
var Get, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Get = (function(_super) {
  __extends(Get, _super);

  function Get() {
    this.store = null;
    this.key = null;
    this.inPorts = {
      store: new noflo.Port('object'),
      key: new noflo.Port('string')
    };
    this.outPorts = {
      store: new noflo.Port('object'),
      item: new noflo.Port('all'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.get();
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(key) {
        _this.key = key;
        return _this.get();
      };
    })(this));
  }

  Get.prototype.get = function() {
    var req;
    if (!(this.store && this.key)) {
      return;
    }
    req = this.store.get(this.key);
    if (this.outPorts.store.isAttached()) {
      this.outPorts.store.send(this.store);
      this.outPorts.store.disconnect();
    }
    this.store = null;
    req.onsuccess = (function(_this) {
      return function(e) {
        _this.outPorts.item.beginGroup(_this.key);
        _this.outPorts.item.send(e.target.result);
        _this.outPorts.item.endGroup();
        _this.outPorts.item.disconnect();
        return _this.key = null;
      };
    })(this);
    return req.onerror = this.error.bind(this);
  };

  return Get;

})(noflo.Component);

exports.getComponent = function() {
  return new Get;
};

});
require.register("noflo-noflo-indexeddb/components/Delete.js", function(exports, require, module){
var Delete, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Delete = (function(_super) {
  __extends(Delete, _super);

  function Delete() {
    this.store = null;
    this.key = null;
    this.inPorts = {
      store: new noflo.Port('object'),
      key: new noflo.Port('string')
    };
    this.outPorts = {
      store: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.get();
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(key) {
        _this.key = key;
        return _this.get();
      };
    })(this));
  }

  Delete.prototype.get = function() {
    var req;
    if (!(this.store && this.key)) {
      return;
    }
    req = this.store["delete"](this.key);
    req.onsuccess = (function(_this) {
      return function(e) {
        if (_this.outPorts.store.isAttached()) {
          _this.outPorts.store.send(_this.store);
          _this.outPorts.store.disconnect();
        }
        _this.key = null;
        return _this.store = null;
      };
    })(this);
    return req.onerror = this.error;
  };

  return Delete;

})(noflo.Component);

exports.getComponent = function() {
  return new Delete;
};

});
require.register("component-reduce/index.js", function(exports, require, module){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
});
require.register("visionmedia-superagent/lib/client.js", function(exports, require, module){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');

/**
 * Root reference for iframes.
 */

var root = 'undefined' == typeof window
  ? this
  : window;

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Determine XHR.
 */

function getXHR() {
  if (root.XMLHttpRequest
    && ('file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
}

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return obj === Object(obj);
}

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(obj[key]));
    }
  }
  return pairs.join('&');
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  this.text = this.xhr.responseText;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  return parse
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  var type = status / 100 | 0;

  // status / class
  this.status = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status || 1223 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var path = req.path;

  var msg = 'cannot ' + method + ' ' + path + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.path = path;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  Emitter.call(this);
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {};
  this._header = {};
  this.on('end', function(){
    var res = new Response(self);
    if ('HEAD' == method) res.text = null;
    self.callback(null, res);
  });
}

/**
 * Mixin `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.timeout = function(ms){
  this._timeout = ms;
  return this;
};

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.clearTimeout = function(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set header `field` to `val`, or multiple fields with one object.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Get case-insensitive header `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api private
 */

Request.prototype.getHeader = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass){
  var str = btoa(user + ':' + pass);
  this.set('Authorization', 'Basic ' + str);
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Send `data`, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // querystring
 *       request.get('/search')
 *         .end(callback)
 *
 *       // multiple data "writes"
 *       request.get('/search')
 *         .send({ search: 'query' })
 *         .send({ range: '1..5' })
 *         .send({ order: 'desc' })
 *         .end(callback)
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"})
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this.getHeader('Content-Type');

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this.getHeader('Content-Type');
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  if (2 == fn.length) return fn(err, res);
  if (err) return this.emit('error', err);
  fn(res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');
  err.crossDomain = true;
  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;
    if (0 == xhr.status) {
      if (self.aborted) return self.timeoutError();
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  if (xhr.upload) {
    xhr.upload.onprogress = function(e){
      e.percent = e.loaded / e.total * 100;
      self.emit('progress', e);
    };
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  xhr.open(this.method, this.url, true);

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var serialize = request.serialize[this.getHeader('Content-Type')];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  // send stuff
  xhr.send(data);
  return this;
};

/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(method, url) {
  // callback
  if ('function' == typeof url) {
    return new Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new Request('GET', method);
  }

  return new Request(method, url);
}

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.del = function(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * Expose `request`.
 */

module.exports = request;

});
require.register("bergie-octo/octo.js", function(exports, require, module){
/*!
 * octo.js
 * Copyright (c) 2012 Justin Palmer <justin@labratrevenge.com>
 * MIT Licensed
 */

(function() {

  if(typeof superagent === 'undefined' && require) {
    superagent = require('superagent');
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      btoa = require('btoa');
    }
  }

  var octo = {}

  // The main entry point for interacting with the GitHub API v3.
  //
  //      var gh = octo.api()
  //      gh.get('/events').on('success', function(events) {
  //        console.log(events);
  //      })
  //
  octo.api = function() {
    var host  = 'https://api.github.com',
        agent = superagent,
        limit,
        remaining,
        username,
        password,
        token

    function api() {}

    function pager(method, path, params) {
      var page    = 1,
          perpage = 30,
          hasnext = false,
          hasprev = false,
          headers = {},
          callbacks = {}

      var request = function() {
        var req = superagent[method](api.host() + path)

        var complete = function(res) {
          limit = ~~res.header['x-ratelimit-limit']
          remaining = ~~res.header['x-ratelimit-remaining']

          var link = res.header['link']
          hasnext = (/rel=\"next\"/i).test(link)
          hasprev = (/rel=\"next\"/).test(link)

          pager.trigger('end', res)
          if(res.ok)    pager.trigger('success', res)
          if(res.error) pager.trigger('error', res)
        }

        if(token) req.set('Authorization', 'token ' + token)

        if(!token && username && password)
          req.set('Authorization', 'Basic ' + btoa(username + ':' + password))

        req
          .set(headers)
          .query({page: page, per_page: perpage})
          .send(params)
          .end(complete)
      }

      // ### Paging
      // Each subsequent request for additional pages can easily share the same callbacks and properties.
      //
      //      var events = api.get('/events').on('end', function(response) {
      //        console.log(response.body);
      //        events.next()
      //        console.log(events.page());
      //      })
      //
      //      events()
      //
      function pager() { request() }

      // Sets or gets the current page
      //
      // Returns the pager
      pager.page = function(v) {
        if(!arguments.length) return page
        page = v

        return pager
      }

      // Sets or gets the items returned per page
      //
      // Returns the pager
      pager.perpage = function(v) {
        if(!arguments.length) return perpage
        perpage = v

        return pager
      }

      // Increments the page number by one and fires a requests for the next page
      //
      // Returns the pager
      pager.next = function() {
        page += 1
        request()

        return pager
      }

      // Decrements the page number by one and fires a request for the previous page
      //
      // Returns the pager
      pager.prev = function() {
        page -= 1
        request()

        return pager
      }

      // Determines if the server is reporting a next page of results
      pager.hasnext = function() {
        return hasnext;
      }

      // Determines if the server is reporting a previous page of results
      pager.hasprev = function() {
        return hasprev;
      }

      // Registers a callback for an event
      //
      //  Supported events:
      //
      // * `success` - Request was successful
      // * `error` - Request returned an error
      // * `end` - Request is complete
      //
      // Returns a pager
      pager.on = function(event, callback) {
        if (typeof callbacks[event] == 'undefined')
          callbacks[event] = []

        callbacks[event].push(callback)

        return pager
      }

      // Unregisters a previously registered callback
      pager.off = function(event, callback) {
        if (callbacks[event] instanceof Array) {
          var cbacks = callbacks[event], i = 0
          for (i; i < cbacks.length; i++) {
            if (cbacks[i] === callback) {
              cbacks.splice(i, 1)
              break
            }
          }
        }

        return pager
      }

      // Triggers a custom event
      pager.trigger = function(event, data) {
        if (callbacks[event] instanceof Array) {
          callbacks[event].forEach(function(callback) {
            callback.call(pager, data)
          })
        }

        return pager
      }

      // Sets a request header
      pager.set = function(key, val) {
        headers[key] = val
        return pager
      }

      return pager
    }

    // Sets or gets the GitHub API host
    // Uses https://api.github.com by default
    //
    //      var gh = octo.api().host('https://api.github.com')
    //
    // Returns the api
    api.host = function(val) {
      if(!arguments.length) return host
      host = val
      return api
    }

    // Initializes a GET request to GitHub API v3
    // Returns a pager
    api.get = function(path, params) {
      return new pager('get', path)
    }

    // Initializes a POST request to GitHub API v3
    // Returns a pager
    api.post = function(path, params) {
      return new pager('post', path, params)
    }

    // Initializes a PATCH request to GitHub API v3
    // Returns a pager
    api.patch = function(path, params) {
      return new pager('patch', path, params)
    }

    // Initializes a PUT request to GitHub API v3
    // Returns a pager
    api.put = function(path, params) {
      return new pager('put', path, params)
    }

    // Initializes a DELETE request to GitHub API v3
    // Returns a pager
    api.delete = function(path, params) {
      return new pager('delete', path, params)
    }

    // Returns the API rate limit as reported by GitHub
    api.limit = function() {
      return limit
    }

    // Returns the number of requests that can be made before the `limit` is reached
    api.remaining = function() {
      return remaining;
    }

    // Sets or gets the Basic Auth username
    // Returns the api
    api.username = function(v) {
      if(!arguments.length) return username;
      username = v

      return api
    }

    // Sets or gets the Basic Auth password
    // Returns the api
    api.password = function(v) {
      if(!arguments.length) return password;
      password = v

      return api
    }

    // Sets or gets an OAuth two token.  You can temporarily use Basic Auth to create a
    // GitHub Authorization which will grant you an OAuth token.  You can use this token in
    // your scripts
    // Returns the api
    api.token = function(v) {
      if(!arguments.length) return token;
      token = v

      return api
    }

    return api
  }

  if("undefined" != typeof exports)
    module.exports = octo
  else
    window.octo = octo

})()

});
require.register("noflo-noflo-github/index.js", function(exports, require, module){

});
require.register("noflo-noflo-github/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-github","description":"GitHub service components for the NoFlo flow-based programming environment","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-github","dependencies":{"noflo/noflo":"*","bergie/octo":"*"},"scripts":["index.js","components/CreateRepository.coffee","components/CreateOrgRepository.coffee","components/GetRepository.coffee","components/GetContents.coffee","components/GetCurrentUser.coffee","components/GetUser.coffee","components/GetStargazers.coffee","components/SetContents.coffee"],"json":["component.json"],"noflo":{"icon":"github","components":{"CreateRepository":"components/CreateRepository.coffee","CreateOrgRepository":"components/CreateOrgRepository.coffee","GetRepository":"components/GetRepository.coffee","GetContents":"components/GetContents.coffee","GetCurrentUser":"components/GetCurrentUser.coffee","GetUser":"components/GetUser.coffee","GetStargazers":"components/GetStargazers.coffee","SetContents":"components/SetContents.coffee"}}}');
});
require.register("noflo-noflo-github/components/CreateRepository.js", function(exports, require, module){
var CreateRepository, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

CreateRepository = (function(_super) {
  __extends(CreateRepository, _super);

  function CreateRepository() {
    this.token = null;
    this.inPorts = {
      "in": new noflo.Port('string'),
      token: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('object'),
      error: new noflo.Port('string')
    };
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    CreateRepository.__super__.constructor.call(this);
  }

  CreateRepository.prototype.doAsync = function(repo, callback) {
    var api, request;
    api = octo.api();
    if (!this.token) {
      callback(new Error('token required'));
      return;
    }
    api.token(this.token);
    request = api.post('/user/repos', {
      name: repo
    });
    request.on('success', (function(_this) {
      return function(res) {
        _this.outPorts.out.beginGroup(repo);
        _this.outPorts.out.send(res.body);
        _this.outPorts.out.endGroup();
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return CreateRepository;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new CreateRepository;
};

});
require.register("noflo-noflo-github/components/CreateOrgRepository.js", function(exports, require, module){
var CreateOrgRepository, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

CreateOrgRepository = (function(_super) {
  __extends(CreateOrgRepository, _super);

  function CreateOrgRepository() {
    this.token = null;
    this.organization = null;
    this.inPorts = {
      "in": new noflo.Port,
      org: new noflo.Port,
      token: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      error: new noflo.Port
    };
    this.inPorts.org.on('data', (function(_this) {
      return function(data) {
        return _this.organization = data;
      };
    })(this));
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    CreateOrgRepository.__super__.constructor.call(this);
  }

  CreateOrgRepository.prototype.doAsync = function(repo, callback) {
    var api, request;
    api = octo.api();
    if (!this.organization) {
      callback(new Error('organization name required'));
      return;
    }
    if (!this.token) {
      callback(new Error('token required'));
      return;
    }
    api.token(this.token);
    request = api.post("/orgs/" + this.organization + "/repos", {
      name: repo
    });
    request.on('success', (function(_this) {
      return function(res) {
        _this.outPorts.out.beginGroup(repo);
        _this.outPorts.out.send(res.body);
        _this.outPorts.out.endGroup();
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return CreateOrgRepository;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new CreateOrgRepository;
};

});
require.register("noflo-noflo-github/components/GetRepository.js", function(exports, require, module){
var GetRepository, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

GetRepository = (function(_super) {
  __extends(GetRepository, _super);

  GetRepository.prototype.description = 'Get information about a repository';

  function GetRepository() {
    this.token = null;
    this.inPorts = {
      "in": new noflo.Port('string'),
      token: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    GetRepository.__super__.constructor.call(this);
  }

  GetRepository.prototype.doAsync = function(repo, callback) {
    var api, request;
    api = octo.api();
    if (this.token) {
      api.token(this.token);
    }
    request = api.get("/repos/" + repo);
    request.on('success', (function(_this) {
      return function(res) {
        _this.outPorts.out.beginGroup(repo);
        _this.outPorts.out.send(res.body);
        _this.outPorts.out.endGroup();
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return GetRepository;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetRepository;
};

});
require.register("noflo-noflo-github/components/GetContents.js", function(exports, require, module){
var GetContents, atob, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

if (!noflo.isBrowser()) {
  atob = require('atob');
} else {
  atob = window.atob;
}

GetContents = (function(_super) {
  __extends(GetContents, _super);

  GetContents.prototype.description = 'Get contents of a file or a directory';

  function GetContents() {
    this.token = null;
    this.repo = null;
    this.sendRepo = true;
    this.inPorts = {
      repository: new noflo.Port('string'),
      path: new noflo.Port('string'),
      token: new noflo.Port('string'),
      sendrepo: new noflo.Port('boolean')
    };
    this.outPorts = {
      out: new noflo.Port('string'),
      files: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.repository.on('data', (function(_this) {
      return function(data) {
        return _this.repo = data;
      };
    })(this));
    this.inPorts.sendrepo.on('data', (function(_this) {
      return function(sendRepo) {
        _this.sendRepo = sendRepo;
      };
    })(this));
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    GetContents.__super__.constructor.call(this, 'path');
  }

  GetContents.prototype.doAsync = function(path, callback) {
    var api, repo, request;
    api = octo.api();
    if (this.token) {
      api.token(this.token);
    }
    if (!this.repo) {
      callback(new Error('repository name required'));
    }
    repo = this.repo;
    request = api.get("/repos/" + repo + "/contents/" + path);
    request.on('success', (function(_this) {
      return function(res) {
        var file, _i, _len, _ref;
        if (!res.body.content) {
          if (toString.call(res.body) !== '[object Array]') {
            callback(new Error('content not found'));
            return;
          }
          if (!_this.outPorts.files.isAttached()) {
            callback(new Error('content not found'));
            return;
          }
          if (_this.sendRepo) {
            _this.outPorts.files.beginGroup(repo);
          }
          _ref = res.body;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            _this.outPorts.files.send(file);
          }
          if (_this.sendRepo) {
            _this.outPorts.files.endGroup();
          }
          _this.outPorts.files.disconnect();
          callback();
          return;
        }
        if (_this.sendRepo) {
          _this.outPorts.out.beginGroup(repo);
        }
        _this.outPorts.out.beginGroup(path);
        _this.outPorts.out.send(atob(res.body.content.replace(/\s/g, '')));
        _this.outPorts.out.endGroup();
        if (_this.sendRepo) {
          _this.outPorts.out.endGroup();
        }
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return GetContents;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetContents;
};

});
require.register("noflo-noflo-github/components/GetCurrentUser.js", function(exports, require, module){
var GetCurrentUser, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

GetCurrentUser = (function(_super) {
  __extends(GetCurrentUser, _super);

  function GetCurrentUser() {
    this.token = null;
    this.inPorts = {
      token: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      error: new noflo.Port
    };
    GetCurrentUser.__super__.constructor.call(this, 'token');
  }

  GetCurrentUser.prototype.doAsync = function(token, callback) {
    var api, request;
    api = octo.api();
    api.token(token);
    request = api.get("/user");
    request.on('success', (function(_this) {
      return function(res) {
        _this.outPorts.out.send(res.body);
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return GetCurrentUser;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetCurrentUser;
};

});
require.register("noflo-noflo-github/components/GetUser.js", function(exports, require, module){
var GetUser, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

GetUser = (function(_super) {
  __extends(GetUser, _super);

  function GetUser() {
    this.token = null;
    this.inPorts = {
      user: new noflo.Port,
      token: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      error: new noflo.Port
    };
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    GetUser.__super__.constructor.call(this, 'user');
  }

  GetUser.prototype.doAsync = function(user, callback) {
    var api, request;
    api = octo.api();
    if (this.token) {
      api.token(this.token);
    }
    request = api.get("/users/" + user);
    request.on('success', (function(_this) {
      return function(res) {
        _this.outPorts.out.beginGroup(user);
        _this.outPorts.out.send(res.body);
        _this.outPorts.out.endGroup();
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return GetUser;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetUser;
};

});
require.register("noflo-noflo-github/components/GetStargazers.js", function(exports, require, module){
var GetStargazers, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

GetStargazers = (function(_super) {
  __extends(GetStargazers, _super);

  function GetStargazers() {
    this.token = null;
    this.inPorts = {
      repository: new noflo.Port,
      token: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      error: new noflo.Port
    };
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    GetStargazers.__super__.constructor.call(this, 'repository');
  }

  GetStargazers.prototype.doAsync = function(repository, callback) {
    var api, request;
    api = octo.api();
    if (this.token) {
      api.token(this.token);
    }
    request = api.get("/repos/" + repository + "/stargazers");
    request.on('success', (function(_this) {
      return function(res) {
        var user, _i, _len, _ref;
        _this.outPorts.out.beginGroup(repository);
        _ref = res.body;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          user = _ref[_i];
          _this.outPorts.out.send(user);
        }
        _this.outPorts.out.endGroup();
        if (request.hasnext()) {
          return request.next();
        }
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return GetStargazers;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetStargazers;
};

});
require.register("noflo-noflo-github/components/SetContents.js", function(exports, require, module){
var SetContents, btoa, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

if (!noflo.isBrowser()) {
  btoa = require('btoa');
} else {
  btoa = window.btoa;
}

SetContents = (function(_super) {
  __extends(SetContents, _super);

  SetContents.prototype.description = 'Create or update a file in the repository';

  function SetContents() {
    this.token = null;
    this.message = null;
    this.repo = null;
    this.path = null;
    this.inPorts = {
      "in": new noflo.Port('string'),
      token: new noflo.Port('string'),
      message: new noflo.Port('string'),
      repository: new noflo.Port('string'),
      path: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.token.on('data', (function(_this) {
      return function(token) {
        _this.token = token;
      };
    })(this));
    this.inPorts.message.on('data', (function(_this) {
      return function(message) {
        _this.message = message;
      };
    })(this));
    this.inPorts.repository.on('data', (function(_this) {
      return function(repo) {
        _this.repo = repo;
      };
    })(this));
    this.inPorts.path.on('data', (function(_this) {
      return function(path) {
        _this.path = path;
      };
    })(this));
    SetContents.__super__.constructor.call(this, 'in');
  }

  SetContents.prototype.doAsync = function(contents, callback) {
    var api, message, path, repo, shaReq;
    if (!this.repo) {
      callback(new Error('repository name required'));
    }
    if (!this.path) {
      callback(new Error('file path required'));
    }
    if (!this.message) {
      this.message = '';
    }
    repo = this.repo;
    path = this.path;
    message = this.message;
    api = octo.api();
    if (this.token) {
      api.token(this.token);
    }
    shaReq = api.get("/repos/" + repo + "/contents/" + path);
    shaReq.on('success', (function(_this) {
      return function(shaRes) {
        var updateReq;
        updateReq = api.put("/repos/" + repo + "/contents/" + path, {
          path: path,
          message: message,
          content: btoa(contents),
          sha: shaRes.body.sha
        });
        updateReq.on('success', function(updateRes) {
          _this.outPorts.out.beginGroup(path);
          _this.outPorts.out.send(updateRes.sha);
          _this.outPorts.out.endGroup();
          _this.outPorts.out.disconnect();
          return callback();
        });
        updateReq.on('error', function(error) {
          _this.outPorts.out.disconnect();
          return callback(err.body);
        });
        return updateReq();
      };
    })(this));
    shaReq.on('error', (function(_this) {
      return function() {
        var createReq;
        createReq = api.put("/repos/" + repo + "/contents/" + path, {
          path: path,
          message: message,
          content: btoa(contents)
        });
        createReq.on('success', function(createRes) {
          _this.outPorts.out.beginGroup(path);
          _this.outPorts.out.send(createRes.sha);
          _this.outPorts.out.endGroup();
          _this.outPorts.out.disconnect();
          return callback();
        });
        createReq.on('error', function(error) {
          _this.outPorts.out.disconnect();
          return callback(err.body);
        });
        return createReq();
      };
    })(this));
    this.outPorts.out.connect();
    return shaReq();
  };

  return SetContents;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new SetContents;
};

});
require.register("d4tocchini-noflo-draggabilly/index.js", function(exports, require, module){
/*
 * This file can be used for general library features that are exposed as CommonJS modules
 * that the components then utilize
 */

});
require.register("d4tocchini-noflo-draggabilly/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-draggabilly","description":"Draggabilly components for the NoFlo flow-based programming environment","author":"D4 Tocchini <d4@rituwall.com>","repo":"d4tocchini/noflo-draggabilly","version":"0.0.1","keywords":["fbp","drag","dnd","draggable"],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Draggabilly.coffee","index.js"],"json":["component.json"],"noflo":{"components":{"Draggabilly":"components/Draggabilly.coffee"}}}');
});
require.register("d4tocchini-noflo-draggabilly/components/Draggabilly.js", function(exports, require, module){
var NoFloDraggabilly, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');


/*
if typeof process is 'object' and process.title is 'node'
  noflo = require "../../lib/NoFlo"
else
  noflo = require '../lib/NoFlo'
 */

NoFloDraggabilly = (function(_super) {
  __extends(NoFloDraggabilly, _super);

  NoFloDraggabilly.prototype.description = 'Make shiz draggable';

  function NoFloDraggabilly() {
    this.dragend = __bind(this.dragend, this);
    this.dragmove = __bind(this.dragmove, this);
    this.dragstart = __bind(this.dragstart, this);
    this.subscribe = __bind(this.subscribe, this);
    this.options = {};
    this.inPorts = {
      container: new noflo.Port('object'),
      options: new noflo.Port,
      element: new noflo.Port('object')
    };
    this.outPorts = {
      start: new noflo.ArrayPort('object'),
      movex: new noflo.ArrayPort('number'),
      movey: new noflo.ArrayPort('number'),
      end: new noflo.ArrayPort('object')
    };
    this.inPorts.container.on("data", (function(_this) {
      return function(data) {
        return _this.setOptions({
          containment: data
        });
      };
    })(this));
    this.inPorts.options.on("data", (function(_this) {
      return function(data) {
        return _this.setOptions(data);
      };
    })(this));
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
  }

  NoFloDraggabilly.prototype.subscribe = function(element) {
    var draggie;
    draggie = this.draggie = new Draggabilly(element, this.options);
    draggie.on('dragStart', this.dragstart);
    draggie.on('dragMove', this.dragmove);
    return draggie.on('dragEnd', this.dragend);
  };

  NoFloDraggabilly.prototype.setOptions = function(options) {
    var key, value, _results;
    if (typeof options !== "object") {
      throw new Error("Options is not an object");
    }
    _results = [];
    for (key in options) {
      if (!__hasProp.call(options, key)) continue;
      value = options[key];
      _results.push(this.options[key] = value);
    }
    return _results;
  };

  NoFloDraggabilly.prototype.dragstart = function(draggie, event, pointer) {
    this.outPorts.start.send(event);
    this.outPorts.start.disconnect();
    this.outPorts.movex.send(draggie.position.x);
    return this.outPorts.movey.send(draggie.position.y);
  };

  NoFloDraggabilly.prototype.dragmove = function(draggie, event, pointer) {
    this.outPorts.movex.send(draggie.position.x);
    return this.outPorts.movey.send(draggie.position.y);
  };

  NoFloDraggabilly.prototype.dragend = function(draggie, event, pointer) {
    if (this.outPorts.movex.isConnected()) {
      this.outPorts.movex.disconnect();
    }
    if (this.outPorts.movey.isConnected()) {
      this.outPorts.movey.disconnect();
    }
    this.outPorts.end.send(event);
    return this.outPorts.end.disconnect();
  };

  return NoFloDraggabilly;

})(noflo.Component);

exports.getComponent = function() {
  return new NoFloDraggabilly;
};

});
require.register("forresto-noflo-gum/index.js", function(exports, require, module){
/* nothing here */
});
require.register("forresto-noflo-gum/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-gum","description":"getUserMedia components for getting webcam and mic into NoFlo","author":"Forrest Oliphant <forrest@sembiki.com>","repo":"forresto/noflo-gum","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/GetUserMedia.coffee","index.js"],"json":["component.json"],"noflo":{"components":{"GetUserMedia":"components/GetUserMedia.coffee"}}}');
});
require.register("forresto-noflo-gum/components/GetUserMedia.js", function(exports, require, module){
var GetUserMedia, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetUserMedia = (function(_super) {
  __extends(GetUserMedia, _super);

  GetUserMedia.prototype.description = 'initialize camera and/or microphone';

  GetUserMedia.prototype.icon = 'video-camera';

  function GetUserMedia() {
    this.video = true;
    this.audio = false;
    this.stream = null;
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang'),
      video: new noflo.Port('boolean'),
      audio: new noflo.Port('boolean')
    };
    this.outPorts = {
      stream: new noflo.Port('object'),
      url: new noflo.Port('string'),
      error: new noflo.Port('object')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        return _this.resetStream();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.stopStream();
      };
    })(this));
    this.inPorts.video.on('data', (function(_this) {
      return function(video) {
        _this.video = video;
        if (_this.stream) {
          return _this.resetStream();
        }
      };
    })(this));
    this.inPorts.audio.on('data', (function(_this) {
      return function(audio) {
        _this.audio = audio;
        if (_this.stream) {
          return _this.resetStream();
        }
      };
    })(this));
    this.stopStream = (function(_this) {
      return function() {
        if (_this.stream) {
          if (_this.stream.stop) {
            _this.stream.stop();
          }
          return _this.stream = null;
        }
      };
    })(this);
    this.resetStream = (function(_this) {
      return function() {
        _this.stopStream();
        if (!navigator.getUserMedia) {
          navigator.getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || null;
        }
        if (!navigator.getUserMedia) {
          _this.error('getUserMedia not available in this browser.');
          return;
        }
        return navigator.getUserMedia({
          video: _this.video,
          audio: _this.audio
        }, function(stream) {
          _this.stream = stream;
          if (!window.URL) {
            window.URL = window.webkitURL || window.msURL || window.oURL || null;
          }
          if (_this.outPorts.url.isAttached()) {
            if (window.URL.createObjectURL) {
              _this.outPorts.url.send(window.URL.createObjectURL(stream));
            } else {
              _this.outPorts.url.send(stream);
            }
          }
          if (_this.outPorts.stream.isAttached()) {
            return _this.outPorts.stream.send(stream);
          }
        }, function() {
          return _this.error('Access denied or no device available.');
        });
      };
    })(this);
  }

  GetUserMedia.prototype.error = function(msg) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(new Error(msg));
      this.outPorts.error.disconnect();
      return;
    }
    throw new Error(msg);
  };

  GetUserMedia.prototype.shutdown = function() {
    return this.stopStream();
  };

  return GetUserMedia;

})(noflo.Component);

exports.getComponent = function() {
  return new GetUserMedia;
};

});
require.register("forresto-noflo-seriously/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-seriously.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

// require.alias("forresto-noflo-seriously/vendor/seriously.js", "seriously");
});
require.register("forresto-noflo-seriously/vendor/seriously.js", function(exports, require, module){
/*jslint devel: true, bitwise: true, browser: true, white: true, nomen: true, plusplus: true, maxerr: 50, indent: 4, todo: true */
/*global Float32Array, Uint8Array, Uint16Array, WebGLTexture, HTMLInputElement, HTMLSelectElement, HTMLElement, WebGLFramebuffer, HTMLCanvasElement, WebGLRenderingContext, define, module, exports */
(function (root, factory) {
	'use strict';
	if (typeof exports === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like enviroments that support module.exports,
		// like Node.
		module.exports = factory(root);
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define('seriously', function () {
			var Seriously = factory(root);
			if (!root.Seriously) {
				root.Seriously = Seriously;
			}
			return Seriously;
		});
	} else {
		// Browser globals
		root.Seriously = factory(root);
	}
}(this, function (window, undefined) {
	'use strict';

	var document = window.document,
		console = window.console,

	/*
		Global environment variables
	*/

	testContext,
	colorElement,
	incompatibility,
	seriousEffects = {},
	seriousTransforms = {},
	timeouts = [],
	allEffectsByHook = {},
	allTransformsByHook = {},
	identity,
	nop = function () {},

	/*
		Global reference variables
	*/

	// http://www.w3.org/TR/css3-color/#svg-color
	colorNames = {
		transparent: [0, 0, 0, 0],
		red: [1, 0, 0, 1],
		green: [0, 1, 0, 1],
		blue: [0, 0, 1, 1],
		white: [1, 1, 1, 1]
	},

	vectorFields = ['x', 'y', 'z', 'w'],
	colorFields = ['r', 'g', 'b', 'a'],

	/*
		utility functions
	*/

	/*
	mat4 matrix functions borrowed from gl-matrix by toji
	https://github.com/toji/gl-matrix
	License: https://github.com/toji/gl-matrix/blob/master/LICENSE.md
	*/
	mat4 = {
		/*
		 * mat4.frustum
		 * Generates a frustum matrix with the given bounds
		 *
		 * Params:
		 * left, right - scalar, left and right bounds of the frustum
		 * bottom, top - scalar, bottom and top bounds of the frustum
		 * near, far - scalar, near and far bounds of the frustum
		 * dest - Optional, mat4 frustum matrix will be written into
		 *
		 * Returns:
		 * dest if specified, a new mat4 otherwise
		 */
		frustum: function (left, right, bottom, top, near, far, dest) {
			if(!dest) { dest = mat4.create(); }
			var rl = (right - left),
				tb = (top - bottom),
				fn = (far - near);
			dest[0] = (near*2) / rl;
			dest[1] = 0;
			dest[2] = 0;
			dest[3] = 0;
			dest[4] = 0;
			dest[5] = (near*2) / tb;
			dest[6] = 0;
			dest[7] = 0;
			dest[8] = (right + left) / rl;
			dest[9] = (top + bottom) / tb;
			dest[10] = -(far + near) / fn;
			dest[11] = -1;
			dest[12] = 0;
			dest[13] = 0;
			dest[14] = -(far*near*2) / fn;
			dest[15] = 0;
			return dest;
		},

		perspective: function (fovy, aspect, near, far, dest) {
			var top = near*Math.tan(fovy*Math.PI / 360.0),
				right = top*aspect;
			return mat4.frustum(-right, right, -top, top, near, far, dest);
		},
		multiply: function (dest, mat, mat2) {
			// Cache the matrix values (makes for huge speed increases!)
			var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
				a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
				a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
				a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

			// Cache only the current line of the second matrix
			b0 = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];
			dest[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
			dest[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
			dest[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
			dest[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

			b0 = mat2[4];
			b1 = mat2[5];
			b2 = mat2[6];
			b3 = mat2[7];
			dest[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
			dest[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
			dest[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
			dest[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

			b0 = mat2[8];
			b1 = mat2[9];
			b2 = mat2[10];
			b3 = mat2[11];
			dest[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
			dest[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
			dest[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
			dest[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

			b0 = mat2[12];
			b1 = mat2[13];
			b2 = mat2[14];
			b3 = mat2[15];
			dest[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
			dest[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
			dest[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
			dest[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

			return dest;
		},
		identity: function (dest) {
			dest[0] = 1;
			dest[1] = 0;
			dest[2] = 0;
			dest[3] = 0;
			dest[4] = 0;
			dest[5] = 1;
			dest[6] = 0;
			dest[7] = 0;
			dest[8] = 0;
			dest[9] = 0;
			dest[10] = 1;
			dest[11] = 0;
			dest[12] = 0;
			dest[13] = 0;
			dest[14] = 0;
			dest[15] = 1;
			return dest;
		},
		copy: function (out, a) {
			out[0] = a[0];
			out[1] = a[1];
			out[2] = a[2];
			out[3] = a[3];
			out[4] = a[4];
			out[5] = a[5];
			out[6] = a[6];
			out[7] = a[7];
			out[8] = a[8];
			out[9] = a[9];
			out[10] = a[10];
			out[11] = a[11];
			out[12] = a[12];
			out[13] = a[13];
			out[14] = a[14];
			out[15] = a[15];
			return out;
		}
	},

	requestAnimationFrame = (function (){
		var lastTime = 0;
		return  window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function (callback) {
					var currTime, timeToCall, id;

					function timeoutCallback() {
						callback(currTime + timeToCall);
					}

					currTime = new Date().getTime();
					timeToCall = Math.max(0, 16 - (currTime - lastTime));
					id = window.setTimeout(timeoutCallback, timeToCall);
					lastTime = currTime + timeToCall;
					return id;
				};
	}()),

	cancelAnimFrame = (function (){
		return  window.cancelAnimationFrame ||
				window.webkitCancelAnimationFrame ||
				window.mozCancelAnimationFrame ||
				window.oCancelAnimationFrame ||
				window.msCancelAnimationFrame ||
				function (id) {
					window.cancelTimeout(id);
				};
	}()),

	reservedNames = ['source', 'target', 'effect', 'effects', 'benchmark', 'incompatible',
		'util', 'ShaderProgram', 'inputValidators', 'save', 'load',
		'plugin', 'removePlugin', 'alias', 'removeAlias', 'stop', 'go',
		'destroy', 'isDestroyed'];

	function getElement(input, tags) {
		var element,
			tag;
		if (typeof input === 'string') {
			//element = document.getElementById(input) || document.getElementsByTagName(input)[0];
			element = document.querySelector(input);
		} else if (!input) {
			return false;
		}

		if (input.tagName) {
			element = input;
		}

		if (!element) {
			return input;
		}

		tag = element.tagName.toLowerCase();
		if (tags && tags.indexOf(tag) < 0) {
			return input;
		}

		return element;
	}

	function extend(dest, src) {
		var property,
			descriptor;

		//todo: are we sure this is safe?
		if (dest.prototype && src.prototype && dest.prototype !== src.prototype) {
			extend(dest.prototype, src.prototype);
		}

		for (property in src) {
			if (src.hasOwnProperty(property)) {
				descriptor = Object.getOwnPropertyDescriptor(src, property);

				if (descriptor.get || descriptor.set) {
					Object.defineProperty(dest, property, {
						configurable: true,
						enumerable: true,
						get: descriptor.get,
						set: descriptor.set
					});
				} else {
					dest[property] = src[property];
				}
			}
		}

		return dest;
	}

	//http://www.w3.org/TR/css3-color/#hsl-color
	function hslToRgb(h, s, l, a, out) {
		function hueToRgb(m1, m2, h) {
			h = h % 1;
			if (h < 0) {
				h += 1;
			}
			if (h < 1 / 6) {
				return m1 + (m2 - m1) * h * 6;
			}
			if (h < 1 / 2) {
				return m2;
			}
			if (h < 2 / 3) {
				return m1 + (m2 - m1) * (2/3 - h) * 6;
			}
			return m1;
		}

		var m1, m2;
		if (l < 0.5) {
			m2 = l * (s + 1);
		} else {
			m2 = l + s - l * s;
		}
		m1 = l * 2 - m2;

		if (!out) {
			out = [];
		}

		out[0] = hueToRgb(m1, m2, h + 1/3);
		out[1] = hueToRgb(m1, m2, h);
		out[2] = hueToRgb(m1, m2, h - 1/3);
		out[3] = a;

		return out;
	}

	/*
	faster than setTimeout(fn, 0);
	http://dbaron.org/log/20100309-faster-timeouts
	*/
	function setTimeoutZero(fn) {
		/*
		Workaround for postMessage bug in Firefox if the page is loaded from the file system
		https://bugzilla.mozilla.org/show_bug.cgi?id=740576
		Should run fine, but maybe a few milliseconds slower per frame.
		*/
		function timeoutFunction() {
			if (timeouts.length) {
				(timeouts.shift())();
			}
		}

		if (typeof fn !== 'function') {
			throw 'setTimeoutZero argument is not a function';
		}

		timeouts.push(fn);
		if (window.location.protocol === 'file:') {
			setTimeout(timeoutFunction, 0);
			return;
		}

		window.postMessage('seriously-timeout-message', window.location);
	}

	function isArrayLike(obj) {
		return Array.isArray(obj) ||
			(obj && obj.BYTES_PER_ELEMENT && 'length' in obj);
	}

	window.addEventListener('message', function (event) {
		if (event.source === window && event.data === 'seriously-timeout-message') {
			event.stopPropagation();
			if (timeouts.length > 0) {
				var fn = timeouts.shift();
				fn();
			}
		}
	}, true);

	function getTestContext() {
		var canvas;

		if (testContext || !window.WebGLRenderingContext) {
			return testContext;
		}

		canvas = document.createElement('canvas');
		try {
			testContext = canvas.getContext('experimental-webgl');
			canvas.addEventListener('webglcontextlost', function (event) {
				/*
				If/When context is lost, just clear testContext and create
				a new one the next time it's needed
				*/
				event.preventDefault();
				if (testContext && testContext.canvas === this) {
					testContext = undefined;
				}
			}, false);
		} catch (webglError) {
			console.log('Unable to access WebGL.');
		}

		return testContext;
	}

	function checkSource(source) {
		var element, canvas, ctx, texture;

		//todo: don't need to create a new array every time we do this
		element = getElement(source, ['img', 'canvas', 'video']);
		if (!element) {
			return false;
		}

		canvas = document.createElement('canvas');
		if (!canvas) {
			console.log('Browser does not support canvas or Seriously.js');
			return false;
		}

		ctx = getTestContext();

		if (ctx) {
			texture = ctx.createTexture();
			ctx.bindTexture(ctx.TEXTURE_2D, texture);

			try {
				ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, ctx.RGBA, ctx.UNSIGNED_BYTE, element);
			} catch (textureError) {
				if (textureError.code === window.DOMException.SECURITY_ERR) {
					console.log('Unable to access cross-domain image');
				} else {
					console.log('Error: ' + textureError.message);
				}
				ctx.deleteTexture(texture);
				return false;
			}
			ctx.deleteTexture(texture);
		} else {
			ctx = canvas.getContext('2d');
			try {
				ctx.drawImage(element, 0, 0);
				ctx.getImageData(0, 0, 1, 1);
			} catch (drawImageError) {
				if (drawImageError.code === window.DOMException.SECURITY_ERR) {
					console.log('Unable to access cross-domain image');
				} else {
					console.log('Error: ' + drawImageError.message);
				}
				return false;
			}
		}

		// This method will return a false positive for resources that aren't
		// actually images or haven't loaded yet

		return true;
	}

	function validateInputSpecs(effect) {
		var reserved = ['render', 'initialize', 'original', 'plugin', 'alias',
			'prototype', 'destroy', 'isDestroyed'],
			input,
			name;

		function nop(value) {
			return value;
		}

		for (name in effect.inputs) {
			if (effect.inputs.hasOwnProperty(name)) {
				if (reserved.indexOf(name) >= 0 || Object.prototype[name]) {
					throw 'Reserved effect input name: ' + name;
				}

				input = effect.inputs[name];

				if (isNaN(input.min)) {
					input.min = -Infinity;
				}

				if (isNaN(input.max)) {
					input.max = Infinity;
				}

				if (isNaN(input.minCount)) {
					input.minCount = -Infinity;
				}

				if (isNaN(input.maxCount)) {
					input.maxCount = Infinity;
				}

				if (isNaN(input.step)) {
					input.step = 0;
				}

				if (input.defaultValue === undefined || input.defaultValue === null) {
					if (input.type === 'number') {
						input.defaultValue = Math.min(Math.max(0, input.min), input.max);
					} else if (input.type === 'color') {
						input.defaultValue = [0, 0, 0, 0];
					} else if (input.type === 'enum') {
						if (input.options && input.options.length) {
							input.defaultValue = input.options[0];
						} else {
							input.defaultValue = '';
						}
					} else if (input.type === 'boolean') {
						input.defaultValue = false;
					} else {
						input.defaultValue = '';
					}
				}

				if (input.type === 'vector') {
					if (input.dimensions < 2) {
						input.dimensions = 2;
					} else if (input.dimensions > 4) {
						input.dimensions = 4;
					} else if (!input.dimensions || isNaN(input.dimensions)) {
						input.dimensions = 4;
					} else {
						input.dimensions = Math.round(input.dimensions);
					}
				} else {
					input.dimensions = 1;
				}

				input.shaderDirty = !!input.shaderDirty;

				if (typeof input.validate !== 'function') {
					input.validate = Seriously.inputValidators[input.type] || nop;
				}

				if (!effect.defaultImageInput && input.type === 'image') {
					effect.defaultImageInput = name;
				}
			}
		}
	}

	/*
		helper Classes
	*/

	function FrameBuffer(gl, width, height, options) {
		var frameBuffer,
			renderBuffer,
			tex,
			status,
			useFloat = options === true ? options : (options && options.useFloat);

		useFloat = false;//useFloat && !!gl.getExtension("OES_texture_float"); //useFloat is not ready!
		if (useFloat) {
			this.type = gl.FLOAT;
		} else {
			this.type = gl.UNSIGNED_BYTE;
		}

		frameBuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);

		if (options && options.texture) {
			this.texture = options.texture;
			gl.bindTexture(gl.TEXTURE_2D, this.texture);
			this.ownTexture = false;
		} else {
			this.texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, this.texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			this.ownTexture = true;
		}

		try {
			if (this.type === gl.FLOAT) {
				tex = new Float32Array(width * height * 4);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, tex);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
				this.type = gl.UNSIGNED_BYTE;
			}
		} catch (e) {
			// Null rejected
			this.type = gl.UNSIGNED_BYTE;
			tex = new Uint8Array(width * height * 4);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, tex);
		}

		renderBuffer = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderBuffer);

		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);

		status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

		if (status === gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {
			throw('Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
		}

		if (status === gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {
			throw('Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
		}

		if (status === gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS) {
			throw('Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
		}

		if (status === gl.FRAMEBUFFER_UNSUPPORTED) {
			throw('Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED');
		}

		if (status !== gl.FRAMEBUFFER_COMPLETE) {
			throw('Incomplete framebuffer: ' + status);
		}

		//clean up
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.bindRenderbuffer(gl.RENDERBUFFER, null);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		this.gl = gl;
		this.frameBuffer = frameBuffer;
		this.renderBuffer = renderBuffer;
		this.width = width;
		this.height = height;
	}

	FrameBuffer.prototype.resize = function (width, height) {
		var gl = this.gl;

		if (this.width === width && this.height === height) {
			return;
		}

		this.width = width;
		this.height = height;

		if (!gl) {
			return;
		}

		gl.bindTexture(gl.TEXTURE_2D, this.texture);
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);

		//todo: handle float
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);

		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.bindRenderbuffer(gl.RENDERBUFFER, null);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	};

	FrameBuffer.prototype.destroy = function () {
		var gl = this.gl;

		if (gl) {
			gl.deleteFramebuffer(this.frameBuffer);
			gl.deleteRenderbuffer(this.renderBuffer);
			if (this.ownTexture) {
				gl.deleteTexture(this.texture);
			}
		}

		delete this.frameBuffer;
		delete this.renderBuffer;
		delete this.texture;
		delete this.gl;
	};

	/* ShaderProgram - utility class for building and accessing WebGL shaders */

	function ShaderProgram(gl, vertexShaderSource, fragmentShaderSource) {
		var program, vertexShader, fragmentShader,
			programError = '',
			shaderError,
			i, l,
			obj;

		function compileShader(source, fragment) {
			var shader, i;
			if (fragment) {
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else {
				shader = gl.createShader(gl.VERTEX_SHADER);
			}

			gl.shaderSource(shader, source);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				source = source.split(/[\n\r]/);
				for (i = 0; i < source.length; i++) {
					source[i] = (i + 1) + ":\t" + source[i];
				}
				console.log(source.join('\n'));
				throw 'Shader error: ' + gl.getShaderInfoLog(shader);
			}

			return shader;
		}

		function makeShaderSetter(info, loc) {
			if (info.type === gl.SAMPLER_2D) {
				return function (value) {
					info.glTexture = gl['TEXTURE' + value];
					gl.uniform1i(loc, value);
				};
			}

			if (info.type === gl.BOOL|| info.type === gl.INT) {
				if (info.size > 1) {
					return function (value) {
						gl.uniform1iv(loc, value);
					};
				}

				return function (value) {
					gl.uniform1i(loc, value);
				};
			}

			if (info.type === gl.FLOAT) {
				if (info.size > 1) {
					return function (value) {
						gl.uniform1fv(loc, value);
					};
				}

				return function (value) {
					gl.uniform1f(loc, value);
				};
			}

			if (info.type === gl.FLOAT_VEC2) {
				return function (obj) {
					gl.uniform2f(loc, obj[0], obj[1]);
				};
			}

			if (info.type === gl.FLOAT_VEC3) {
				return function (obj) {
					gl.uniform3f(loc, obj[0], obj[1], obj[2]);
				};
			}

			if (info.type === gl.FLOAT_VEC4) {
				return function (obj) {
					gl.uniform4f(loc, obj[0], obj[1], obj[2], obj[3]);
				};
			}

			if (info.type === gl.FLOAT_MAT3) {
				return function (mat3) {
					gl.uniformMatrix3fv(loc, false, mat3);
				};
			}

			if (info.type === gl.FLOAT_MAT4) {
				return function (mat4) {
					gl.uniformMatrix4fv(loc, false, mat4);
				};
			}

			throw "Unknown shader uniform type: " + info.type;
		}

		function makeShaderGetter(loc) {
			return function () {
				return gl.getUniform(program, loc);
			};
		}

		vertexShader = compileShader(vertexShaderSource);
		fragmentShader = compileShader(fragmentShaderSource, true);

		program = gl.createProgram();
		gl.attachShader(program, vertexShader);
		shaderError = gl.getShaderInfoLog(vertexShader);
		if (shaderError) {
			programError += 'Vertex shader error: ' + shaderError + "\n";
		}
		gl.attachShader(program, fragmentShader);
		shaderError = gl.getShaderInfoLog(fragmentShader);
		if (shaderError) {
			programError += 'Fragment shader error: ' + shaderError + "\n";
		}
		gl.linkProgram(program);

		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			programError += gl.getProgramInfoLog(program);
			gl.deleteProgram(program);
			gl.deleteShader(vertexShader);
			gl.deleteShader(fragmentShader);
			throw 'Could not initialise shader: ' + programError;
		}

		gl.useProgram(program);

		this.uniforms = {};

		l = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
		for (i = 0; i < l; ++i) {
			obj = {
				info: gl.getActiveUniform(program, i)
			};

			obj.name = obj.info.name;
			obj.loc = gl.getUniformLocation(program, obj.name);
			obj.set = makeShaderSetter(obj.info, obj.loc);
			obj.get = makeShaderGetter(obj.loc);
			this.uniforms[obj.name] = obj;

			if (!this[obj.name]) {
				//for convenience
				this[obj.name] = obj;
			}
		}

		this.attributes = {};
		this.location = {};
		l = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
		for (i = 0; i < l; ++i) {
			obj = {
				info: gl.getActiveAttrib(program, i)
			};

			obj.name = obj.info.name;
			obj.location = gl.getAttribLocation(program, obj.name);
			this.attributes[obj.name] = obj;
			this.location[obj.name] = obj.location;
		}

		this.gl = gl;
		this.program = program;

		this.destroy = function () {
			var i;

			if (gl) {
				gl.deleteProgram(program);
				gl.deleteShader(vertexShader);
				gl.deleteShader(fragmentShader);
			}

			for (i in this) {
				if (this.hasOwnProperty(i)) {
					delete this[i];
				}
			}

			program = null;
			vertexShader = null;
			fragmentShader = null;
		};
	}

	ShaderProgram.prototype.use = function () {
		this.gl.useProgram(this.program);
	};

	/*
		main class: Seriously
	*/

	function Seriously(options) {

		//if called without 'new', make a new object and return that
		if (window === this || !(this instanceof Seriously)) {
			return new Seriously(options);
		}

		//initialize object, private properties
		var seriously = this,
			nodes = [],
			nodesById = {},
			nodeId = 0,
			sources = [],
			targets = [],
			transforms = [],
			effects = [],
			aliases = {},
			preCallbacks = [],
			postCallbacks = [],
			glCanvas,
			gl,
			rectangleModel,
			baseShader,
			baseVertexShader, baseFragmentShader,
			Node, SourceNode, EffectNode, TransformNode, TargetNode,
			Effect, Source, Transform, Target,
			auto = false,
			isDestroyed = false,
			rafId;

		function makeGlModel(shape, gl) {
			var vertex, index, texCoord;

			if (!gl) {
				return false;
			}

			vertex = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, vertex);
			gl.bufferData(gl.ARRAY_BUFFER, shape.vertices, gl.STATIC_DRAW);
			vertex.size = 3;

			index = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shape.indices, gl.STATIC_DRAW);

			texCoord = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, texCoord);
			gl.bufferData(gl.ARRAY_BUFFER, shape.coords, gl.STATIC_DRAW);
			texCoord.size = 2;

			return {
				vertex: vertex,
				index: index,
				texCoord: texCoord,
				length: shape.indices.length,
				mode: shape.mode || gl.TRIANGLES
			};
		}

		function buildRectangleModel(gl) {
			var shape = {};

			shape.vertices = new Float32Array([
				-1, -1, 0,
				1, -1, 0,
				1, 1, 0,
				-1, 1, 0
			]);

			shape.indices = new Uint16Array([
				0, 1, 2,
				0, 2, 3	// Front face
			]);

			shape.coords = new Float32Array([
				0, 0,
				1, 0,
				1, 1,
				0, 1
			]);

			return makeGlModel(shape, gl);
		}

		function attachContext(context) {
			var i, node;

			gl = context;
			glCanvas = context.canvas;

			rectangleModel = buildRectangleModel(gl);

			baseShader = new ShaderProgram(gl, baseVertexShader, baseFragmentShader);

			for (i = 0; i < effects.length; i++) {
				node = effects[i];

				node.gl = gl;

				if (node.initialized) {
					node.buildShader();
				}
			}

			for (i = 0; i < sources.length; i++) {
				node = sources[i];
				node.initialize();
			}

			for (i = 0; i < targets.length; i++) {
				node = targets[i];

				if (!node.model) {
					node.model = rectangleModel;
				}

				//todo: initialize frame buffer if not main canvas
			}
		}

		/*
		runs on every frame, as long as there are media sources (img, video, canvas, etc.) to check,
		dirty target nodes or pre/post callbacks to run. any sources that are updated are set to dirty,
		forcing all dependent nodes to render
		*/
		function renderDaemon() {
			var i, node, media,
				keepRunning = false;

			rafId = null;

			if (preCallbacks.length) {
				keepRunning = true;
				for (i = 0; i < preCallbacks.length; i++) {
					preCallbacks[i].call(seriously);
				}
			}

			if (sources && sources.length) {
				keepRunning = true;
				for (i = 0; i < sources.length; i++) {
					node = sources[i];

					media = node.source;
					if (node.lastRenderTime === undefined ||
							node.dirty ||
							media.currentTime !== undefined && node.lastRenderTime !== media.currentTime) {
						node.dirty = false;
						node.setDirty();
					}
				}
			}

			for (i = 0; i < targets.length; i++) {
				node = targets[i];
				if (node.auto && node.dirty) {
					node.render();
				}
			}

			if (postCallbacks.length) {
				keepRunning = true;
				for (i = 0; i < postCallbacks.length; i++) {
					postCallbacks[i].call(seriously);
				}
			}

			//rafId may have been set again by a callback or in target.setDirty()
			if (keepRunning && !rafId) {
				rafId = requestAnimationFrame(renderDaemon);
			}
		}

		function draw(shader, model, uniforms, frameBuffer, node, options) {
			var numTextures = 0,
				name, value, shaderUniform,
				width, height,
				nodeGl = (node && node.gl) || gl;

			if (!nodeGl) {
				return;
			}

			if (node) {
				width = options && options.width || node.width || nodeGl.canvas.width;
				height = options && options.height || node.height || nodeGl.canvas.height;
			} else {
				width = options && options.width || nodeGl.canvas.width;
				height = options && options.height || nodeGl.canvas.height;
			}

			shader.use();

			nodeGl.viewport(0, 0, width, height);

			nodeGl.bindFramebuffer(nodeGl.FRAMEBUFFER, frameBuffer);

			/* todo: do this all only once at the beginning, since we only have one model? */
			nodeGl.enableVertexAttribArray(shader.location.position);
			nodeGl.enableVertexAttribArray(shader.location.texCoord);

			if (model.texCoord) {
				nodeGl.bindBuffer(nodeGl.ARRAY_BUFFER, model.texCoord);
				nodeGl.vertexAttribPointer(shader.location.texCoord, model.texCoord.size, nodeGl.FLOAT, false, 0, 0);
			}

			nodeGl.bindBuffer(nodeGl.ARRAY_BUFFER, model.vertex);
			nodeGl.vertexAttribPointer(shader.location.position, model.vertex.size, nodeGl.FLOAT, false, 0, 0);

			nodeGl.bindBuffer(nodeGl.ELEMENT_ARRAY_BUFFER, model.index);

			//default for depth is disable
			if (options && options.depth) {
				gl.enable(gl.DEPTH_TEST);
			} else {
				gl.disable(gl.DEPTH_TEST);
			}

			//default for blend is enable
			if (!options || options.blend === undefined || options.blend) {
				gl.enable(gl.BLEND);
				gl.blendFunc(
					options && options.srcRGB || gl.SRC_ALPHA,
					options && options.dstRGB || gl.ONE_MINUS_SRC_ALPHA
				);

				/*
				gl.blendFuncSeparate(
					options && options.srcRGB || gl.SRC_ALPHA,
					options && options.dstRGB || gl.ONE_MINUS_SRC_ALPHA,
					options && options.srcAlpha || gl.SRC_ALPHA,
					options && options.dstAlpha || gl.DST_ALPHA
				);
				*/
				gl.blendEquation(options && options.blendEquation || gl.FUNC_ADD);
			} else {
				gl.disable(gl.BLEND);
			}

			/* set uniforms to current values */
			for (name in uniforms) {
				if (uniforms.hasOwnProperty(name)) {
					value = uniforms[name];
					shaderUniform = shader.uniforms[name];
					if (shaderUniform) {
						if (value instanceof WebGLTexture) {
							nodeGl.activeTexture(nodeGl.TEXTURE0 + numTextures);
							nodeGl.bindTexture(nodeGl.TEXTURE_2D, value);
							shaderUniform.set(numTextures);
							numTextures++;
						} else if (value instanceof SourceNode ||
								value instanceof EffectNode ||
								value instanceof TransformNode) {
							if (value.texture) {
								nodeGl.activeTexture(nodeGl.TEXTURE0 + numTextures);
								nodeGl.bindTexture(nodeGl.TEXTURE_2D, value.texture);
								shaderUniform.set(numTextures);
								numTextures++;
							}
						} else if(value !== undefined && value !== null) {
							shaderUniform.set(value);
						}
					}
				}
			}

			//default for clear is true
			if (!options || options.clear === undefined || options.clear) {
				nodeGl.clearColor(0.0, 0.0, 0.0, 0.0);
				nodeGl.clear(nodeGl.COLOR_BUFFER_BIT | nodeGl.DEPTH_BUFFER_BIT);
			}

			// draw!
			nodeGl.drawElements(model.mode, model.length, nodeGl.UNSIGNED_SHORT, 0);

			//to protect other 3D libraries that may not remember to turn their depth tests on
			gl.enable(gl.DEPTH_TEST);
		}

		function findInputNode(source, options) {
			var node, i;

			if (source instanceof SourceNode ||
					source instanceof EffectNode ||
					source instanceof TransformNode) {
				node = source;
			} else if (source instanceof Effect ||
					source instanceof Source ||
					source instanceof Transform) {
				node = nodesById[source.id];

				if (!node) {
					throw 'Cannot connect a foreign node';
				}
			} else {
				if (typeof source === 'string' && isNaN(source)) {
					source = getElement(source, ['canvas', 'img', 'video']);
				}

				for (i = 0; i < sources.length; i++) {
					if (sources[i].source === source) {
						return sources[i];
					}
				}

				node = new SourceNode(source, options);
			}

			return node;
		}

		//trace back all sources to make sure we're not making a cyclical connection
		function traceSources(node, original) {
			var i,
				source,
				sources;

			if (!(node instanceof EffectNode) && !(node instanceof TransformNode)) {
				return false;
			}

			sources = node.sources;

			for (i in sources) {
				if (sources.hasOwnProperty(i)) {
					source = sources[i];

					if (source === original || traceSources(source, original)) {
						return true;
					}
				}
			}

			return false;
		}

		Node = function () {
			this.width = 1;
			this.height = 1;

			this.gl = gl;

			this.uniforms = {
				resolution: [this.width, this.height],
				transform: null
			};

			this.dirty = true;
			this.isDestroyed = false;

			this.seriously = seriously;

			this.id = nodeId;
			nodes.push(this);
			nodesById[nodeId] = this;
			nodeId++;
		};

		Node.prototype.setDirty = function () {
			//loop through all targets calling setDirty (depth-first)
			var i;

			if (!this.dirty) {
				this.dirty = true;
				if (this.targets) {
					for (i = 0; i < this.targets.length; i++) {
						this.targets[i].setDirty();
					}
				}
			}
		};

		Node.prototype.initFrameBuffer = function (useFloat) {
			if (gl) {
				this.frameBuffer = new FrameBuffer(gl, this.width, this.height, useFloat);
			}
		};

		Node.prototype.readPixels = function (x, y, width, height, dest) {

			if (!gl) {
				//todo: is this the best approach?
				throw 'Cannot read pixels until a canvas is connected';
			}

			//todo: check on x, y, width, height

			if (!this.frameBuffer) {
				this.initFrameBuffer();
			}

			//todo: should we render here?
			this.render();

			//todo: figure out formats and types
			if (dest === undefined) {
				dest = new Uint8Array(width * height * 4);
			} else if (!dest instanceof Uint8Array) {
				throw 'Incompatible array type';
			}

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer.frameBuffer); //todo: are we sure about this?
			gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, dest);

			return dest;
		};

		Node.prototype.resize = function () {
			var width,
				height;

			if (this.source) {
				width = this.source.width;
				height = this.source.height;
			} else if (this.sources && this.sources.source) {
				width = this.sources.source.width;
				height = this.sources.source.height;
			} else if (this.inputs && this.inputs.width) {
				width = this.inputs.width;
				height = this.inputs.height || width;
			} else if (this.inputs && this.inputs.height) {
				width = height = this.inputs.height;
			} else {
				//this node will be responsible for calculating its own size
				width = 1;
				height = 1;
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.setDirty();
			}

			if (this.uniforms && this.uniforms.resolution) {
				this.uniforms.resolution[0] = width;
				this.uniforms.resolution[1] = height;
			}

			if (this.frameBuffer && this.frameBuffer.resize) {
				this.frameBuffer.resize(width, height);
			}
		};

		Node.prototype.destroy = function () {
			var i;

			delete this.gl;
			delete this.seriously;

			//clear out uniforms
			for (i in this.uniforms) {
				if (this.uniforms.hasOwnProperty(i)) {
					delete this.uniforms[i];
				}
			}

			//clear out list of targets and disconnect each
			if (this.targets) {
				delete this.targets;
			}

			//clear out frameBuffer
			if (this.frameBuffer && this.frameBuffer.destroy) {
				this.frameBuffer.destroy();
				delete this.frameBuffer;
			}

			//remove from main nodes index
			i = nodes.indexOf(this);
			if (i >= 0) {
				nodes.splice(i, 1);
			}
			delete nodesById[this.id];

			this.isDestroyed = true;
		};

		Effect = function (effectNode) {
			var name, me = effectNode;

			function arrayToHex(color) {
				var i, val, s = '#';
				for (i = 0; i < 4; i++) {
					val = Math.min(255, Math.round(color[i] * 255 || 0));
					s += val.toString(16);
				}
				return s;
			}

			function setInput(inputName, input) {
				var lookup, value, effectInput, i;

				effectInput = me.effect.inputs[inputName];

				lookup = me.inputElements[inputName];

				if (typeof input === 'string' && isNaN(input)) {
					if (effectInput.type === 'enum') {
						if (effectInput.options && effectInput.options.filter) {
							i = String(input).toLowerCase();
							value = effectInput.options.filter(function (e) {
								return (typeof e === 'string' && e.toLowerCase() === i) ||
									(e.length && typeof e[0] === 'string' && e[0].toLowerCase() === i);
							});

							value = value.length;
						}

						if (!value) {
							input = getElement(input, ['select']);
						}

					} else if (effectInput.type === 'number' || effectInput.type === 'boolean') {
						input = getElement(input, ['input', 'select']);
					} else if (effectInput.type === 'image') {
						input = getElement(input, ['canvas', 'img', 'video']);
					}
					//todo: color? date/time?
				}

				if (input instanceof HTMLInputElement || input instanceof HTMLSelectElement) {
					value = input.value;

					if (lookup && lookup.element !== input) {
						lookup.element.removeEventListener('change', lookup.listener, true);
						lookup.element.removeEventListener('input', lookup.listener, true);
						delete me.inputElements[inputName];
						lookup = null;
					}

					if (!lookup) {
						lookup = {
							element: input,
							listener: (function (name, element) {
								return function () {
									var oldValue, newValue;

									if (input.type === 'checkbox') {
										//special case for check box
										oldValue = input.checked;
									} else {
										oldValue = element.value;
									}
									newValue = me.setInput(name, oldValue);

									//special case for color type
									if (effectInput.type === 'color') {
										newValue = arrayToHex(newValue);
									}

									//if input validator changes our value, update HTML Element
									//todo: make this optional...somehow
									if (newValue !== oldValue) {
										element.value = newValue;
									}
								};
							}(inputName, input))
						};

						me.inputElements[inputName] = lookup;
						if (input.type === 'range') {
							input.addEventListener('input', lookup.listener, true);
							input.addEventListener('change', lookup.listener, true);
						} else {
							input.addEventListener('change', lookup.listener, true);
						}
					}

					if (lookup && input.type === 'checkbox') {
						value = input.checked;
					}
				} else {
					if (lookup) {
						lookup.element.removeEventListener('change', lookup.listener, true);
						lookup.element.removeEventListener('input', lookup.listener, true);
						delete me.inputElements[inputName];
					}
					value = input;
				}

				me.setInput(inputName, value);
				return me.inputs[inputName];
			}

			function makeImageSetter(inputName) {
				return function (value) {
					var val = setInput(inputName, value);
					return val && val.pub;
				};
			}

			function makeImageGetter(inputName) {
				return function () {
					var val = me.inputs[inputName];
					return val && val.pub;
				};
			}

			function makeSetter(inputName) {
				return function (value) {
					return setInput(inputName, value);
				};
			}

			function makeGetter(inputName) {
				return function () {
					return me.inputs[inputName];
				};
			}

			//priveleged publicly accessible methods/setters/getters
			//todo: provide an alternate method
			for (name in me.effect.inputs) {
				if (me.effect.inputs.hasOwnProperty(name)) {
					if (this[name] === undefined) {
						if (me.effect.inputs[name].type === 'image') {
							Object.defineProperty(this, name, {
								configurable: true,
								enumerable: true,
								get: makeImageGetter(name),
								set: makeImageSetter(name)
							});
						} else {
							Object.defineProperty(this, name, {
								configurable: true,
								enumerable: true,
								get: makeGetter(name),
								set: makeSetter(name)
							});
						}
					} else {
						//todo: this is temporary. get rid of it.
						throw 'Cannot overwrite Seriously.' + name;
					}
				}
			}

			Object.defineProperties(this, {
				inputs: {
					enumerable: true,
					configurable: true,
					get: function () {
						return {
							source: {
								type: 'image'
							}
						};
					}
				},
				original: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.source;
					}
				},
				width: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.width;
					}
				},
				height: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.height;
					}
				},
				id: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.id;
					}
				}
			});

			this.render = function () {
				me.render();
				return this;
			};

			this.readPixels = function (x, y, width, height, dest) {
				return me.readPixels(x, y, width, height, dest);
			};

			this.alias = function (inputName, aliasName) {
				me.alias(inputName, aliasName);
				return this;
			};

			this.matte = function (polygons) {
				me.matte(polygons);
			};

			this.destroy = function () {
				var i,
					descriptor;

				me.destroy();

				for (i in this) {
					if (this.hasOwnProperty(i) && i !== 'isDestroyed') {
						descriptor = Object.getOwnPropertyDescriptor(this, i);
						if (descriptor.get || descriptor.set ||
								typeof this[i] !== 'function') {
							delete this[i];
						} else {
							this[i] = nop;
						}
					}
				}
			};

			this.isDestroyed = function () {
				return me.isDestroyed;
			};
		};

		EffectNode = function (hook, options) {
			var key, name, input;

			Node.call(this, options);

			this.effectRef = seriousEffects[hook];
			this.sources = {};
			this.targets = [];
			this.inputElements = {};
			this.dirty = true;
			this.shaderDirty = true;
			this.hook = hook;
			this.options = options;
			this.transform = null;

			if (this.effectRef.definition) {
				this.effect = this.effectRef.definition.call(this, options);
				/*
				todo: copy over inputs object separately in case some are specified
				in advance and some are specified in definition function
				*/
				for (key in this.effectRef) {
					if (this.effectRef.hasOwnProperty(key) && !this.effect[key]) {
						this.effect[key] = this.effectRef[key];
					}
				}
				if (this.effect.inputs !== this.effectRef.inputs) {
					validateInputSpecs(this.effect);
				}
			} else {
				this.effect = extend({}, this.effectRef);
			}

			//todo: set up frame buffer(s), inputs, transforms, stencils, draw method. allow plugin to override

			this.uniforms.transform = identity;
			this.inputs = {};
			for (name in this.effect.inputs) {
				if (this.effect.inputs.hasOwnProperty(name)) {
					input = this.effect.inputs[name];

					this.inputs[name] = input.defaultValue;
					if (input.uniform) {
						this.uniforms[input.uniform] = input.defaultValue;
					}
				}
			}

			if (gl) {
				this.buildShader();
			}

			this.inPlace = this.effect.inPlace;

			this.pub = new Effect(this);

			effects.push(this);

			allEffectsByHook[hook].push(this);
		};

		extend(EffectNode, Node);

		EffectNode.prototype.initialize = function () {
			if (!this.initialized) {
				var that = this;

				if (this.shape) {
					this.model = makeGlModel(this.shape, this.gl);
				} else {
					this.model = rectangleModel;
				}

				if (typeof this.effect.initialize === 'function') {
					this.effect.initialize.call(this, function () {
						that.initFrameBuffer(true);
					}, gl);
				} else {
					this.initFrameBuffer(true);
				}

				if (this.frameBuffer) {
					this.texture = this.frameBuffer.texture;
				}

				this.initialized = true;
			}
		};

		EffectNode.prototype.resize = function () {
			var i;

			Node.prototype.resize.call(this);

			if (this.effect.resize) {
				this.effect.resize.call(this);
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		EffectNode.prototype.setTarget = function (target) {
			var i;
			for (i = 0; i < this.targets.length; i++) {
				if (this.targets[i] === target) {
					return;
				}
			}

			this.targets.push(target);
		};

		EffectNode.prototype.removeTarget = function (target) {
			var i = this.targets && this.targets.indexOf(target);
			if (i >= 0) {
				this.targets.splice(i, 1);
			}
		};

		EffectNode.prototype.removeSource = function (source) {
			var i, pub = source && source.pub;

			for (i in this.inputs) {
				if (this.inputs.hasOwnProperty(i) &&
					(this.inputs[i] === source || this.inputs[i] === pub)) {
					this.inputs[i] = null;
				}
			}

			for (i in this.sources) {
				if (this.sources.hasOwnProperty(i) &&
					(this.sources[i] === source || this.sources[i] === pub)) {
					this.sources[i] = null;
				}
			}
		};

		EffectNode.prototype.buildShader = function () {
			var shader, effect = this.effect;
			if (this.shaderDirty) {
				if (effect.shader) {
					shader = effect.shader.call(this, this.inputs, {
						vertex: baseVertexShader,
						fragment: baseFragmentShader
					}, Seriously.util);

					if (shader instanceof ShaderProgram) {
						this.shader = shader;
					} else if (shader && shader.vertex && shader.fragment) {
						this.shader = new ShaderProgram(gl, shader.vertex, shader.fragment);
					} else {
						this.shader = baseShader;
					}
				} else {
					this.shader = baseShader;
				}

				this.shaderDirty = false;
			}
		};

		EffectNode.prototype.render = function () {
			var i,
				frameBuffer,
				effect = this.effect,
				that = this,
				inPlace;

			function drawFn(shader, model, uniforms, frameBuffer, node, options) {
				draw(shader, model, uniforms, frameBuffer, node || that, options);
			}

			if (!this.initialized) {
				this.initialize();
			}

			if (this.shaderDirty) {
				this.buildShader();
			}

			if (this.dirty) {
				for (i in this.sources) {
					if (this.sources.hasOwnProperty(i) &&
						(!effect.requires || effect.requires.call(this, i, this.inputs))) {

						//todo: set source texture
						//sourcetexture = this.sources[i].render() || this.sources[i].texture

						inPlace = typeof this.inPlace === 'function' ? this.inPlace(i) : this.inPlace;
						this.sources[i].render(!inPlace);
					}
				}

				if (this.frameBuffer) {
					frameBuffer = this.frameBuffer.frameBuffer;
				}

				if (typeof effect.draw === 'function') {
					effect.draw.call(this, this.shader, this.model, this.uniforms, frameBuffer, drawFn);
				} else if (frameBuffer) {
					draw(this.shader, this.model, this.uniforms, frameBuffer, this);
				}

				this.dirty = false;
			}

			return this.texture;
		};

		EffectNode.prototype.setInput = function (name, value) {
			var input, uniform,
				sourceKeys,
				source;

			if (this.effect.inputs.hasOwnProperty(name)) {
				input = this.effect.inputs[name];
				if (input.type === 'image') {
					//&& !(value instanceof Effect) && !(value instanceof Source)) {

					if (value) {
						value = findInputNode(value);

						if (value !== this.sources[name]) {
							if (this.sources[name]) {
								this.sources[name].removeTarget(this);
							}

							if (traceSources(value, this)) {
								throw 'Attempt to make cyclical connection.';
							}

							this.sources[name] = value;
							value.setTarget(this);
						}
					} else {
						delete this.sources[name];
						value = false;
					}

					uniform = this.sources[name];

					sourceKeys = Object.keys(this.sources);
					if (this.inPlace === true && sourceKeys.length === 1) {
						source = this.sources[sourceKeys[0]];
						this.uniforms.transform = source && source.cumulativeMatrix || identity;
					} else {
						this.uniforms.transform = identity;
					}

					this.resize();
				} else {
					value = input.validate.call(this, value, input, this.inputs[name]);
					uniform = value;
				}

				if (this.inputs[name] === value && input.type !== 'color' && input.type !== 'vector') {
					return value;
				}

				this.inputs[name] = value;

				if (input.uniform) {
					this.uniforms[input.uniform] = uniform;
				}

				if (input.shaderDirty) {
					this.shaderDirty = true;
				}

				this.setDirty();

				if (input.update) {
					input.update.call(this, value);
				}

				return value;
			}
		};

		EffectNode.prototype.alias = function (inputName, aliasName) {
			var that = this;

			if (reservedNames.indexOf(aliasName) >= 0) {
				throw aliasName + ' is a reserved name and cannot be used as an alias.';
			}

			if (this.effect.inputs.hasOwnProperty(inputName)) {
				if (!aliasName) {
					aliasName = inputName;
				}

				seriously.removeAlias(aliasName);

				aliases[aliasName] = {
					node: this,
					input: inputName
				};

				Object.defineProperty(seriously, aliasName, {
					configurable: true,
					enumerable: true,
					get: function () {
						return that.inputs[inputName];
					},
					set: function (value) {
						return that.setInput(inputName, value);
					}
				});
			}

			return this;
		};

		/*
		matte function to be assigned as a method to EffectNode and TargetNode
		*/
		EffectNode.prototype.matte = function (poly) {
			var polys,
				polygons = [],
				polygon,
				vertices = [],
				i, j, v,
				vert, prev,
				//triangles = [],
				shape = {};

			//detect whether it's multiple polygons or what
			function makePolygonsArray(poly) {
				if (!poly || !poly.length || !Array.isArray(poly)) {
					return [];
				}

				if (!Array.isArray(poly[0])) {
					return [poly];
				}

				if (Array.isArray(poly[0]) && !isNaN(poly[0][0])) {
					return [poly];
				}

				return poly;
			}

			function linesIntersect(a1, a2, b1, b2) {
				var ua_t, ub_t, u_b, ua, ub;
				ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
				ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
				u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
				if (u_b) {
					ua = ua_t / u_b;
					ub = ub_t / u_b;
					if (ua > 0 && ua <= 1 && ub > 0 && ub <= 1) {
						return {
							x: a1.x + ua * (a2.x - a1.x),
							y: a1.y + ua * (a2.y - a1.y)
						};
					}
				}
				return false;
			}

			function makeSimple(poly) {
				/*
				this uses a slow, naive approach to detecting line intersections.
				Use Bentley-Ottmann Algorithm
				see: http://softsurfer.com/Archive/algorithm_0108/algorithm_0108.htm#Bentley-Ottmann Algorithm
				see: https://github.com/tokumine/sweepline
				*/
				var i, j,
					edge1, edge2,
					intersect,
					intersections = [],
					newPoly,
					head, point,
					newPolygons,
					point1, point2;

				if (poly.simple) {
					return;
				}

				for (i = 0; i < poly.edges.length; i++) {
					edge1 = poly.edges[i];
					for (j = i + 1; j < poly.edges.length; j++) {
						edge2 = poly.edges[j];
						intersect = linesIntersect(edge1[0], edge1[1], edge2[0], edge2[1]);
						if (intersect) {
							intersect.edge1 = edge1;
							intersect.edge2 = edge2;
							intersections.push(intersect);
						}
					}
				}

				if (intersections.length) {
					newPolygons = [];

					for (i = 0; i < intersections.length; i++) {
						intersect = intersections[i];
						edge1 = intersect.edge1;
						edge2 = intersect.edge2;

						//make new points
						//todo: set ids for points
						point1 = {
							x: intersect.x,
							y: intersect.y,
							prev: edge1[0],
							next: edge2[1],
							id: vertices.length
						};
						poly.vertices.push(point1);
						vertices.push(point1);

						point2 = {
							x: intersect.x,
							y: intersect.y,
							prev: edge2[0],
							next: edge1[1],
							id: vertices.length
						};
						poly.vertices.push(point2);
						vertices.push(point1);

						//modify old points
						point1.prev.next = point1;
						point1.next.prev = point1;
						point2.prev.next = point2;
						point2.next.prev = point2;

						//don't bother modifying the old edges. we're just gonna throw them out
					}

					//make new polygons
					do {
						newPoly = {
							edges: [],
							vertices: [],
							simple: true
						};
						newPolygons.push(newPoly);
						point = poly.vertices[0];
						head = point;
						//while (point.next !== head && poly.vertices.length) {
						do {
							i = poly.vertices.indexOf(point);
							poly.vertices.splice(i, 1);
							newPoly.edges.push([point, point.next]);
							newPoly.vertices.push(point);
							point = point.next;
						} while (point !== head);
					} while (poly.vertices.length);

					//remove original polygon from list
					i = polygons.indexOf(poly);
					polygons.splice(i, 1);

					//add new polygons to list
					for (i = 0; i < newPolygons.length; i++) {
						polygons.push(newPolygons[i]);
					}
				} else {
					poly.simple = true;
				}
			}

			function clockWise(poly) {
				var p, q, n = poly.vertices.length,
					pv, qv, sum = 0;
				for (p = n - 1, q = 0; q < n; p = q, q++) {
					pv = poly.vertices[p];
					qv = poly.vertices[q];
					//sum += (next.x - v.x) * (next.y + v.y);
					//sum += (v.next.x + v.x) * (v.next.y - v.y);
					sum += pv.x * qv.y - qv.x * pv.y;
				}
				return sum > 0;
			}

			function triangulate(poly) {
				var v, points = poly.vertices,
					n, V = [], indices = [],
					nv, count, m, u, w,

					//todo: give these variables much better names
					a, b, c, s, t;

				function pointInTriangle(a, b, c, p) {
					var ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy,
						cXap, bXcp, aXbp;

					ax = c.x - b.x;
					ay = c.y - b.y;
					bx = a.x - c.x;
					by = a.y - c.y;
					cx = b.x - a.x;
					cy = b.y - a.y;
					apx = p.x - a.x;
					apy = p.y - a.y;
					bpx = p.x - b.x;
					bpy = p.y - b.y;
					cpx = p.x - c.x;
					cpy = p.y - c.y;

					aXbp = ax * bpy - ay * bpx;
					cXap = cx * apy - cy * apx;
					bXcp = bx * cpy - by * cpx;

					return aXbp >= 0 && bXcp >=0 && cXap >=0;
				}

				function snip(u, v, w, n, V) {
					var p, a, b, c, point;
					a = points[V[u]];
					b = points[V[v]];
					c = points[V[w]];
					if (0 > (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) {
						return false;
					}
					for (p = 0; p < n; p++) {
						if (!(p === u || p === v || p === w)) {
							point = points[V[p]];
							if (pointInTriangle(a, b, c, point)) {
								return false;
							}
						}
					}
					return true;
				}

				//copy points
				//for (v = 0; v < poly.vertices.length; v++) {
				//	points.push(poly.vertices[v]);
				//}
				n = points.length;

				if (poly.clockWise) {
					for (v = 0; v < n; v++) {
						V[v] = v;
					}
				} else {
					for (v = 0; v < n; v++) {
						V[v] = (n - 1) - v;
					}
				}

				nv = n;
				count = 2 * nv;
				m = 0;
				v = nv - 1;
				while (nv > 2) {
					if ((count--) <= 0) {
						return indices;
					}

					u = v;
					if (nv <= u) {
						u = 0;
					}

					v = u + 1;
					if (nv <= v) {
						v = 0;
					}

					w = v + 1;
					if (nv < w) {
						w = 0;
					}

					if (snip(u, v, w, nv, V)) {
						a = V[u];
						b = V[v];
						c = V[w];
						if (poly.clockWise) {
							indices.push(points[a]);
							indices.push(points[b]);
							indices.push(points[c]);
						} else {
							indices.push(points[c]);
							indices.push(points[b]);
							indices.push(points[a]);
						}
						m++;
						for (s = v, t = v + 1; t < nv; s++, t++) {
							V[s] = V[t];
						}
						nv--;
						count = 2 * nv;
					}
				}

				polygon.indices = indices;
			}

			polys = makePolygonsArray(poly);

			for (i = 0; i < polys.length; i++) {
				poly = polys[i];
				prev = null;
				polygon = {
					vertices: [],
					edges: []
				};

				for (j = 0; j < poly.length; j++) {
					v = poly[j];
					if (typeof v ==='object' && !isNaN(v.x) && !isNaN(v.y)) {
						vert = {
							x: v.x,
							y: v.y,
							id: vertices.length
						};
					} else if (v.length >= 2 && !isNaN(v[0]) && !isNaN(v[1])) {
						vert = {
							x: v[0],
							y: v[1],
							id: vertices.length
						};
					}
					if (vert) {
						if (prev) {
							prev.next = vert;
							vert.prev = prev;
							vert.next = polygon.vertices[0];
							polygon.vertices[0].prev = vert;
						} else {
							polygon.head = vert;
							vert.next = vert;
							vert.prev = vert;
						}
						vertices.push(vert);
						polygon.vertices.push(vert);
						prev = vert;
					}
				}

				if (polygon.vertices.length > 2) {
					if (polygon.vertices.length === 3) {
						polygon.simple = true;
					}

					polygons.push(polygon);

					//save edges
					for (j = 0; j < polygon.vertices.length; j++) {
						vert = polygon.vertices[j];
						polygon.edges.push([
							vert, vert.next
						]);
					}
				}
			}

			for (i = polygons.length - 1; i >= 0; i--) {
				polygon = polygons[i];
				makeSimple(polygon);
			}

			for (i = 0; i < polygons.length; i++) {
				polygon = polygons[i];
				polygon.clockWise = clockWise(polygon);
				triangulate(polygon);
			}

			//build shape
			shape.vertices = [];
			shape.coords = [];
			for (i = 0; i < vertices.length; i++) {
				v = vertices[i];
				shape.vertices.push(v.x * 2 - 1);
				shape.vertices.push(v.y * -2 + 1);
				shape.vertices.push(-1);

				shape.coords.push(v.x);
				shape.coords.push(v.y * -1 + 1);
			}
			shape.vertices = new Float32Array(shape.vertices);
			shape.coords = new Float32Array(shape.coords);

			shape.indices = [];
			for (i = 0; i < polygons.length; i++) {
				polygon = polygons[i];
				for (j = 0; j < polygon.indices.length; j++) {
					v = polygon.indices[j];
					shape.indices.push(v.id);
					//shape.indices.push(v[1].id);
					//shape.indices.push(v[2].id);
				}
			}
			shape.indices = new Uint16Array(shape.indices);

			this.shape = shape;
			if (this.gl) {
				makeGlModel(shape, this.gl);
			}
		};

		EffectNode.prototype.destroy = function () {
			var i, key, item, hook = this.hook;

			//let effect destroy itself
			if (this.effect.destroy && typeof this.effect.destroy === 'function') {
				this.effect.destroy.call(this);
			}
			delete this.effect;

			//shader
			if (this.shader && this.shader.destroy && this.shader !== baseShader) {
				this.shader.destroy();
			}
			delete this.shader;

			//stop watching any input elements
			for (key in this.inputElements) {
				if (this.inputElements.hasOwnProperty(key)) {
					item = this.inputElements[key];
					item.element.removeEventListener('change', item.listener, true);
					item.element.removeEventListener('input', item.listener, true);
				}
			}

			//sources
			for (key in this.sources) {
				if (this.sources.hasOwnProperty(key)) {
					item = this.sources[key];
					if (item && item.removeTarget) {
						item.removeTarget(this);
					}
					delete this.sources[key];
				}
			}

			//targets
			while (this.targets.length) {
				item = this.targets.pop();
				if (item && item.removeSource) {
					item.removeSource(this);
				}
			}

			for (i in this) {
				if (this.hasOwnProperty(key) && key !== 'id') {
					delete this[key];
				}
			}

			//remove any aliases
			for (key in aliases) {
				if (aliases.hasOwnProperty(key)) {
					item = aliases[key];
					if (item.node === this) {
						seriously.removeAlias(key);
					}
				}
			}

			//remove self from master list of effects
			i = effects.indexOf(this);
			if (i >= 0) {
				effects.splice(i, 1);
			}

			i = allEffectsByHook[hook].indexOf(this);
			if (i >= 0) {
				allEffectsByHook[hook].splice(i, 1);
			}

			Node.prototype.destroy.call(this);
		};

		Source = function (sourceNode) {
			var me = sourceNode;

			//priveleged accessor methods
			Object.defineProperties(this, {
				original: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.source;
					}
				},
				id: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.id;
					}
				}
			});

			this.render = function () {
				me.render();
			};

			this.update = function () {
				me.setDirty();
			};

			this.readPixels = function (x, y, width, height, dest) {
				return me.readPixels(x, y, width, height, dest);
			};

			this.destroy = function () {
				var i,
					descriptor;

				me.destroy();

				for (i in this) {
					if (this.hasOwnProperty(i) && i !== 'isDestroyed') {
						descriptor = Object.getOwnPropertyDescriptor(this, i);
						if (descriptor.get || descriptor.set ||
								typeof this[i] !== 'function') {
							delete this[i];
						} else {
							this[i] = nop;
						}
					}
				}
			};

			this.isDestroyed = function () {
				return me.isDestroyed;
			};
		};

		/*
			possible sources: img, video, canvas (2d or 3d), texture, ImageData, array, typed array
		*/
		SourceNode = function (source, options) {
			var opts = options || {},
				flip = opts.flip === undefined ? true : opts.flip,
				width = opts.width,
				height = opts.height,
				deferTexture = false,
				that = this,
				matchedType = false;

			Node.call(this);

			if (typeof source === 'string' && isNaN(source)) {
				source = getElement(source, ['canvas', 'img', 'video']);
			}

			if (source instanceof HTMLElement) {
				if (source.tagName === 'CANVAS') {
					this.width = source.width;
					this.height = source.height;

					this.render = this.renderImageCanvas;
				} else if (source.tagName === 'IMG') {
					this.width = source.naturalWidth || 1;
					this.height = source.naturalHeight || 1;

					if (!source.complete) {
						deferTexture = true;

						source.addEventListener('load', function () {
							that.width = source.naturalWidth;
							that.height = source.naturalHeight;
							that.resize();
							that.initialize();
						}, true);
					}

					this.render = this.renderImageCanvas;
				} else if (source.tagName === 'VIDEO') {
					this.width = source.videoWidth || 1;
					this.height = source.videoHeight || 1;

					if (!source.readyState) {
						deferTexture = true;

						source.addEventListener('loadedmetadata', function () {
							that.width = source.videoWidth;
							that.height = source.videoHeight;
							that.resize();
							that.initialize();
						}, true);
					}

					this.render = this.renderVideo;
				} else {
					throw 'Not a valid HTML element: ' + source.tagName + ' (must be img, video or canvas)';
				}
				matchedType = true;

			} else if (source instanceof Object && source.data &&
				source.width && source.height &&
				source.width * source.height * 4 === source.data.length
				) {

				//Because of this bug, Firefox doesn't recognize ImageData, so we have to duck type
				//https://bugzilla.mozilla.org/show_bug.cgi?id=637077

				this.width = source.width;
				this.height = source.height;
				matchedType = true;

				this.render = this.renderImageCanvas;
			} else if (isArrayLike(source)) {
				if (!width || !height) {
					throw 'Height and width must be provided with an Array';
				}

				if (width * height * 4 !== source.length) {
					throw 'Array length must be height x width x 4.';
				}

				this.width = width;
				this.height = height;

				matchedType = true;

				//use opposite default for flip
				if (opts.flip === undefined) {
					flip = false;
				}

				if (!(source instanceof Uint8Array)) {
					source = new Uint8Array(source);
				}
				this.render = this.renderTypedArray;
			} else if (source instanceof WebGLTexture) {
				if (gl && !gl.isTexture(source)) {
					throw 'Not a valid WebGL texture.';
				}

				//different defaults
				if (!isNaN(width)) {
					if (isNaN(height)) {
						height = width;
					}
				} else if (!isNaN(height)) {
					width = height;
				}/* else {
					//todo: guess based on dimensions of target canvas
					//throw 'Must specify width and height when using a WebGL texture as a source';
				}*/

				this.width = width;
				this.height = height;

				if (opts.flip === undefined) {
					flip = false;
				}
				matchedType = true;

				this.texture = source;
				this.initialized = true;

				//todo: if WebGLTexture source is from a different context render it and copy it over
				this.render = function () {};
			}

			if (!matchedType) {
				throw 'Unknown source type';
			}

			this.source = source;
			this.flip = flip;

			this.targets = [];

			if (!deferTexture) {
				this.resize();
				this.initialize();
			}

			this.pub = new Source(this);

			sources.push(this);

			if (sources.length && !rafId) {
				renderDaemon();
			}
		};

		extend(SourceNode, Node);

		SourceNode.prototype.initialize = function () {
			if (!gl || this.texture) {
				return;
			}

			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindTexture(gl.TEXTURE_2D, null);

			this.texture = texture;
			this.initialized = true;
			this.allowRefresh = true;
			this.setDirty();
		};

		SourceNode.prototype.initFrameBuffer = function (useFloat) {
			if (gl) {
				this.frameBuffer = new FrameBuffer(gl, this.width, this.height, {
					texture: this.texture,
					useFloat: useFloat
				});
			}
		};

		SourceNode.prototype.setTarget = function (target) {
			var i;
			for (i = 0; i < this.targets.length; i++) {
				if (this.targets[i] === target) {
					return;
				}
			}

			this.targets.push(target);
		};

		SourceNode.prototype.removeTarget = function (target) {
			var i = this.targets && this.targets.indexOf(target);
			if (i >= 0) {
				this.targets.splice(i, 1);
			}
		};

		SourceNode.prototype.resize = function () {
			var i,
				target;

			this.uniforms.resolution[0] = this.width;
			this.uniforms.resolution[1] = this.height;

			if (this.framebuffer) {
				this.framebuffer.resize(this.width, this.height);
			}

			this.setDirty();

			for (i = 0; i < this.targets.length; i++) {
				target = this.targets[i];
				target.resize();
				if (target.setTransformDirty) {
					target.setTransformDirty();
				}
			}
		};

		SourceNode.prototype.renderVideo = function () {
			var video = this.source;

			if (!gl || !video || !video.videoHeight || !video.videoWidth || video.readyState < 2) {
				return;
			}

			if (!this.initialized) {
				this.initialize();
			}

			if (!this.allowRefresh) {
				return;
			}

			if (this.dirty ||
				this.lastRenderFrame !== video.mozPresentedFrames ||
				this.lastRenderTime !== video.currentTime) {

				gl.bindTexture(gl.TEXTURE_2D, this.texture);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flip);
				try {
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
				} catch (securityError) {
					if (securityError.name === 'SECURITY_ERR') {
						this.allowRefresh = false;
						console.log('Unable to access cross-domain image');
					}
				}

				// Render a few extra times because the canvas takes a while to catch up
				if (Date.now() - 100 > this.lastRenderTimeStamp) {
					this.lastRenderTime = video.currentTime;
				}
				this.lastRenderFrame = video.mozPresentedFrames;
				this.lastRenderTimeStamp = Date.now();
				this.dirty = false;
			}
		};

		SourceNode.prototype.renderImageCanvas = function () {
			var media = this.source;

			if (!gl || !media || !media.height || !media.width) {
				return;
			}

			if (!this.initialized) {
				this.initialize();
			}

			if (!this.allowRefresh) {
				return;
			}

			if (this.dirty) {
				gl.bindTexture(gl.TEXTURE_2D, this.texture);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flip);
				try {
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, media);
				} catch (securityError) {
					if (securityError.name === 'SECURITY_ERR') {
						this.allowRefresh = false;
						console.log('Unable to access cross-domain image');
					}
				}

				this.lastRenderTime = Date.now() / 1000;
				this.dirty = false;
			}
		};

		SourceNode.prototype.renderTypedArray = function () {
			var media = this.source;

			if (!gl || !media || !media.length) {
				return;
			}

			if (!this.initialized) {
				this.initialize();
			}

			//this.currentTime = media.currentTime || 0;

			if (!this.allowRefresh) {
				return;
			}

			if (this.dirty) {
				gl.bindTexture(gl.TEXTURE_2D, this.texture);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flip);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, media);

				this.lastRenderTime = Date.now() / 1000;
				this.dirty = false;
			}
		};

		SourceNode.prototype.destroy = function () {
			var i, key, item;

			if (this.gl && this.texture) {
				this.gl.deleteTexture(this.texture);
			}

			//targets
			while (this.targets.length) {
				item = this.targets.pop();
				if (item && item.removeSource) {
					item.removeSource(this);
				}
			}

			//remove self from master list of sources
			i = sources.indexOf(this);
			if (i >= 0) {
				sources.splice(i, 1);
			}

			for (key in this) {
				if (this.hasOwnProperty(key) && key !== 'id') {
					delete this[key];
				}
			}

			Node.prototype.destroy.call(this);
		};

		//todo: implement render for array and typed array

		Target = function (targetNode) {
			var me = targetNode;

			//priveleged accessor methods
			Object.defineProperties(this, {
				inputs: {
					enumerable: true,
					configurable: true,
					get: function () {
						return {
							source: {
								type: 'image'
							}
						};
					}
				},
				source: {
					enumerable: true,
					configurable: true,
					get: function () {
						if (me.source) {
							return me.source.pub;
						}
					},
					set: function (value) {
						me.setSource(value);
					}
				},
				original: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.target;
					}
				},
				width: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.width;
					},
					set: function (value) {
						if (!isNaN(value) && value >0 && me.width !== value) {
							me.width = me.desiredWidth = value;
							me.target.width = value;

							me.setTransformDirty();
							/*
							if (this.source && this.source.resize) {
								this.source.resize(value);

								//todo: for secondary webgl nodes, we need a new array
								//if (this.pixels && this.pixels.length !== (this.width * this.height * 4)) {
								//	delete this.pixels;
								//}
							}
							*/
						}
					}
				},
				height: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.height;
					},
					set: function (value) {
						if (!isNaN(value) && value >0 && me.height !== value) {
							me.height = me.desiredHeight = value;
							me.target.height = value;

							me.setTransformDirty();

							/*
							if (this.source && this.source.resize) {
								this.source.resize(undefined, value);

								//for secondary webgl nodes, we need a new array
								//if (this.pixels && this.pixels.length !== (this.width * this.height * 4)) {
								//	delete this.pixels;
								//}
							}
							*/
						}
					}
				},
				id: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.id;
					}
				}
			});

			this.render = function () {
				me.render();
			};

			this.readPixels = function (x, y, width, height, dest) {
				return me.readPixels(x, y, width, height, dest);
			};

			this.go = function (options) {
				me.go(options);
			};

			this.stop = function () {
				me.stop();
			};

			this.getTexture = function () {
				return me.frameBuffer.texture;
			};

			this.destroy = function () {
				var i,
					descriptor;

				me.destroy();

				for (i in this) {
					if (this.hasOwnProperty(i) && i !== 'isDestroyed') {
						descriptor = Object.getOwnPropertyDescriptor(this, i);
						if (descriptor.get || descriptor.set ||
								typeof this[i] !== 'function') {
							delete this[i];
						} else {
							this[i] = nop;
						}
					}
				}
			};

			this.isDestroyed = function () {
				return me.isDestroyed;
			};
		};

		/*
			possible targets: canvas (2d or 3d), gl render buffer (must be same canvas)
		*/
		TargetNode = function (target, options) {
			var opts = options || {},
				flip = opts.flip === undefined ? true : opts.flip,
				width = parseInt(opts.width, 10),
				height = parseInt(opts.height, 10),
				matchedType = false,
				i, element, elements, context,
				frameBuffer;

			Node.call(this, opts);

			this.renderToTexture = opts.renderToTexture;

			if (typeof target === 'string') {
				elements = document.querySelectorAll(target);

				for (i = 0; i < elements.length; i++) {
					element = elements[i];
					if (element.tagName === 'CANVAS') {
						break;
					}
				}

				if (i >= elements.length) {
					throw 'not a valid HTML element (must be image, video or canvas)';
				}

				target = element;
			} else if (target instanceof WebGLFramebuffer) {

				frameBuffer = target;

				if (opts instanceof HTMLCanvasElement) {
					target = opts;
				} else if (opts instanceof WebGLRenderingContext) {
					target = opts.canvas;
				} else if (opts.canvas instanceof HTMLCanvasElement) {
					target = opts.canvas;
				} else if (opts.context instanceof WebGLRenderingContext) {
					target = opts.context.canvas;
				} else {
					//todo: search all canvases for matching contexts?
					throw "Must provide a canvas with WebGLFramebuffer target";
				}
			}

			if (target instanceof HTMLElement && target.tagName === 'CANVAS') {
				width = target.width;
				height = target.height;

				//todo: try to get a webgl context. if not, get a 2d context, and set up a different render function
				try {
					if (window.WebGLDebugUtils) {
						context = window.WebGLDebugUtils.makeDebugContext(target.getContext('experimental-webgl', {
							alpha: true,
							premultipliedAlpha: false,
							preserveDrawingBuffer: true,
							stencil: true
						}));
					} else {
						context = target.getContext('experimental-webgl', {
							alpha: true,
							premultipliedAlpha: false,
							preserveDrawingBuffer: true,
							stencil: true
						});
					}
				} catch (expError) {
				}

				if (!context) {
					try {
						context = target.getContext('webgl', {
							alpha: true,
							premultipliedAlpha: false,
							preserveDrawingBuffer: true,
							stencil: true
						});
					} catch (error) {

					}
				}

				if (!context) {
					context = target.getContext('2d');
					//todo: set up ImageData and alternative drawing method (or drawImage)
					this.render = this.render2D;
					this.use2D = true;
				} else if (!gl || gl === context) {
					//this is our main WebGL canvas
					if (!gl) {
						attachContext(context);
					}
					this.render = this.renderWebGL;
					if (opts.renderToTexture) {
						this.frameBuffer = new FrameBuffer(gl, width, height, false);
					} else {
						this.frameBuffer = {
							frameBuffer: frameBuffer || null
						};
					}
				} else if (context !== gl) {
					//set up alternative drawing method using ArrayBufferView
					this.gl = context;
					//this.pixels = new Uint8Array(width * height * 4);
					//todo: probably need another framebuffer for renderToTexture
					if (frameBuffer) {
						this.frameBuffer = {
							frameBuffer: frameBuffer
						};
					} else {
						this.frameBuffer = new FrameBuffer(this.gl, width, height, false);
					}
					this.shader = new ShaderProgram(this.gl, baseVertexShader, baseFragmentShader);
					this.model = buildRectangleModel.call(this, this.gl);

					this.texture = this.gl.createTexture();
					this.gl.bindTexture(gl.TEXTURE_2D, this.texture);
					this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

					this.render = this.renderSecondaryWebGL;
				} else {
					//todo: this should theoretically never happen
				}

				matchedType = true;
			}

			if (!matchedType) {
				throw 'Unknown target type';
			}

			this.target = target;
			this.transform = null;
			this.transformDirty = true;
			this.flip = flip;
			this.width = width;
			this.height = height;

			this.uniforms.resolution[0] = this.width;
			this.uniforms.resolution[1] = this.height;

			if (opts.auto !== undefined) {
				this.auto = opts.auto;
			} else {
				this.auto = auto;
			}
			this.frames = 0;

			this.pub = new Target(this);

			targets.push(this);
		};

		extend(TargetNode, Node);

		TargetNode.prototype.setSource = function (source) {
			var newSource;

			//todo: what if source is null/undefined/false

			newSource = findInputNode(source);

			//todo: check for cycles

			if (newSource !== this.source) {
				if (this.source) {
					this.source.removeTarget(this);
				}
				this.source = newSource;
				newSource.setTarget(this);

				this.setDirty();
			}
		};

		TargetNode.prototype.setDirty = function () {
			this.dirty = true;

			if (this.auto && !rafId) {
				rafId = requestAnimationFrame(renderDaemon);
			}
		};

		TargetNode.prototype.resize = function () {
			//if target is a canvas, reset size to canvas size
			if (this.target instanceof HTMLCanvasElement &&
					(this.width !== this.target.width || this.height !== this.target.height)) {
				this.width = this.target.width;
				this.height = this.target.height;
				this.uniforms.resolution[0] = this.width;
				this.uniforms.resolution[1] = this.height;
				this.setTransformDirty();
			}

			if (this.source &&
				(this.source.width !== this.width || this.source.height !== this.height)) {
				if (!this.transform) {
					this.transform = new Float32Array(16);
				}
			}
		};

		TargetNode.prototype.setTransformDirty = function () {
			this.transformDirty = true;
			this.setDirty();
		};

		TargetNode.prototype.go = function () {
			this.auto = true;
			this.setDirty();
		};

		TargetNode.prototype.stop = function () {
			this.auto = false;
		};

		TargetNode.prototype.renderWebGL = function () {
			var matrix, x, y;

			this.resize();

			if (this.dirty) {
				if (!this.source) {
					return;
				}

				this.source.render();

				this.uniforms.source = this.source.texture;

				if (this.source.width === this.width && this.source.height === this.height) {
					this.uniforms.transform = this.source.cumulativeMatrix || identity;
				} else if (this.transformDirty) {
					matrix = this.transform;
					mat4.copy(matrix, this.source.cumulativeMatrix || identity);
					x = this.source.width / this.width;
					y = this.source.height / this.height;
					matrix[0] *= x;
					matrix[1] *= x;
					matrix[2] *= x;
					matrix[3] *= x;
					matrix[4] *= y;
					matrix[5] *= y;
					matrix[6] *= y;
					matrix[7] *= y;
					this.uniforms.transform = matrix;
					this.transformDirty = false;
				}

				draw(baseShader, rectangleModel, this.uniforms, this.frameBuffer.frameBuffer, this);

				this.dirty = false;
			}
		};

		TargetNode.prototype.renderSecondaryWebGL = function () {
			if (this.dirty && this.source) {
				this.source.render();

				var width = this.source.width,
					height = this.source.height;

				if (!this.pixels || this.pixels.length !== width * height * 4) {
					this.pixels = new Uint8Array(width * height * 4);
				}

				this.source.readPixels(0, 0, this.source.width, this.source.height, this.pixels);

				this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.pixels);

				this.uniforms.source = this.texture;
				draw(this.shader, this.model, this.uniforms, null, this);

				this.dirty = false;
			}
		};

		TargetNode.prototype.render2D = function () {
			//todo: make this actually do something?
		};

		TargetNode.prototype.removeSource = function (source) {
			if (this.source === source || this.source === source.pub) {
				this.source = null;
			}
		};

		TargetNode.prototype.destroy = function () {
			var i;

			//source
			if (this.source && this.source.removeTarget) {
				this.source.removeTarget(this);
			}
			delete this.source;
			delete this.target;
			delete this.pub;
			delete this.uniforms;
			delete this.pixels;
			delete this.auto;

			//remove self from master list of targets
			i = targets.indexOf(this);
			if (i >= 0) {
				targets.splice(i, 1);
			}

			Node.prototype.destroy.call(this);
		};

		Transform = function (transformNode) {
			var me = transformNode,
				self = this,
				key;

			function setProperty(name, def) {
				// todo: validate value passed to 'set'
				Object.defineProperty(self, name, {
					configurable: true,
					enumerable: true,
					get: function () {
						return def.get.call(me);
					},
					set: function (val) {
						if (def.set.call(me, val)) {
							me.setTransformDirty();
						}
					}
				});
			}

			function makeMethod(method) {
				return function () {
					if (method.apply(me, arguments)) {
						me.setTransformDirty();
					}
				};
			}

			//priveleged accessor methods
			Object.defineProperties(this, {
				id: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.id;
					}
				},
				source: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.source.pub;
					},
					set: function (source) {
						me.setSource(source);
					}
				}
			});

			// attach methods
			for (key in me.methods) {
				if (me.methods.hasOwnProperty(key)) {
					this[key] = makeMethod(me.methods[key].bind(me));
				}
			}

			for (key in me.inputs) {
				if (me.inputs.hasOwnProperty(key)) {
					setProperty(key, me.inputs[key]);
				}
			}

			this.update = function () {
				me.setDirty();
			};

			this.alias = function (inputName, aliasName) {
				me.alias(inputName, aliasName);
				return this;
			};

			this.destroy = function () {
				var i,
					descriptor;

				me.destroy();

				for (i in this) {
					if (this.hasOwnProperty(i) && i !== 'isDestroyed') {
						//todo: probably can simplify this if the only setter/getter is id
						descriptor = Object.getOwnPropertyDescriptor(this, i);
						if (descriptor.get || descriptor.set ||
								typeof this[i] !== 'function') {
							delete this[i];
						} else {
							this[i] = nop;
						}
					}
				}
			};

			this.isDestroyed = function () {
				return me.isDestroyed;
			};
		};

		TransformNode = function (hook, options) {
			var key,
				input;

			this.matrix = new Float32Array(16);
			this.cumulativeMatrix = new Float32Array(16);

			this.width = 1;
			this.height = 1;

			this.seriously = seriously;

			this.transformRef = seriousTransforms[hook];
			this.hook = hook;
			this.id = nodeId;
			nodes.push(this);
			nodesById[nodeId] = this;
			nodeId++;

			this.options = options;
			this.sources = null;
			this.targets = [];
			this.inputElements = {};
			this.inputs = {};
			this.methods = {};

			this.texture = null;
			this.frameBuffer = null;
			this.uniforms = null;

			this.dirty = true;
			this.transformDirty = true;
			this.renderDirty = false;
			this.isDestroyed = false;
			this.transformed = false;

			if (this.transformRef.definition) {
				this.plugin = this.transformRef.definition.call(this, options);
				for (key in this.transformRef) {
					if (this.transformRef.hasOwnProperty(key) && !this.plugin[key]) {
						this.plugin[key] = this.transformRef[key];
					}
				}

				/*
				todo: validate method definitions, check against reserved names
				if (this.plugin.inputs !== this.transformRef.inputs) {
					validateInputSpecs(this.plugin);
				}
				*/
			} else {
				this.plugin = extend({}, this.transformRef);
			}

			for (key in this.plugin.inputs) {
				if (this.plugin.inputs.hasOwnProperty(key)) {
					input = this.plugin.inputs[key];

					if (input.method && typeof input.method === 'function') {
						this.methods[key] = input.method;
					} else if (typeof input.set === 'function' && typeof input.get === 'function') {
						this.inputs[key] = input;
					}
				}
			}

			this.pub = new Transform(this);

			transforms.push(this);

			allTransformsByHook[hook].push(this);
		};

		TransformNode.prototype.setDirty = function () {
			this.renderDirty = true;
			Node.prototype.setDirty.call(this);
		};

		TransformNode.prototype.setTransformDirty = function () {
			var i,
				target;
			this.transformDirty = true;
			this.dirty = true;
			this.renderDirty = true;
			for (i = 0; i < this.targets.length; i++) {
				target = this.targets[i];
				if (target.setTransformDirty) {
					target.setTransformDirty();
				} else {
					target.setDirty();
				}
			}
		};

		TransformNode.prototype.resize = function () {
			var i;

			Node.prototype.resize.call(this);

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}

			this.setTransformDirty();
		};

		TransformNode.prototype.setSource = function (source) {
			var newSource;

			//todo: what if source is null/undefined/false

			newSource = findInputNode(source);

			if (newSource === this.source) {
				return;
			}

			if (traceSources(newSource, this)) {
				throw 'Attempt to make cyclical connection.';
			}

			if (this.source) {
				this.source.removeTarget(this);
			}
			this.source = newSource;
			newSource.setTarget(this);

			this.resize();
		};

		TransformNode.prototype.setTarget = function (target) {
			var i;
			for (i = 0; i < this.targets.length; i++) {
				if (this.targets[i] === target) {
					return;
				}
			}

			this.targets.push(target);
		};

		TransformNode.prototype.removeTarget = function (target) {
			var i = this.targets && this.targets.indexOf(target);
			if (i >= 0) {
				this.targets.splice(i, 1);
			}

			if (this.targets && this.targets.length) {
				this.resize();
			}
		};

		TransformNode.prototype.alias = function (inputName, aliasName) {
			var me = this,
				input,
				def;

			if (reservedNames.indexOf(aliasName) >= 0) {
				throw aliasName + ' is a reserved name and cannot be used as an alias.';
			}

			if (this.plugin.inputs.hasOwnProperty(inputName)) {
				if (!aliasName) {
					aliasName = inputName;
				}

				seriously.removeAlias(aliasName);

				input = this.inputs[inputName];
				if (input) {
					def = me.inputs[inputName];
					Object.defineProperty(seriously, aliasName, {
						configurable: true,
						enumerable: true,
						get: function () {
							return def.get.call(me);
						},
						set: function (val) {
							if (def.set.call(me, val)) {
								me.setTransformDirty();
							}
						}
					});
				} else {
					input = this.methods[inputName];
					if (input) {
						def = input;
						seriously[aliasName] = function () {
							if (def.apply(me, arguments)) {
								me.setTransformDirty();
							}
						};
					}
				}

				if (input) {
					aliases[aliasName] = {
						node: this,
						input: inputName
					};
				}
			}

			return this;
		};

		TransformNode.prototype.render = function (renderTransform) {
			if (!this.source) {
				if (this.transformDirty) {
					mat4.copy(this.cumulativeMatrix, this.matrix);
					this.transformDirty = false;
				}
				this.texture = null;
				this.dirty = false;

				return;
			}

			this.source.render();

			if (this.transformDirty) {
				if (this.transformed) {
					//use this.matrix
					if (this.source.cumulativeMatrix) {
						mat4.multiply(this.cumulativeMatrix, this.matrix, this.source.cumulativeMatrix);
					} else {
						mat4.copy(this.cumulativeMatrix, this.matrix);
					}
				} else {
					//copy source.cumulativeMatrix
					mat4.copy(this.cumulativeMatrix, this.source.cumulativeMatrix || identity);
				}

				this.transformDirty = false;
			}

			if (renderTransform && gl) {
				if (this.renderDirty) {
					if (!this.frameBuffer) {
						this.uniforms = {
							resolution: [this.width, this.height]
						};
						this.frameBuffer = new FrameBuffer(gl, this.width, this.height);
					}

					this.uniforms.source = this.source.texture;
					this.uniforms.transform = this.cumulativeMatrix || identity;
					draw(baseShader, rectangleModel, this.uniforms, this.frameBuffer.frameBuffer, this);

					this.renderDirty = false;
				}
				this.texture = this.frameBuffer.texture;
			} else if (this.source) {
				this.texture = this.source.texture;
			} else {
				this.texture = null;
			}

			this.dirty = false;

			return this.texture;
		};

		TransformNode.prototype.destroy = function () {
			var i, key, item, hook = this.hook;

			//let effect destroy itself
			if (this.plugin.destroy && typeof this.plugin.destroy === 'function') {
				this.plugin.destroy.call(this);
			}
			delete this.effect;

			//stop watching any input elements
			for (i in this.inputElements) {
				if (this.inputElements.hasOwnProperty(i)) {
					item = this.inputElements[i];
					item.element.removeEventListener('change', item.listener, true);
					item.element.removeEventListener('input', item.listener, true);
				}
			}

			//sources
			if (this.source) {
				this.source.removeTarget(this);
			}

			//targets
			while (this.targets.length) {
				item = this.targets.pop();
				if (item && item.removeSource) {
					item.removeSource(this);
				}
			}

			for (key in this) {
				if (this.hasOwnProperty(key) && key !== 'id') {
					delete this[key];
				}
			}

			//remove any aliases
			for (key in aliases) {
				if (aliases.hasOwnProperty(key)) {
					item = aliases[key];
					if (item.node === this) {
						seriously.removeAlias(key);
					}
				}
			}

			//remove self from master list of effects
			i = transforms.indexOf(this);
			if (i >= 0) {
				transforms.splice(i, 1);
			}

			i = allTransformsByHook[hook].indexOf(this);
			if (i >= 0) {
				allTransformsByHook[hook].splice(i, 1);
			}

			Node.prototype.destroy.call(this);
		};

		/*
		Initialize Seriously object based on options
		*/

		if (options instanceof HTMLCanvasElement) {
			options = {
				canvas: options
			};
		} else {
			options = options || {};
		}

		if (options.canvas) {
		}

		/*
		priveleged methods
		*/
		this.effect = function (hook, options) {
			if (!seriousEffects[hook]) {
				throw 'Unknown effect: ' + hook;
			}

			var effectNode = new EffectNode(hook, options);
			return effectNode.pub;
		};

		this.source = function (source, options) {
			var sourceNode = findInputNode(source, options);
			//var sourceNode = new SourceNode(source, options);
			return sourceNode.pub;
		};

		this.transform = function (hook, opts) {
			var transformNode;

			if (typeof hook !== 'string') {
				opts = hook;
				hook = false;
			}

			if (hook) {
				if (!seriousTransforms[hook]) {
					throw 'Unknown transforms: ' + hook;
				}
			} else {
				hook = options && options.defaultTransform || '2d';
				if (!seriousTransforms[hook]) {
					throw 'No transform specified';
				}
			}

			transformNode = new TransformNode(hook, opts);
			return transformNode.pub;
		};

		this.target = function (target, options) {
			var targetNode, i;

			for (i = 0; i < targets.length; i++) {
				if (targets[i] === target || targets[i].target === target) {
					if (!!(options && options.renderToTexture) === !!targets[i].renderToTexture) {
						return targets[i].pub;
					}
				}
			}

			targetNode = new TargetNode(target, options);

			return targetNode.pub;
		};

		this.aliases = function () {
			return Object.keys(aliases);
		};

		this.removeAlias = function (name) {
			if (aliases[name]) {
				delete this[name];
				delete aliases[name];
			}
		};

		this.go = function (pre, post) {
			var i;

			if (typeof pre === 'function' && preCallbacks.indexOf(pre) < 0) {
				preCallbacks.push(pre);
			}

			if (typeof post === 'function' && postCallbacks.indexOf(post) < 0) {
				postCallbacks.push(post);
			}

			auto = true;
			for (i = 0; i < targets.length; i++) {
				targets[i].go();
			}

			if (!rafId && (preCallbacks.length || postCallbacks.length)) {
				renderDaemon();
			}
		};

		this.stop = function () {
			preCallbacks.length = 0;
			postCallbacks.length = 0;
			cancelAnimFrame(rafId);
			rafId = null;
		};

		this.render = function () {
			var i;
			for (i = 0; i < targets.length; i++) {
				targets[i].render(options);
			}
		};

		this.destroy = function () {
			var i,
				node,
				descriptor;

			while (nodes.length) {
				node = nodes.shift();
				node.destroy();
			}

			if (baseShader) {
				baseShader.destroy();
				baseShader = null;
			}

			//clean up rectangleModel
			if (gl) {
				gl.deleteBuffer(rectangleModel.vertex);
				gl.deleteBuffer(rectangleModel.texCoord);
				gl.deleteBuffer(rectangleModel.index);
			}

			if (rectangleModel) {
				delete rectangleModel.vertex;
				delete rectangleModel.texCoord;
				delete rectangleModel.index;
			}

			for (i in this) {
				if (this.hasOwnProperty(i) && i !== 'isDestroyed') {
					descriptor = Object.getOwnPropertyDescriptor(this, i);
					if (descriptor.get || descriptor.set ||
							typeof this[i] !== 'function') {
						delete this[i];
					} else {
						this[i] = nop;
					}
				}
			}

			baseFragmentShader = null;
			baseVertexShader = null;
			rectangleModel = null;
			gl = null;
			seriously = null;
			sources = [];
			targets = [];
			effects = [];
			nodes = [];
			preCallbacks.length = 0;
			postCallbacks.length = 0;
			cancelAnimFrame(rafId);
			rafId = null;


			isDestroyed = true;
		};

		this.isDestroyed = function () {
			return isDestroyed;
		};

		this.incompatible = function (pluginHook) {
			var i,
				plugin,
				failure = false;

			failure = Seriously.incompatible(pluginHook);

			if (failure) {
				return failure;
			}

			if (!pluginHook) {
				for (i in allEffectsByHook) {
					if (allEffectsByHook.hasOwnProperty(i) && allEffectsByHook[i].length) {
						plugin = seriousEffects[i];
						if (plugin && typeof plugin.compatible === 'function' &&
							!plugin.compatible.call(this)) {

							return 'plugin-' + i;
						}
					}
				}
			}

			return false;
		};

		//todo: load, save, find

		baseVertexShader = [
			'#ifdef GL_ES',
			'precision mediump float;',
			'#endif',

			'attribute vec4 position;',
			'attribute vec2 texCoord;',

			'uniform vec2 resolution;',
			'uniform mat4 transform;',

			'varying vec2 vTexCoord;',
			'varying vec4 vPosition;',

			'void main(void) {',
			// first convert to screen space
			'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
			'	screenPosition = transform * screenPosition;',

			// convert back to OpenGL coords
			'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
			'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
			'	gl_Position.w = screenPosition.w;',
			'	vTexCoord = texCoord;',
			'	vPosition = gl_Position;',
			'}\n'
		].join('\n');

		baseFragmentShader = [
			'#ifdef GL_ES',
			'precision mediump float;',
			'#endif',
			'varying vec2 vTexCoord;',
			'varying vec4 vPosition;',
			'uniform sampler2D source;',
			'void main(void) {',
			/*
			'	if (any(lessThan(vTexCoord, vec2(0.0))) || any(greaterThanEqual(vTexCoord, vec2(1.0)))) {',
			'		gl_FragColor = vec4(0.0);',
			'	} else {',
			*/
			'		gl_FragColor = texture2D(source, vTexCoord);',
			//'	}',
			'}'
		].join('\n');
	}

	Seriously.incompatible = function (pluginHook) {
		var canvas, gl, plugin;

		if (incompatibility === undefined) {
			canvas = document.createElement('canvas');
			if (!canvas || !canvas.getContext) {
				incompatibility = 'canvas';
			} else if (!window.WebGLRenderingContext) {
				incompatibility = 'webgl';
			} else {
				gl = getTestContext();
				if (!gl) {
					incompatibility = 'context';
				}
			}
		}

		if (incompatibility) {
			return incompatibility;
		}

		if (pluginHook) {
			plugin = seriousEffects[pluginHook];
			if (plugin && typeof plugin.compatible === 'function' &&
				!plugin.compatible(gl)) {

				return 'plugin-' + pluginHook;
			}
		}

		return false;
	};

	Seriously.plugin = function (hook, definition, meta) {
		var effect;

		if (seriousEffects[hook]) {
			console.log('Effect [' + hook + '] already loaded');
			return;
		}

		if (meta === undefined && typeof definition === 'object') {
			meta = definition;
		}

		if (!meta) {
			return;
		}

		effect = extend({}, meta);

		if (typeof definition === 'function') {
			effect.definition = definition;
		}

		if (effect.inputs) {
			validateInputSpecs(effect);
		}

		if (!effect.title) {
			effect.title = hook;
		}

		/*
		if (typeof effect.requires !== 'function') {
			effect.requires = false;
		}
		*/

		seriousEffects[hook] = effect;
		allEffectsByHook[hook] = [];

		return effect;
	};

	Seriously.removePlugin = function (hook) {
		var all, effect, plugin;

		if (!hook) {
			return this;
		}

		plugin = seriousEffects[hook];

		if (!plugin) {
			return this;
		}

		all = allEffectsByHook[hook];
		if (all) {
			while (all.length) {
				effect = all[0];
				effect.destroy();
			}
			delete allEffectsByHook[hook];
		}

		delete seriousEffects[hook];

		return this;
	};

	Seriously.transform = function (hook, definition, meta) {
		var transform;

		if (seriousTransforms[hook]) {
			console.log('Transform [' + hook + '] already loaded');
			return;
		}

		if (meta === undefined && typeof definition === 'object') {
			meta = definition;
		}

		if (!meta && !definition) {
			return;
		}

		transform = extend({}, meta);

		if (typeof definition === 'function') {
			transform.definition = definition;
		}

		/*
		todo: validate method definitions
		if (effect.inputs) {
			validateInputSpecs(effect);
		}
		*/

		if (!transform.title) {
			transform.title = hook;
		}


		seriousTransforms[hook] = transform;
		allTransformsByHook[hook] = [];

		return transform;
	};

	Seriously.removeTransform = function (hook) {
		var all, transform, plugin;

		if (!hook) {
			return this;
		}

		plugin = seriousTransforms[hook];

		if (!plugin) {
			return this;
		}

		all = allTransformsByHook[hook];
		if (all) {
			while (all.length) {
				transform = all[0];
				transform.destroy();
			}
			delete allTransformsByHook[hook];
		}

		delete seriousTransforms[hook];

		return this;
	};

	//todo: validators should not allocate new objects/arrays if input is valid
	Seriously.inputValidators = {
		color: function (value, input, oldValue) {
			var s, a, i, computed, bg;

			a = oldValue || [];

			if (typeof value === 'string') {
				//todo: support percentages, decimals
				s = (/^(rgb|hsl)a?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*(\d+(\.\d*)?)\s*)?\)/i).exec(value);
				if (s && s.length) {
					if (s.length < 3) {
						a[0] = a[1] = a[2] = a[3] = 0;
						return a;
					}

					a[3] = 1;
					for (i = 0; i < 3; i++) {
						a[i] = parseFloat(s[i+2]) / 255;
					}
					if (!isNaN(s[6])) {
						a[3] = parseFloat(s[6]);
					}
					if (s[1].toLowerCase() === 'hsl') {
						return hslToRgb(a[0], a[1], a[2], a[3], a);
					}
					return a;
				}

				s = (/^#(([0-9a-fA-F]{3,8}))/).exec(value);
				if (s && s.length) {
					s = s[1];
					if (s.length === 3) {
						a[0] = parseInt(s[0], 16) / 15;
						a[1] = parseInt(s[1], 16) / 15;
						a[2] = parseInt(s[2], 16) / 15;
						a[3] = 1;
					} else if (s.length === 4) {
						a[0] = parseInt(s[0], 16) / 15;
						a[1] = parseInt(s[1], 16) / 15;
						a[2] = parseInt(s[2], 16) / 15;
						a[3] = parseInt(s[3], 16) / 15;
					} else if (s.length === 6) {
						a[0] = parseInt(s.substr(0, 2), 16) / 255;
						a[1] = parseInt(s.substr(2, 2), 16) / 255;
						a[2] = parseInt(s.substr(4, 2), 16) / 255;
						a[3] = 1;
					} else if (s.length === 8) {
						a[0] = parseInt(s.substr(0, 2), 16) / 255;
						a[1] = parseInt(s.substr(2, 2), 16) / 255;
						a[2] = parseInt(s.substr(4, 2), 16) / 255;
						a[3] = parseInt(s.substr(6, 2), 16) / 255;
					} else {
						a[0] = a[1] = a[2] = a[3] = 0;
					}
					return a;
				}

				s = colorNames[value.toLowerCase()];
				if (s) {
					for (i = 0; i < 4; i++) {
						a[i] = s[i];
					}
					return a;
				}

				if (!colorElement) {
					colorElement = document.createElement('a');
				}
				colorElement.style.backgroundColor = '';
				colorElement.style.backgroundColor = value;
				computed = window.getComputedStyle(colorElement);
				bg = computed.getPropertyValue('background-color') ||
					computed.getPropertyValue('backgroundColor') ||
					colorElement.style.backgroundColor;
				if (bg && bg !== value) {
					return Seriously.inputValidators.color(bg, input, oldValue);
				}

				a[0] = a[1] = a[2] = a[3] = 0;
				return a;
			}

			if (isArrayLike(value)) {
				a = value;
				if (a.length < 3) {
					a[0] = a[1] = a[2] = a[3] = 0;
					return a;
				}
				for (i = 0; i < 3; i++) {
					if (isNaN(a[i])) {
						a[0] = a[1] = a[2] = a[3] = 0;
						return a;
					}
				}
				if (a.length < 4) {
					a.push(1);
				}
				return a;
			}

			if (typeof value === 'number') {
				a[0] = a[1] = a[2] = value;
				a[3] = 1;
				return a;
			}

			if (typeof value === 'object') {
				for (i = 0; i < 4; i++) {
					s = colorFields[i];
					if (value[s] === null || isNaN(value[s])) {
						a[i] = i === 3 ? 1 : 0;
					} else {
						a[i] = value[s];
					}
				}
				return a;
			}

			a[0] = a[1] = a[2] = a[3] = 0;
			return a;
		},
		number: function (value, input) {
			if (isNaN(value)) {
				return input.defaultValue || 0;
			}

			value = parseFloat(value);

			if (value < input.min) {
				return input.min;
			}

			if (value > input.max) {
				return input.max;
			}

			if (input.step) {
				return Math.round(value / input.step) * input.step;
			}

			return value;
		},
		'enum': function (value, input) {
			var options = input.options || [],
				filtered;

			filtered = options.filter(function (opt) {
				return (isArrayLike(opt) && opt.length && opt[0] === value) || opt === value;
			});

			if (filtered.length) {
				return value;
			}

			return input.defaultValue || '';
		},
		vector: function (value, input, oldValue) {
			var a, i, s, n = input.dimensions || 4;

			a = oldValue || [];
			if (isArrayLike(value)) {
				for (i = 0; i < n; i++) {
					a[i] = value[i] || 0;
				}
				return a;
			}

			if (typeof value === 'object') {
				for (i = 0; i < n; i++) {
					s = vectorFields[i];
					if (value[s] === undefined) {
						s = colorFields[i];
					}
					a[i] = value[s] || 0;
				}
				return a;
			}

			value = parseFloat(value) || 0;
			for (i = 0; i < n; i++) {
				a[i] = value;
			}

			return a;
		},
		'boolean': function (value) {
			if (!value) {
				return false;
			}

			if (value && value.toLowerCase && value.toLowerCase() === 'false') {
				return false;
			}

			return true;
		}
		//todo: date/time
	};

	Seriously.prototype.effects = Seriously.effects = function () {
		var name,
			effect,
			manifest,
			effects = {},
			input,
			i;

		for (name in seriousEffects) {
			if (seriousEffects.hasOwnProperty(name)) {
				effect = seriousEffects[name];
				manifest = {
					title: effect.title || name,
					description: effect.description || '',
					inputs: {}
				};

				for (i in effect.inputs) {
					if (effect.inputs.hasOwnProperty(i)) {
						input = effect.inputs[i];
						manifest.inputs[i] = {
							type: input.type,
							defaultValue: input.defaultValue,
							step: input.step,
							min: input.min,
							max: input.max,
							minCount: input.minCount,
							maxCount: input.maxCount,
							dimensions: input.dimensions,
							title: input.title || i,
							description: input.description || '',
							options: input.options || []
						};
					}
				}

				effects[name] = manifest;
			}
		}

		return effects;
	};

	if (window.Float32Array) {
		identity = new Float32Array([
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		]);
	}

	//check for plugins loaded out of order
	if (window.Seriously) {
		if (typeof window.Seriously === 'object') {
			(function () {
				var i;
				for (i in window.Seriously) {
					if (window.Seriously.hasOwnProperty(i) &&
						i !== 'plugin' &&
						typeof window.Seriously[i] === 'object') {

						Seriously.plugin(i, window.Seriously[i]);
					}
				}
			}());
		} else {
			//seriously has already been loaded, so don't replace it
			return;
		}
	}

	//expose Seriously to the global object
	Seriously.util = {
		mat4: mat4,
		checkSource: checkSource,
		hslToRgb: hslToRgb,
		colors: colorNames,
		setTimeoutZero: setTimeoutZero,
		ShaderProgram: ShaderProgram,
		FrameBuffer: FrameBuffer,
		requestAnimationFrame: requestAnimationFrame,
		shader: {
			makeNoise: 'float makeNoise(float u, float v, float timer) {\n' +
						'	float x = u * v * mod(timer * 1000.0, 100.0);\n' +
						'	x = mod(x, 13.0) * mod(x, 127.0);\n' +
						'	float dx = mod(x, 0.01);\n' +
						'	return clamp(0.1 + dx * 100.0, 0.0, 1.0);\n' +
						'}\n',
			random: '#ifndef RANDOM\n' +
				'#define RANDOM\n' +
				'float random(vec2 n) {\n' +
				'	return 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n' +
				'}\n' +
				'#endif\n'
		}
	};

	/*
	Default transform - 2D
	Affine transforms
	- translate
	- rotate (degrees)
	- scale
	- skew

	todo: move this to a different file when we have a build tool
	*/
	Seriously.transform('2d', function (options) {
		var me = this,
			degrees = !(options && options.radians),

			centerX = 0,
			centerY = 0,
			scaleX = 1,
			scaleY = 1,
			translateX = 0,
			translateY = 0,
			rotation = 0,
			skewX = 0,
			skewY = 0;

		//todo: skew order
		//todo: invert?

		function recompute() {
			var matrix = me.matrix,
				angle,
				s, c,
				m00,
				m01,
				m02,
				m03,
				m10,
				m11,
				m12,
				m13;

			function translate(x, y) {
				matrix[12] = matrix[0] * x + matrix[4] * y + matrix[12];
				matrix[13] = matrix[1] * x + matrix[5] * y + matrix[13];
				matrix[14] = matrix[2] * x + matrix[6] * y + matrix[14];
				matrix[15] = matrix[3] * x + matrix[7] * y + matrix[15];
			}

			if (!translateX &&
					!translateY &&
					!rotation &&
					!skewX &&
					!skewY &&
					scaleX === 1 &&
					scaleY === 1
					) {
				me.transformed = false;
				return;
			}

			//calculate transformation matrix
			mat4.identity(matrix);

			translate(translateX + centerX, translateY + centerY);

			//skew
			if (skewX) {
				matrix[4] = skewX / me.width;
			}
			if (skewY) {
				matrix[1] = skewY / me.height;
			}

			if (rotation) {
				m00 = matrix[0];
				m01 = matrix[1];
				m02 = matrix[2];
				m03 = matrix[3];
				m10 = matrix[4];
				m11 = matrix[5];
				m12 = matrix[6];
				m13 = matrix[7];

				//rotate
				angle = -(degrees ? rotation * Math.PI / 180 : rotation);
				//...rotate
				s = Math.sin(angle);
				c = Math.cos(angle);
				matrix[0] = m00 * c + m10 * s;
				matrix[1] = m01 * c + m11 * s;
				matrix[2] = m02 * c + m12 * s;
				matrix[3] = m03 * c + m13 * s;
				matrix[4] = m10 * c - m00 * s;
				matrix[5] = m11 * c - m01 * s;
				matrix[6] = m12 * c - m02 * s;
				matrix[7] = m13 * c - m03 * s;
			}

			//scale
			if (scaleX !== 1) {
				matrix[0] *= scaleX;
				matrix[1] *= scaleX;
				matrix[2] *= scaleX;
				matrix[3] *= scaleX;
			}
			if (scaleY !== 1) {
				matrix[4] *= scaleY;
				matrix[5] *= scaleY;
				matrix[6] *= scaleY;
				matrix[7] *= scaleY;
			}

			translate(-centerX, -centerY);

			me.transformed = true;
		}

		return {
			inputs: {
				reset: {
					method: function () {
						centerX = 0;
						centerY = 0;
						scaleX = 1;
						scaleY = 1;
						translateX = 0;
						translateY = 0;
						rotation = 0;
						skewX = 0;
						skewY = 0;

						if (me.transformed) {
							me.transformed = false;
							return true;
						}

						return false;
					}
				},
				translate: {
					method: function (x, y) {
						if (isNaN(x)) {
							x = translateX;
						}

						if (isNaN(y)) {
							y = translateY;
						}

						if (x === translateX && y === translateY) {
							return false;
						}

						translateX = x;
						translateY = y;

						recompute();
						return true;
					},
					type: [
						'number',
						'number'
					]
				},
				translateX: {
					get: function () {
						return translateX;
					},
					set: function (x) {
						if (x === translateX) {
							return false;
						}

						translateX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				translateY: {
					get: function () {
						return translateY;
					},
					set: function (y) {
						if (y === translateY) {
							return false;
						}

						translateY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotation: {
					get: function () {
						return rotation;
					},
					set: function (angle) {
						if (angle === rotation) {
							return false;
						}

						//todo: fmod 360deg or Math.PI * 2 radians
						rotation = angle;

						recompute();
						return true;
					},
					type: 'number'
				},
				center: {
					method: function (x, y) {
						if (isNaN(x)) {
							x = centerX;
						}

						if (isNaN(y)) {
							y = centerY;
						}

						if (x === centerX && y === centerY) {
							return false;
						}

						centerX = x;
						centerY = y;

						recompute();
						return true;
					},
					type: [
						'number',
						'number'
					]
				},
				centerX: {
					get: function () {
						return centerX;
					},
					set: function (x) {
						if (x === centerX) {
							return false;
						}

						centerX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				centerY: {
					get: function () {
						return centerY;
					},
					set: function (y) {
						if (y === centerY) {
							return false;
						}

						centerY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				skew: {
					method: function (x, y) {
						if (isNaN(x)) {
							x = skewX;
						}

						if (isNaN(y)) {
							y = skewY;
						}

						if (x === skewX && y === skewY) {
							return false;
						}

						skewX = x;
						skewY = y;

						recompute();
						return true;
					},
					type: [
						'number',
						'number'
					]
				},
				skewX: {
					get: function () {
						return skewX;
					},
					set: function (x) {
						if (x === skewX) {
							return false;
						}

						skewX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				skewY: {
					get: function () {
						return skewY;
					},
					set: function (y) {
						if (y === skewY) {
							return false;
						}

						skewY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				scale: {
					method: function (x, y) {
						var newX, newY;

						if (isNaN(x)) {
							newX = scaleX;
						} else {
							newX = x;
						}

						/*
						if only one value is specified, set both x and y to the same scale
						*/
						if (isNaN(y)) {
							if (isNaN(x)) {
								return false;
							}

							newY = newX;
						} else {
							newY = y;
						}

						if (newX === scaleX && newY === scaleY) {
							return false;
						}

						scaleX = newX;
						scaleY = newY;

						recompute();
						return true;
					},
					type: [
						'number',
						'number'
					]
				},
				scaleX: {
					get: function () {
						return scaleX;
					},
					set: function (x) {
						if (x === scaleX) {
							return false;
						}

						scaleX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				scaleY: {
					get: function () {
						return scaleY;
					},
					set: function (y) {
						if (y === scaleY) {
							return false;
						}

						scaleY = y;

						recompute();
						return true;
					},
					type: 'number'
				}
			}
		};
	}, {
		title: '2D Transform',
		description: 'Translate, Rotate, Scale, Skew'
	});

	/*
	todo: move this to a different file when we have a build tool
	*/
	Seriously.transform('flip', function () {
		var me = this,
			horizontal = true;

		function recompute() {
			var matrix = me.matrix;

			//calculate transformation matrix
			//mat4.identity(matrix);

			//scale
			if (horizontal) {
				matrix[0] = -1;
				matrix[5] = 1;
			} else {
				matrix[0] = 1;
				matrix[5] = -1;
			}
		}

		mat4.identity(me.matrix);
		recompute();

		me.transformDirty = true;

		me.transformed = true;

		return {
			inputs: {
				direction: {
					get: function () {
						return horizontal ? 'horizontal' : 'vertical';
					},
					set: function (d) {
						var horiz;
						if (d === 'vertical') {
							horiz = false;
						} else {
							horiz = true;
						}

						if (horiz === horizontal) {
							return false;
						}

						horizontal = horiz;
						recompute();
						return true;
					},
					type: 'string'
				}
			}
		};
	}, {
		title: 'Flip',
		description: 'Flip Horizontal/Vertical'
	});

	/*
	Reformat
	todo: move this to a different file when we have a build tool
	*/
	Seriously.transform('reformat', function () {
		var me = this,
			forceWidth,
			forceHeight,
			mode = 'contain';

		function recompute() {
			var matrix = me.matrix,
				width = forceWidth || me.width,
				height = forceHeight || me.height,
				scaleX,
				scaleY,
				source = me.source,
				sourceWidth = source && source.width || 1,
				sourceHeight = source && source.height || 1,
				aspectIn,
				aspectOut;

			if (mode === 'distort' || width === sourceWidth && height === sourceHeight) {
				me.transformed = false;
				return;
			}

			aspectIn = sourceWidth / sourceHeight;

			aspectOut = width / height;

			if (mode === 'width' || mode === 'contain' && aspectOut <= aspectIn) {
				scaleX = 1;
				scaleY = aspectOut / aspectIn;
			} else if (mode === 'height' || mode === 'contain' && aspectOut > aspectIn) {
				scaleX = aspectIn / aspectOut;
				scaleY = 1;
			} else {
				//mode === 'cover'
				if (aspectOut > aspectIn) {
					scaleX = 1;
					scaleY = aspectOut / aspectIn;
				} else {
					scaleX = aspectIn / aspectOut;
					scaleY = 1;
				}
			}

			if (scaleX === 1 && scaleY === 1) {
				me.transformed = false;
				return;
			}

			//calculate transformation matrix
			mat4.identity(matrix);

			//scale
			if (scaleX !== 1) {
				matrix[0] *= scaleX;
				matrix[1] *= scaleX;
				matrix[2] *= scaleX;
				matrix[3] *= scaleX;
			}
			if (scaleY !== 1) {
				matrix[4] *= scaleY;
				matrix[5] *= scaleY;
				matrix[6] *= scaleY;
				matrix[7] *= scaleY;
			}
			me.transformed = true;
		}

		function getWidth() {
			return forceWidth || me.source && me.source.width || 1;
		}

		function getHeight() {
			return forceHeight || me.source && me.source.height || 1;
		}

		this.resize = function () {
			var width = getWidth(),
				height = getHeight(),
				i;

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				if (this.uniforms && this.uniforms.resolution) {
					this.uniforms.resolution[0] = width;
					this.uniforms.resolution[1] = height;
				}

				if (this.frameBuffer && this.frameBuffer.resize) {
					this.frameBuffer.resize(width, height);
				}

				for (i = 0; i < this.targets.length; i++) {
					this.targets[i].resize();
				}
			}

			this.setTransformDirty();

			recompute();
		};

		return {
			inputs: {
				width: {
					get: getWidth,
					set: function (x) {
						if (x === forceWidth) {
							return false;
						}

						forceWidth = x;

						this.resize();

						//don't need to run setTransformDirty again
						return false;
					},
					type: 'number'
				},
				height: {
					get: getHeight,
					set: function (y) {
						if (y === forceHeight) {
							return false;
						}

						forceHeight = y;

						this.resize();

						//don't need to run setTransformDirty again
						return false;
					},
					type: 'number'
				},
				mode: {
					get: function () {
						return mode;
					},
					set: function (m) {
						if (m === mode) {
							return false;
						}

						mode = m;

						recompute();
						return true;
					},
					type: 'enum',
					options: [
						'cover',
						'contain',
						'distort',
						'width',
						'height'
					]
				}
			}
		};
	}, {
		title: 'Reformat',
		description: 'Change output dimensions'
	});

	/*
	todo: additional transform node types
	- perspective
	- matrix
	- crop? - maybe not - probably would just scale.
	- camera shake?
	*/

	/*
	 * simplex noise shaders
	 * https://github.com/ashima/webgl-noise
	 * Copyright (C) 2011 by Ashima Arts (Simplex noise)
	 * Copyright (C) 2011 by Stefan Gustavson (Classic noise)
	 */

	Seriously.util.shader.noiseHelpers = '#ifndef NOISE_HELPERS\n' +
		'#define NOISE_HELPERS\n' +
		'vec2 mod289(vec2 x) {\n' +
		'	return x - floor(x * (1.0 / 289.0)) * 289.0;\n' +
		'}\n' +
		'vec3 mod289(vec3 x) {\n' +
		'	return x - floor(x * (1.0 / 289.0)) * 289.0;\n' +
		'}\n' +
		'vec4 mod289(vec4 x) {\n' +
		'	return x - floor(x * (1.0 / 289.0)) * 289.0;\n' +
		'}\n' +
		'vec3 permute(vec3 x) {\n' +
		'	return mod289(((x*34.0)+1.0)*x);\n' +
		'}\n' +
		'vec4 permute(vec4 x) {\n' +
		'	return mod289(((x*34.0)+1.0)*x);\n' +
		'}\n' +
		'vec4 taylorInvSqrt(vec4 r) {\n' +
		'	return 1.79284291400159 - 0.85373472095314 * r;\n' +
		'}\n' +
		'float taylorInvSqrt(float r) {\n' +
		'	return 1.79284291400159 - 0.85373472095314 * r;\n' +
		'}\n' +
		'#endif\n';

	Seriously.util.shader.snoise2d = '#ifndef NOISE2D\n' +
		'#define NOISE2D\n' +
		'float snoise(vec2 v) {\n' +
		'	const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n' +
		'		0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n' +
		'		-0.577350269189626, // -1.0 + 2.0 * C.x\n' +
		'		0.024390243902439); // 1.0 / 41.0\n' +
		'	vec2 i = floor(v + dot(v, C.yy));\n' +
		'	vec2 x0 = v - i + dot(i, C.xx);\n' +
		'	vec2 i1;\n' +
		'	//i1.x = step(x0.y, x0.x); // x0.x > x0.y ? 1.0 : 0.0\n' +
		'	//i1.y = 1.0 - i1.x;\n' +
		'	i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n' +
		'	// x0 = x0 - 0.0 + 0.0 * C.xx ;\n' +
		'	// x1 = x0 - i1 + 1.0 * C.xx ;\n' +
		'	// x2 = x0 - 1.0 + 2.0 * C.xx ;\n' +
		'	vec4 x12 = x0.xyxy + C.xxzz;\n' +
		'	x12.xy -= i1;\n' +
		'	i = mod289(i); // Avoid truncation effects in permutation\n' +
		'	vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n' +
		'	vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n' +
		'	m = m*m ;\n' +
		'	m = m*m ;\n' +
		'	vec3 x = 2.0 * fract(p * C.www) - 1.0;\n' +
		'	vec3 h = abs(x) - 0.5;\n' +
		'	vec3 ox = floor(x + 0.5);\n' +
		'	vec3 a0 = x - ox;\n' +
		'	m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n' +
		'	vec3 g;\n' +
		'	g.x = a0.x * x0.x + h.x * x0.y;\n' +
		'	g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n' +
		'	return 130.0 * dot(m, g);\n' +
		'}\n' +
		'#endif\n';

	Seriously.util.shader.snoise3d = '#ifndef NOISE3D\n' +
		'#define NOISE3D\n' +
		'float snoise(vec3 v) {\n' +
		'	const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n' +
		'	const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n' +

		// First corner
		'	vec3 i = floor(v + dot(v, C.yyy));\n' +
		'	vec3 x0 = v - i + dot(i, C.xxx) ;\n' +

		// Other corners
		'	vec3 g = step(x0.yzx, x0.xyz);\n' +
		'	vec3 l = 1.0 - g;\n' +
		'	vec3 i1 = min(g.xyz, l.zxy);\n' +
		'	vec3 i2 = max(g.xyz, l.zxy);\n' +

		'	// x0 = x0 - 0.0 + 0.0 * C.xxx;\n' +
		'	// x1 = x0 - i1 + 1.0 * C.xxx;\n' +
		'	// x2 = x0 - i2 + 2.0 * C.xxx;\n' +
		'	// x3 = x0 - 1.0 + 3.0 * C.xxx;\n' +
		'	vec3 x1 = x0 - i1 + C.xxx;\n' +
		'	vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n' +
		'	vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n' +

		// Permutations
		'	i = mod289(i);\n' +
		'	vec4 p = permute(permute(permute(\n' +
		'						i.z + vec4(0.0, i1.z, i2.z, 1.0))\n' +
		'						+ i.y + vec4(0.0, i1.y, i2.y, 1.0))\n' +
		'						+ i.x + vec4(0.0, i1.x, i2.x, 1.0));\n' +

		// Gradients: 7x7 points over a square, mapped onto an octahedron.
		// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
		'	float n_ = 0.142857142857; // 1.0/7.0\n' +
		'	vec3 ns = n_ * D.wyz - D.xzx;\n' +

		'	vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p, 7 * 7)\n' +

		'	vec4 x_ = floor(j * ns.z);\n' +
		'	vec4 y_ = floor(j - 7.0 * x_); // mod(j, N)\n' +

		'	vec4 x = x_ * ns.x + ns.yyyy;\n' +
		'	vec4 y = y_ * ns.x + ns.yyyy;\n' +
		'	vec4 h = 1.0 - abs(x) - abs(y);\n' +

		'	vec4 b0 = vec4(x.xy, y.xy);\n' +
		'	vec4 b1 = vec4(x.zw, y.zw);\n' +

		'	//vec4 s0 = vec4(lessThan(b0, 0.0)) * 2.0 - 1.0;\n' +
		'	//vec4 s1 = vec4(lessThan(b1, 0.0)) * 2.0 - 1.0;\n' +
		'	vec4 s0 = floor(b0) * 2.0 + 1.0;\n' +
		'	vec4 s1 = floor(b1) * 2.0 + 1.0;\n' +
		'	vec4 sh = -step(h, vec4(0.0));\n' +

		'	vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n' +
		'	vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n' +

		'	vec3 p0 = vec3(a0.xy, h.x);\n' +
		'	vec3 p1 = vec3(a0.zw, h.y);\n' +
		'	vec3 p2 = vec3(a1.xy, h.z);\n' +
		'	vec3 p3 = vec3(a1.zw, h.w);\n' +

		//Normalise gradients
		'	vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n' +
		'	p0 *= norm.x;\n' +
		'	p1 *= norm.y;\n' +
		'	p2 *= norm.z;\n' +
		'	p3 *= norm.w;\n' +

		// Mix final noise value
		'	vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n' +
		'	m = m * m;\n' +
		'	return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n' +
		'}\n' +
		'#endif\n';

	Seriously.util.shader.snoise4d = '#ifndef NOISE4D\n' +
		'#define NOISE4D\n' +
		'vec4 grad4(float j, vec4 ip)\n' +
		'	{\n' +
		'	const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n' +
		'	vec4 p, s;\n' +
		'\n' +
		'	p.xyz = floor(fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n' +
		'	p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n' +
		'	s = vec4(lessThan(p, vec4(0.0)));\n' +
		'	p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n' +
		'\n' +
		'	return p;\n' +
		'	}\n' +
		'\n' +
		// (sqrt(5) - 1)/4 = F4, used once below\n
		'#define F4 0.309016994374947451\n' +
		'\n' +
		'float snoise(vec4 v)\n' +
		'	{\n' +
		'	const vec4 C = vec4(0.138196601125011, // (5 - sqrt(5))/20 G4\n' +
		'						0.276393202250021, // 2 * G4\n' +
		'						0.414589803375032, // 3 * G4\n' +
		'						-0.447213595499958); // -1 + 4 * G4\n' +
		'\n' +
		// First corner
		'	vec4 i = floor(v + dot(v, vec4(F4)));\n' +
		'	vec4 x0 = v - i + dot(i, C.xxxx);\n' +
		'\n' +
		// Other corners
		'\n' +
		// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
		'	vec4 i0;\n' +
		'	vec3 isX = step(x0.yzw, x0.xxx);\n' +
		'	vec3 isYZ = step(x0.zww, x0.yyz);\n' +
		// i0.x = dot(isX, vec3(1.0));
		'	i0.x = isX.x + isX.y + isX.z;\n' +
		'	i0.yzw = 1.0 - isX;\n' +
		// i0.y += dot(isYZ.xy, vec2(1.0));
		'	i0.y += isYZ.x + isYZ.y;\n' +
		'	i0.zw += 1.0 - isYZ.xy;\n' +
		'	i0.z += isYZ.z;\n' +
		'	i0.w += 1.0 - isYZ.z;\n' +
		'\n' +
			// i0 now contains the unique values 0,1,2,3 in each channel
		'	vec4 i3 = clamp(i0, 0.0, 1.0);\n' +
		'	vec4 i2 = clamp(i0-1.0, 0.0, 1.0);\n' +
		'	vec4 i1 = clamp(i0-2.0, 0.0, 1.0);\n' +
		'\n' +
		'	vec4 x1 = x0 - i1 + C.xxxx;\n' +
		'	vec4 x2 = x0 - i2 + C.yyyy;\n' +
		'	vec4 x3 = x0 - i3 + C.zzzz;\n' +
		'	vec4 x4 = x0 + C.wwww;\n' +
		'\n' +
		// Permutations
		'	i = mod289(i);\n' +
		'	float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);\n' +
		'	vec4 j1 = permute(permute(permute(permute (\n' +
		'					i.w + vec4(i1.w, i2.w, i3.w, 1.0))\n' +
		'					+ i.z + vec4(i1.z, i2.z, i3.z, 1.0))\n' +
		'					+ i.y + vec4(i1.y, i2.y, i3.y, 1.0))\n' +
		'					+ i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n' +
		'\n' +
		// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
		// 7*7*6 = 294, which is close to the ring size 17*17 = 289.
		'	vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n' +
		'\n' +
		'	vec4 p0 = grad4(j0, ip);\n' +
		'	vec4 p1 = grad4(j1.x, ip);\n' +
		'	vec4 p2 = grad4(j1.y, ip);\n' +
		'	vec4 p3 = grad4(j1.z, ip);\n' +
		'	vec4 p4 = grad4(j1.w, ip);\n' +
		'\n' +
		// Normalise gradients
		'	vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n' +
		'	p0 *= norm.x;\n' +
		'	p1 *= norm.y;\n' +
		'	p2 *= norm.z;\n' +
		'	p3 *= norm.w;\n' +
		'	p4 *= taylorInvSqrt(dot(p4, p4));\n' +
		'\n' +
		// Mix contributions from the five corners
		'	vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n' +
		'	vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n' +
		'	m0 = m0 * m0;\n' +
		'	m1 = m1 * m1;\n' +
		'	return 49.0 * (dot(m0*m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2)))\n' +
		'							+ dot(m1*m1, vec2(dot(p3, x3), dot(p4, x4)))) ;\n' +
		'}\n' +
		'#endif\n';

	return Seriously;

}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.ascii.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	todo: consider an alternative algorithm:
	http://tllabs.io/asciistreetview/
	http://sol.gfxile.net/textfx/index.html
	*/

	var identity, letters;

	letters = document.createElement('img');
	letters.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAvAAAAAICAYAAACf+MsnAAAFY0lEQVR4Xu2Z644bOwyDN+//0NsOigEMQdRHyU6CFDnA+bHVWNaFojiTx8/Pz+/f/4/89/v7z9Xj8Tjib3XyTN9usFcMz8gt3h9zXf/O6nD/W1V7Vb9uXad+nHucZ9xenX7OqTHdSfmRXfmPsSn8xPMrllcfCkdVfHSe7Ned0/yp7jv2GPfqK+MCByc0zzvxKi5RPq8cuvE4+JrwpFM7N78K2yu+qb9kd3qV+ZjUx5n/+xnXP81ctW/UHQ5P3Gd360vxKf+n8dGpxXTeKu6h2ansFT6pvo5G2/FP99NsUf9d/xleInfetcj629m9cf9WOV5K+78R8ERGRLYO8VQiecd/1vwKEJV46JBJRzhRfXftVL/MTgM48UmL0l2OSmzs9kctAJfE4/1KkNFzbj8cjFHsJ/u460vhnPDfqddujJ27poLCWWBuHt0YKr/ki+yOKJnk5Z7pPLfLf4TZif+qvi7XuDWg+HbtNEe79ds9H7m1m2/3+YzLK5Hc9e/gYxdfNP+ZfdV9lT3usWn+9310/qiAdxa1O5gTEqVhoLudxVwVNPrvCqDp/ZX4d0Uk1Y7sbgyU4zooCk8nB3i9Y61V5wWpIjDlP+ZJsxPvmLxEOD2sntk5Pz1LBOb0L+sPfQGs6ksYpt7QAiHuUwtkgl+F3Qyf2YxTX53+Vdjfjc8VYIq7KT+abzof7ervZ8fX8d/Jyc3PmTcnRrrPEbyVTnD8T+Y38pH624mfNIr6muzO95S/sh1Gvog/XmW/a6N+scww43zgqLjcOX9cwFeESQK3Gpx32QggTlwk8Ei8OXfE4VMLeCLQiLBjfJM7VA069XefnZBGJz7Vr24dK3GwEoqLD7p/1+4IMWdRdxaMK9CmP4E62F7nm8S7s4B3BMCkBzQPVQ0IM06+2WLvzlDlI+NfF4d0ljiHuF/Zb/4m/4ojTgnA6f0qfiWA135P5l/NoFv/7txm+5ZyyOw0e1R/skd8ZKKwwnjXf9xLrkBV+2x3Pib9Vz3JOMaNL/KZ+oCkXhDUTLxEwLsC41OfI5DEYe9+mXfr0l2mJH5ISHTOUw2U8IjD5LyVUtxEmrvi4V5ejvijWNWicBbOyfsrYejkMMXmdIFEAZH19ASWnNyrPlBdKH+yU3y0gGjGKf4Mv51ft9zzKk83vul5qr9r7+CT9gHx2zvs0/yofpGX1AuC4svqhYJeJJydNZk/urcSxet91dfiUy94HX6oBHCHi5+F38svCeg1h+zZ6nyF5VUzVC8Q0X9LwE/IkMjmpJ3i27XvxuqQ0c4dp/JTfnb9T847AoNIW/nokIYrYKvnJvln/siPwtD0XAeTU+x0luEugWdLNeY4ecl260vxK8Efl3OnZi4uaZZIMBFeJ/hw6xrFvppvV1Q559d8MwwR50cskIBQ2KhE3y7/ZeddAUjxOr3diZ/8U3+I953z7uzR7Lj4rvjl9HxXvaHaOflSfSkf93y24xx94PpX89I5H2t9+fwK+KVzNOwdIeM+e905+ZqqRIj7pYHiU3FNFnBnkO+41EKige3cpX7GunwoARfjIwKrxNhEJFLfMrsbI+G/smfkojAa60vxPcNeCZCqhjSra6ydBaAWSFzaqnb01c4VEdVCWWPM7svstKDWuKrZpwUb7dVsOzPcxUeGdYdfdgV8Vr+Mv1R8Tn/iHcSNWR8jjjv9URzama9qbp0XlBP4y2Jw6u/E577AZTVz/BM/OfySzSjl79o73FRxaFdfuPG5/XE58PbXEvAT8UBn1HKuSIB8ThYwiZfJnd8z768Aib/3R/iN4J0VeMXcVwvynbl/735OBV6BKTfyT+e/T4/f7dP3uW8F3Aqs/PIHbWXeeeKjnSsAAAAASUVORK5CYII=";
	identity = new Float32Array([
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	]);

	Seriously.plugin('ascii', function () {
		var baseShader,
			scaledBuffer,
			lettersTexture,
			gl,
			width,
			height,
			scaledWidth,
			scaledHeight,
			unif;
		return {
			initialize: function (parent) {
				function setLetters() {
					gl.bindTexture(gl.TEXTURE_2D, lettersTexture);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, letters);
					gl.bindTexture(gl.TEXTURE_2D, null);
				}

				var me = this;

				parent();
				this.texture = this.frameBuffer.texture;

				gl = this.gl;

				lettersTexture = gl.createTexture();
				if (letters.naturalWidth) {
					setLetters();
				} else {
					letters.addEventListener('load', function () {
						setLetters();
						me.setDirty();
					});
				}

				unif = {
					letters: lettersTexture
				};

				//when the output scales up, don't smooth it out
				gl.bindTexture(gl.TEXTURE_2D, this.texture || this.frameBuffer && this.frameBuffer.texture);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.bindTexture(gl.TEXTURE_2D, null);

				scaledBuffer = new Seriously.util.FrameBuffer(gl, 1, 1);

				this.uniforms.transform = identity;
			},
			shader: function (inputs, shaderSource) {
				baseShader = new Seriously.util.ShaderProgram(this.gl, shaderSource.vertex, shaderSource.fragment);

				shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'uniform sampler2D letters;\n' +
					'uniform vec4 background;\n' +
					'uniform vec2 resolution;\n' +
					'\n' +
					'const vec3 lumcoeff = vec3(0.2125,0.7154,0.0721);\n' +
					'const vec2 fontSize = vec2(8.0, 8.0);\n' +
					'\n' +
					'vec4 lookup(float ascii) {\n' +
					'	vec2 pos = mod(vTexCoord * resolution, fontSize) / vec2(752.0, fontSize.x) + vec2(ascii, 0.0);\n' +
					'	return texture2D(letters, pos);\n' +
					'}\n' +
					'\n' +
					'void main(void) {\n' +
					'	vec4 sample = texture2D(source, vTexCoord);\n' +
					'	float luma = dot(sample.rgb,lumcoeff);\n' +
					'	vec4 clamped = vec4(floor(sample.rgb * 8.0) / 8.0, sample.a);\n' +
					'	float char = floor(luma * 94.0) / 94.0;\n' +
					'	gl_FragColor = mix(background, clamped, lookup(char).r);\n' +
					'}\n';

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, parent) {
				//set up scaledBuffer if (width or height have changed)
				if (height !== this.height || width !== this.width) {
					height = this.height;
					width = this.width;
					scaledWidth = Math.ceil(width / 8);
					scaledHeight = Math.ceil(height / 8);

					unif.resolution = uniforms.resolution;
					unif.transform = identity;

					scaledBuffer.resize(scaledWidth, scaledHeight);

					//so it stays blocky
					gl.bindTexture(gl.TEXTURE_2D, scaledBuffer.texture);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				}


				parent(baseShader, model, uniforms, scaledBuffer.frameBuffer, false, {
					width: scaledWidth,
					height: scaledHeight,
					blend: false
				});

				unif.source = scaledBuffer.texture;
				unif.background = uniforms.background;

				parent(shader, model, unif, frameBuffer);
			},
			destroy: function () {
				if (scaledBuffer) {
					scaledBuffer.destroy();
				}
				if (gl && lettersTexture) {
					gl.deleteTexture(lettersTexture);
				}
			}
		};
	},
	{
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			background: {
				type: 'color',
				uniform: 'background',
				defaultValue: [0, 0, 0, 1]
			}
		},
		description: 'Display image as ascii text in 8-bit color.',
		title: 'Ascii Text'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.bleach-bypass.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	Shader code:
	* Copyright vade - Anton Marini
	* Creative Commons, Attribution - Non Commercial - Share Alike 3.0

	http://v002.info/?page_id=34

	Modified to keep alpha channel constant
	*/

	Seriously.plugin('bleach-bypass', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'\n' +
				'uniform float amount;\n' +
				'\n' +
				'//constant variables.\n' +
				'const vec4 one = vec4(1.0);\n' +
				'const vec4 two = vec4(2.0);\n' +
				'const vec4 lumcoeff = vec4(0.2125,0.7154,0.0721,0.0);\n' +
				'\n' +
				'vec4 overlay(vec4 myInput, vec4 previousmix, vec4 amount) {\n' +
				'	float luminance = dot(previousmix,lumcoeff);\n' +
				'	float mixamount = clamp((luminance - 0.45) * 10.0, 0.0, 1.0);\n' +
				'\n' +
				'	vec4 branch1 = two * previousmix * myInput;\n' +
				'	vec4 branch2 = one - (two * (one - previousmix) * (one - myInput));\n' +
				'\n' +
				'	vec4 result = mix(branch1, branch2, vec4(mixamount) );\n' +
				'\n' +
				'	return mix(previousmix, result, amount);\n' +
				'}\n' +
				'\n' +
				'void main (void)  {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	vec4 luma = vec4(vec3(dot(pixel,lumcoeff)), pixel.a);\n' +
				'	gl_FragColor = overlay(luma, pixel, vec4(amount));\n' +
				'\n' +
				'} \n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 1,
				min: 0,
				max: 1
			}
		},
		title: 'Bleach Bypass',
		categories: ['film'],
		description: 'Bleach Bypass film treatment\n' +
					'http://en.wikipedia.org/wiki/Bleach_bypass\n' +
					'see: "Saving Private Ryan", "Minority Report"'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.blend.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	todo: for prototype version, blend only handles two layers. this should handle multiple layers?
	todo: if transforms are used, do multiple passes and enable depth testing?
	todo: for now, only supporting float blend modes. Add complex ones
	todo: apply proper credit and license

	** Romain Dura | Romz
	** Blog: http://blog.mouaif.org
	** Post: http://blog.mouaif.org/?p=94

	*/
	var modes = {
		'normal': 'BlendNormal',
		'lighten': 'BlendLighten',
		'darken': 'BlendDarken',
		'multiply': 'BlendMultiply',
		'average': 'BlendAverage',
		'add': 'BlendAdd',
		'subtract': 'BlendSubtract',
		'difference': 'BlendDifference',
		'negation': 'BlendNegation',
		'exclusion': 'BlendExclusion',
		'screen': 'BlendScreen',
		'overlay': 'BlendOverlay',
		'softlight': 'BlendSoftLight',
		'hardlight': 'BlendHardLight',
		'colordodge': 'BlendColorDodge',
		'colorburn': 'BlendColorBurn',
		'lineardodge': 'BlendLinearDodge',
		'linearburn': 'BlendLinearBurn',
		'linearlight': 'BlendLinearLight',
		'vividlight': 'BlendVividLight',
		'pinlight': 'BlendPinLight',
		'hardmix': 'BlendHardMix',
		'reflect': 'BlendReflect',
		'glow': 'BlendGlow',
		'phoenix': 'BlendPhoenix'
	},
	nativeBlendModes = {
		normal: ['FUNC_ADD', 'SRC_ALPHA', 'ONE_MINUS_SRC_ALPHA', 'SRC_ALPHA', 'DST_ALPHA']/*,
		add: ['FUNC_ADD', 'SRC_ALPHA', 'ONE_MINUS_SRC_ALPHA', 'SRC_ALPHA', 'DST_ALPHA']*/
	},
	identity = new Float32Array([
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	]);

	Seriously.plugin('blend', function () {
		var topUniforms,
			bottomUniforms,
			topOpts = {
				clear: false
			};

		// custom resize method
		this.resize = function () {
			var width,
				height,
				mode = this.inputs.sizeMode,
				node,
				fn,
				i,
				bottom = this.inputs.bottom,
				top = this.inputs.top;

			if (mode === 'bottom' || mode === 'top') {
				node = this.inputs[mode];
				if (node) {
					width = node.width;
					height = node.height;
				} else {
					width = 1;
					height = 1;
				}
			} else {
				if (bottom) {
					if (top) {
						fn = (mode === 'union' ? Math.max : Math.min);
						width = fn(bottom.width, top.width);
						height = fn(bottom.height, top.height);
					} else {
						width = bottom.width;
						height = bottom.height;
					}
				} else if (top) {
					width = top.width;
					height = top.height;
				} else {
					width = 1;
					height = 1;
				}
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.uniforms.resolution[0] = width;
				this.uniforms.resolution[1] = height;

				if (this.frameBuffer) {
					this.frameBuffer.resize(width, height);
				}

				this.setDirty();
			}

			if (topUniforms) {
				if (bottom) {
					bottomUniforms.resolution[0] = bottom.width;
					bottomUniforms.resolution[1] = bottom.height;
				}
				if (top) {
					topUniforms.resolution[0] = top.width;
					topUniforms.resolution[1] = top.height;
				}
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		return {
			shader: function (inputs, shaderSource) {
				var mode = inputs.mode || 'normal',
					node;
				mode = mode.toLowerCase();

				if (nativeBlendModes[mode]) {
					//todo: move this to an 'update' event for 'mode' input
					if (!topUniforms) {
						node = this.inputs.top;
						topUniforms = {
							resolution: [
								node && node.width || 1,
								node && node.height || 1
							],
							targetRes: this.uniforms.resolution,
							source: node,
							transform: node && node.cumulativeMatrix || identity,
							opacity: 1
						};

						node = this.inputs.bottom;
						bottomUniforms = {
							resolution: [
								node && node.width || 1,
								node && node.height || 1
							],
							targetRes: this.uniforms.resolution,
							source: node,
							transform: node && node.cumulativeMatrix || identity,
							opacity: 1
						};
					}

					shaderSource.vertex = [
						'precision mediump float;',

						'attribute vec4 position;',
						'attribute vec2 texCoord;',

						'uniform vec2 resolution;',
						'uniform vec2 targetRes;',
						'uniform mat4 transform;',

						'varying vec2 vTexCoord;',
						'varying vec4 vPosition;',

						'void main(void) {',
						// first convert to screen space
						'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
						'	screenPosition = transform * screenPosition;',

						// convert back to OpenGL coords
						'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
						'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
						'	gl_Position.xy *= resolution / targetRes;',
						'	gl_Position.w = screenPosition.w;',
						'	vTexCoord = texCoord;',
						'	vPosition = gl_Position;',
						'}\n'
					].join('\n');

					shaderSource.fragment = [
						'precision mediump float;',
						'varying vec2 vTexCoord;',
						'varying vec4 vPosition;',
						'uniform sampler2D source;',
						'uniform float opacity;',
						'void main(void) {',
						'	gl_FragColor = texture2D(source, vTexCoord);',
						'	gl_FragColor.a *= opacity;',
						'}'
					].join('\n');

					return shaderSource;
				}

				topUniforms = null;
				bottomUniforms = null;

				mode = modes[mode] || 'BlendNormal';
				shaderSource.fragment = '#define BlendFunction ' + mode + '\n' +
					'#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'#define BlendLinearDodgef				BlendAddf\n' +
					'#define BlendLinearBurnf				BlendSubtractf\n' +
					'#define BlendAddf(base, blend)			min(base + blend, 1.0)\n' +
					'#define BlendSubtractf(base, blend)	max(base + blend - 1.0, 0.0)\n' +
					'#define BlendLightenf(base, blend)		max(blend, base)\n' +
					'#define BlendDarkenf(base, blend)		min(blend, base)\n' +
					'#define BlendLinearLightf(base, blend)	(blend < 0.5 ? BlendLinearBurnf(base, (2.0 * blend)) : BlendLinearDodgef(base, (2.0 * (blend - 0.5))))\n' +
					'#define BlendScreenf(base, blend)		(1.0 - ((1.0 - base) * (1.0 - blend)))\n' +
					'#define BlendOverlayf(base, blend)		(base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\n' +
					'#define BlendSoftLightf(base, blend)	((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))\n' +
					'#define BlendColorDodgef(base, blend)	((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))\n' +
					'#define BlendColorBurnf(base, blend)	((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))\n' +
					'#define BlendVividLightf(base, blend)	((blend < 0.5) ? BlendColorBurnf(base, (2.0 * blend)) : BlendColorDodgef(base, (2.0 * (blend - 0.5))))\n' +
					'#define BlendPinLightf(base, blend)	((blend < 0.5) ? BlendDarkenf(base, (2.0 * blend)) : BlendLightenf(base, (2.0 *(blend - 0.5))))\n' +
					'#define BlendHardMixf(base, blend)		((BlendVividLightf(base, blend) < 0.5) ? 0.0 : 1.0)\n' +
					'#define BlendReflectf(base, blend)		((blend == 1.0) ? blend : min(base * base / (1.0 - blend), 1.0))\n' +
					/*
					** Vector3 blending modes
					*/

					// Component wise blending
					'#define Blend(base, blend, funcf)		vec3(funcf(base.r, blend.r), funcf(base.g, blend.g), funcf(base.b, blend.b))\n' +
					'#define BlendNormal(base, blend)		(blend)\n' +
					'#define BlendLighten					BlendLightenf\n' +
					'#define BlendDarken					BlendDarkenf\n' +
					'#define BlendMultiply(base, blend)		(base * blend)\n' +
					'#define BlendAverage(base, blend)		((base + blend) / 2.0)\n' +
					'#define BlendAdd(base, blend)			min(base + blend, vec3(1.0))\n' +
					'#define BlendSubtract(base, blend)	max(base + blend - vec3(1.0), vec3(0.0))\n' +
					'#define BlendDifference(base, blend)	abs(base - blend)\n' +
					'#define BlendNegation(base, blend)		(vec3(1.0) - abs(vec3(1.0) - base - blend))\n' +
					'#define BlendExclusion(base, blend)	(base + blend - 2.0 * base * blend)\n' +
					'#define BlendScreen(base, blend)		Blend(base, blend, BlendScreenf)\n' +
					'#define BlendOverlay(base, blend)		Blend(base, blend, BlendOverlayf)\n' +
					'#define BlendSoftLight(base, blend)	Blend(base, blend, BlendSoftLightf)\n' +
					'#define BlendHardLight(base, blend)	BlendOverlay(blend, base)\n' +
					'#define BlendColorDodge(base, blend)	Blend(base, blend, BlendColorDodgef)\n' +
					'#define BlendColorBurn(base, blend)	Blend(base, blend, BlendColorBurnf)\n' +
					'#define BlendLinearDodge				BlendAdd\n' +
					'#define BlendLinearBurn				BlendSubtract\n' +
					// Linear Light is another contrast-increasing mode
					// If the blend color is darker than midgray, Linear Light darkens the image by decreasing the brightness. If the blend color is lighter than midgray, the result is a brighter image due to increased brightness.
					'#define BlendLinearLight(base, blend)	Blend(base, blend, BlendLinearLightf)\n' +
					'#define BlendVividLight(base, blend)	Blend(base, blend, BlendVividLightf)\n' +
					'#define BlendPinLight(base, blend)		Blend(base, blend, BlendPinLightf)\n' +
					'#define BlendHardMix(base, blend)		Blend(base, blend, BlendHardMixf)\n' +
					'#define BlendReflect(base, blend)		Blend(base, blend, BlendReflectf)\n' +
					'#define BlendGlow(base, blend)			BlendReflect(blend, base)\n' +
					'#define BlendPhoenix(base, blend)		(min(base, blend) - max(base, blend) + vec3(1.0))\n' +
					//'#define BlendOpacity(base, blend, F, O)	(F(base, blend) * O + blend * (1.0 - O))\n' +
					'#define BlendOpacity(base, blend, BlendFn, Opacity, Alpha)	((BlendFn(base.rgb * blend.a * Opacity, blend.rgb * blend.a * Opacity) + base.rgb * base.a * (1.0 - blend.a * Opacity)) / Alpha)\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D top;\n' +
					'\n' +
					'uniform sampler2D bottom;\n' +
					'\n' +
					'uniform float opacity;\n' +
					'\n' +
					'void main(void) {\n' +
					'	vec3 color;\n' +
					'	vec4 topPixel = texture2D(top, vTexCoord);\n' +
					'	vec4 bottomPixel = texture2D(bottom, vTexCoord);\n' +

					'	float alpha = topPixel.a + bottomPixel.a * (1.0 - topPixel.a);\n' +
					'	if (alpha == 0.0) {\n' +
					'		color = vec3(0.0);\n' +
					'	} else {\n' +
					'		color = BlendOpacity(bottomPixel, topPixel, BlendFunction, opacity, alpha);\n' +
					'	}\n' +
					'	gl_FragColor = vec4(color, alpha);\n' +
					'}\n';

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, draw) {
				if (nativeBlendModes[this.inputs.mode]) {
					if (this.inputs.bottom) {
						draw(shader, model, bottomUniforms, frameBuffer);
					}

					if (this.inputs.top) {
						draw(shader, model, topUniforms, frameBuffer, null, topOpts);
					}
				} else {
					draw(shader, model, uniforms, frameBuffer);
				}
			},
			inputs: {
				top: {
					type: 'image',
					uniform: 'top',
					update: function () {
						if (topUniforms) {
							topUniforms.source = this.inputs.top;
							topUniforms.transform = this.inputs.top.cumulativeMatrix || identity;
						}
						this.resize();
					}
				},
				bottom: {
					type: 'image',
					uniform: 'bottom',
					update: function () {
						if (bottomUniforms) {
							bottomUniforms.source = this.inputs.bottom;
							bottomUniforms.transform = this.inputs.bottom.cumulativeMatrix || identity;
						}
						this.resize();
					}
				},
				opacity: {
					type: 'number',
					uniform: 'opacity',
					defaultValue: 1,
					min: 0,
					max: 1,
					update: function (opacity) {
						if (topUniforms) {
							topUniforms.opacity = opacity;
						}
					}
				},
				sizeMode: {
					type: 'enum',
					defaultValue: 'bottom',
					options: [
						'bottom',
						'top',
						'union',
						'intersection'
					],
					update: function () {
						this.resize();
					}
				},
				mode: {
					type: 'enum',
					shaderDirty: true,
					defaultValue: 'normal',
					options: [
						['normal', 'Normal'],
						['lighten', 'Lighten'],
						['darken', 'Darken'],
						['multiply', 'Multiply'],
						['average', 'Average'],
						['add', 'Add'],
						['substract', 'Substract'],
						['difference', 'Difference'],
						['negation', 'Negation'],
						['exclusion', 'Exclusion'],
						['screen', 'Screen'],
						['overlay', 'Overlay'],
						['softlight', 'Soft Light'],
						['hardlight', 'Hard Light'],
						['colordodge', 'Color Dodge'],
						['colorburn', 'Color Burn'],
						['lineardodge', 'Linear Dodge'],
						['linearburn', 'Linear Burn'],
						['linearlight', 'Linear Light'],
						['vividlight', 'Vivid Light'],
						['pinlight', 'Pin Light'],
						['hardmix', 'Hard Mix'],
						['reflect', 'Reflect'],
						['glow', 'Glow'],
						['phoenix', 'Phoenix']
					]
				}
			}
		};
	},
	{
		inPlace: function () {
			return !!nativeBlendModes[this.inputs.mode];
		},
		description: 'Blend two layers',
		title: 'Blend'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.blur.js", function(exports, require, module){
/* global define, require */
/*
Blur

Adapted from v002 by Anton Marini and Tom Butterworth
* Copyright vade - Anton Marini
* Creative Commons, Attribution - Non Commercial - Share Alike 3.0

http://v002.info/plugins/v002-blurs/
*/
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var passes = [0.2, 0.3, 0.5, 0.8, 1],
		finalPass = passes.length - 1,
		horizontal = [1, 0],
		vertical = [0, 1],
		identity = new Float32Array([
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		]);

	Seriously.plugin('blur', function (options) {
		var fbHorizontal,
			fbVertical,
			baseShader,
			loopUniforms = {
				amount: 0,
				inputScale: 1,
				resolution: [this.width, this.height],
				transform: identity,
				direction: null,
				projection: new Float32Array([
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
				])
			};

		return {
			initialize: function (parent) {
				var gl;

				parent();

				gl = this.gl;

				if (!gl) {
					return;
				}

				fbHorizontal = new Seriously.util.FrameBuffer(gl, this.width, this.height);
				fbVertical = new Seriously.util.FrameBuffer(gl, this.width, this.height);
			},
			shader: function (inputs, shaderSource) {
				var gl = this.gl,
					/*
					Some devices or browsers (e.g. IE11 preview) don't support enough
					varying vectors, so we need to fallback to a less efficient method
					*/
					maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS),
					defineVaryings = (maxVaryings >= 10 ? '#define USE_VARYINGS' : '');

				baseShader = new Seriously.util.ShaderProgram(gl, shaderSource.vertex, shaderSource.fragment);

				shaderSource.vertex = [
					defineVaryings,
					'#define PI ' + Math.PI,
					'precision mediump float;',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					'uniform mat4 projection;',
					'uniform mat4 transform;',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'uniform vec2 direction;',
					'uniform float amount;',
					'uniform float inputScale;',

					'const vec2 zero = vec2(0.0, 0.0);',
					'#ifdef USE_VARYINGS',
					'vec2 one;',
					'vec2 amount1;',
					'varying vec2 vTexCoord1;',
					'varying vec2 vTexCoord2;',
					'varying vec2 vTexCoord3;',
					'varying vec2 vTexCoord4;',
					'varying vec2 vTexCoord5;',
					'varying vec2 vTexCoord6;',
					'varying vec2 vTexCoord7;',
					'varying vec2 vTexCoord8;',
					'#else',
					'varying vec2 one;',
					'varying vec2 amount1;',
					'#endif',

					'void main(void) {',
					// first convert to screen space
					'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
					'	screenPosition = transform * screenPosition;',

					// convert back to OpenGL coords
					'	gl_Position = screenPosition;',
					'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
					'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
					'	vTexCoord = texCoord;',
					'	vPosition = gl_Position;',

					'	one = vec2(1.0, 1.0) * inputScale;',
					'	if (inputScale < 1.0) {',
					'		one -= 1.0 / resolution;',
					'	}',
					//'	one *= inputScale;',
					'	vTexCoord = max(zero, min(one, texCoord.st * inputScale));',
					'	amount1 = direction * (inputScale * amount * 5.0 / resolution);',

					'#ifdef USE_VARYINGS',
					'	vec2 amount2 = amount1 * 3.0;',
					'	vec2 amount3 = amount1 * 6.0;',
					'	vec2 amount4 = amount1 * 9.0;',
					'	vec2 amount5 = -amount1;',
					'	vec2 amount6 = amount5 * 3.0;',
					'	vec2 amount7 = amount5 * 6.0;',
					'	vec2 amount8 = amount5 * 9.0;',
					'	vTexCoord1 = max(zero, min(one, vTexCoord + amount1));',
					'	vTexCoord2 = max(zero, min(one, vTexCoord + amount2));',
					'	vTexCoord3 = max(zero, min(one, vTexCoord + amount3));',
					'	vTexCoord4 = max(zero, min(one, vTexCoord + amount4));',
					'	vTexCoord5 = max(zero, min(one, vTexCoord + amount5));',
					'	vTexCoord6 = max(zero, min(one, vTexCoord + amount6));',
					'	vTexCoord7 = max(zero, min(one, vTexCoord + amount7));',
					'	vTexCoord8 = max(zero, min(one, vTexCoord + amount8));',
					'#endif',
					'}'
				].join('\n');
				shaderSource.fragment = [
					defineVaryings,

					'precision mediump float;\n',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'uniform sampler2D source;',
					'uniform float angle;',
					'uniform float amount;',
					'uniform float inputScale;',

					'#ifdef USE_VARYINGS',
					'varying vec2 vTexCoord1;',
					'varying vec2 vTexCoord2;',
					'varying vec2 vTexCoord3;',
					'varying vec2 vTexCoord4;',
					'varying vec2 vTexCoord5;',
					'varying vec2 vTexCoord6;',
					'varying vec2 vTexCoord7;',
					'varying vec2 vTexCoord8;',
					'#else',
					'varying vec2 amount1;',
					'varying vec2 one;',
					'const vec2 zero = vec2(0.0, 0.0);',
					'#endif',

					'void main(void) {',
					'#ifndef USE_VARYINGS',
					'	vec2 vTexCoord1 = max(zero, min(one, vTexCoord + amount1));',
					'	vec2 vTexCoord2 = max(zero, min(one, vTexCoord + amount1 * 3.0));',
					'	vec2 vTexCoord3 = max(zero, min(one, vTexCoord + amount1 * 6.0));',
					'	vec2 vTexCoord4 = max(zero, min(one, vTexCoord + amount1 * 9.0));',
					'	vec2 vTexCoord5 = max(zero, min(one, vTexCoord - amount1));',
					'	vec2 vTexCoord6 = max(zero, min(one, vTexCoord - amount1 * 3.0));',
					'	vec2 vTexCoord7 = max(zero, min(one, vTexCoord - amount1 * 6.0));',
					'	vec2 vTexCoord8 = max(zero, min(one, vTexCoord - amount1 * 9.0));',
					'#endif',
					'	gl_FragColor = texture2D(source, vTexCoord) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord1) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord2) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord3) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord4) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord5) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord6) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord7) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord8) / 9.0;',
					'}'
				].join('\n');

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, parent) {
				var i,
					pass,
					amount,
					width,
					height,
					opts = {
						width: 0,
						height: 0,
						blend: false
					},
					previousPass = 1;

				amount = this.inputs.amount;
				if (!amount) {
					uniforms.source = this.inputs.source.texture;
					parent(baseShader, model, uniforms, frameBuffer);
					return;
				}

				if (amount <= 0.01) {
					//horizontal pass
					uniforms.inputScale = 1;
					uniforms.direction = horizontal;
					uniforms.source = this.inputs.source.texture;
					parent(shader, model, uniforms, fbHorizontal.frameBuffer);

					//vertical pass
					uniforms.direction = vertical;
					uniforms.source = fbVertical.texture;
					parent(shader, model, uniforms, frameBuffer);
					return;
				}

				loopUniforms.amount = amount;
				loopUniforms.source = this.inputs.source.texture;
				loopUniforms.projection[0] = this.height / this.width;

				for (i = 0; i < passes.length; i++) {
					pass = Math.min(1, passes[i] / amount);
					width = Math.floor(pass * this.width);
					height = Math.floor(pass * this.height);

					loopUniforms.resolution[0] = width;
					loopUniforms.resolution[1] = height;
					loopUniforms.inputScale = previousPass;
					previousPass = pass;

					opts.width = width;
					opts.height = height;

					//horizontal pass
					loopUniforms.direction = horizontal;
					parent(shader, model, loopUniforms, fbHorizontal.frameBuffer, null, opts);

					//vertical pass
					loopUniforms.inputScale = pass;
					loopUniforms.source = fbHorizontal.texture;
					loopUniforms.direction = vertical;
					parent(shader, model, loopUniforms, i === finalPass ? frameBuffer : fbVertical.frameBuffer, null, opts);

					loopUniforms.source = fbVertical.texture;
				}
			},
			resize: function () {
				loopUniforms.resolution[0] = this.width;
				loopUniforms.resolution[1] = this.height;
				if (fbHorizontal) {
					fbHorizontal.resize(this.width, this.height);
					fbVertical.resize(this.width, this.height);
				}
			},
			destroy: function () {
				if (fbHorizontal) {
					fbHorizontal.destroy();
					fbVertical.destroy();
					fbHorizontal = null;
					fbVertical = null;
				}

				if (baseShader) {
					baseShader.destroy();
				}

				loopUniforms = null;
			}
		};
	},
	{
		inputs: {
			source: {
				type: 'image',
				shaderDirty: false
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 0.2,
				min: 0,
				max: 1
			}
		},
		title: 'Gaussian Blur'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.brightness-contrast.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('brightness-contrast', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES\n',
				'precision mediump float;\n',
				'#endif\n',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform float brightness;',
				'uniform float saturation;',
				'uniform float contrast;',

				'const vec3 half3 = vec3(0.5);',

				'void main(void) {',
				'	vec4 pixel = texture2D(source, vTexCoord);',

				//adjust brightness
				'	vec3 color = pixel.rgb * brightness;',

				//adjust contrast
				'	color = (color - half3) * contrast + half3;',

				//keep alpha the same
				'	gl_FragColor = vec4(color, pixel.a);',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			brightness: {
				type: 'number',
				uniform: 'brightness',
				defaultValue: 1,
				min: 0
			},
			contrast: {
				type: 'number',
				uniform: 'contrast',
				defaultValue: 1,
				min: 0
			}
		},
		title: 'Brightness/Contrast',
		description: 'Multiply brightness and contrast values. Works the same as CSS filters.'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.channels.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var channelOptions = [
			'Red',
			'Green',
			'Blue',
			'Alpha'
		],
		channelLookup = {
			r: 0,
			g: 1,
			b: 2,
			a: 3,
			x: 0,
			y: 1,
			z: 2,
			w: 3
		};

	Seriously.plugin('channels', function () {
		var sources = [],
			shaders = [],
			matrices = [],
			me = this;

		function validateChannel(value, input, name) {
			var val;
			if (typeof value === 'string') {
				val = value.charAt(0).toLowerCase();
				val = channelLookup[val];
				if (val === undefined) {
					val = -1;
				}
				if (val < 0) {
					val = parseFloat(value);
				}
			} else {
				val = value;
			}

			if (val === 0 || val === 1 || val === 2 || val === 3) {
				return val;
			}

			return me.inputs[name];
		}

		function updateChannels() {
			var inputs = me.inputs,
				i, j,
				source,
				matrix;

			for (i = 0; i < sources.length; i++) {
				source = sources[i];
				matrix = matrices[i];
				if (!matrix) {
					matrix = matrices[i] = [];
					me.uniforms['channels' + i] = matrix;
				}

				for (j = 0; j < 16; j++) {
					matrix[j] = 0;
				}

				matrix[inputs.red] = (inputs.redSource === source) ? 1 : 0;
				matrix[4 + inputs.green] = (inputs.greenSource === source) ? 1 : 0;
				matrix[8 + inputs.blue] = (inputs.blueSource === source) ? 1 : 0;
				matrix[12 + inputs.alpha] = (inputs.alphaSource === source) ? 1 : 0;
			}
		}

		function updateSources() {
			var inputs = me.inputs;

			function validateSource(name) {
				var s, j;
				s = inputs[name];
				if (!s) {
					s = inputs[name] = inputs.source;
				}

				j = sources.indexOf(s);
				if (j < 0) {
					j = sources.length;
					sources.push(s);
					me.uniforms['source' + j] = s;
				}
			}
			sources.length = 0;

			validateSource('redSource');
			validateSource('greenSource');
			validateSource('blueSource');
			validateSource('alphaSource');

			me.resize();

			updateChannels();
		}

		// custom resize method
		this.resize = function () {
			var width,
				height,
				mode = this.inputs.sizeMode,
				i,
				resolution,
				source;

			if (!sources.length) {
				width = 1;
				height = 1;
			} else if (sources.length === 1) {
				source = sources[0];
				width = source.width;
				height = source.height;
			} else if (mode === 'union') {
				width = 0;
				height = 0;
				for (i = 0; i < sources.length; i++) {
					source = sources[0];
					width = Math.max(width, source.width);
					height = Math.max(height, source.height);
				}
			} else if (mode === 'intersection') {
				width = Infinity;
				height = Infinity;
				for (i = 0; i < sources.length; i++) {
					source = sources[0];
					width = Math.min(width, source.width);
					height = Math.min(height, source.height);
				}
			} else {
				source = me.inputs[mode + 'Source'];
				if (source) {
					width = source.width;
					height = source.height;
				} else {
					width = 1;
					height = 1;
				}
			}

			for (i = 0; i < sources.length; i++) {
				source = sources[i];
				resolution = me.uniforms['resolution' + i];
				if (resolution) {
					resolution[0] = source.width;
					resolution[1] = source.height;
				} else {
					me.uniforms['resolution' + i] = [source.width, source.height];
				}
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.uniforms.resolution[0] = width;
				this.uniforms.resolution[1] = height;

				if (this.frameBuffer) {
					this.frameBuffer.resize(width, height);
				}

				this.setDirty();
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		return {
			shader: function () {
				var i,
					frag,
					vert,
					shader,
					uniforms = '',
					samples = '',
					varyings = '',
					position = '';

				/*
				We'll restore this and the draw function below if we ever figure out a way to
				add/& multiple renders without screwing up the brightness
				shaderSource.fragment = [
					'#ifdef GL_ES',
					'precision mediump float;',
					'#endif',
					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',
					'uniform mat4 channels;',
					'uniform sampler2D source;',
					//'uniform sampler2D previous;',
					'void main(void) {',
					'	vec4 pixel;',
					'	if (any(lessThan(vTexCoord, vec2(0.0))) || any(greaterThanEqual(vTexCoord, vec2(1.0)))) {',
					'		pixel = vec4(0.0);',
					'	} else {',
					'		pixel = texture2D(source, vTexCoord) * channels;',
					//'		if (gl_FragColor.a == 0.0) gl_FragColor.a = 1.0;',
					'	}',
					'	gl_FragColor = pixel;',
					'}'
				].join('\n');

				return shaderSource;
				*/
				if (shaders[sources.length]) {
					return shaders[sources.length];
				}

				for (i = 0; i < sources.length; i++) {
					varyings += 'varying vec2 vTexCoord' + i + ';\n';

					uniforms += 'uniform sampler2D source' + i + ';\n' +
						'uniform mat4 channels' + i + ';\n' +
						'uniform vec2 resolution' + i + ';\n\n';

					position += '    vTexCoord' + i + ' = (position.xy * resolution / resolution' + i + ') * 0.5 + 0.5;\n';

					samples += '    if (all(greaterThanEqual(vTexCoord' + i + ', vec2(0.0))) && all(lessThan(vTexCoord' + i + ', vec2(1.0)))) {\n' +
						'        gl_FragColor += texture2D(source' + i + ', vTexCoord' + i + ') * channels' + i + ';\n    }\n';
				}

				vert = ['#ifdef GL_ES',
					'precision mediump float;',
					'#endif',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					uniforms,

					varyings,

					'void main(void) {',
					position,
					'	gl_Position = position;',
					'}\n'
				].join('\n');

				frag = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					varyings +
					'\n' +
					uniforms +
					'\n' +
					'void main(void) {\n' +
					'	gl_FragColor = vec4(0.0);\n' +
					samples +
					'}\n';

				shader = new Seriously.util.ShaderProgram(this.gl,
					vert,
					frag);

				shaders[sources.length] = shader;
				return shader;
			},
			/*
			draw: function (shader, model, uniforms, frameBuffer, draw) {
				var i,
					source;

				options.clear = true;
				for (i = 0; i < sources.length; i++) {
				//for (i = sources.length - 1; i >= 0; i--) {
					uniforms.channels = matrices[i];
					source = sources[i];
					uniforms.source = sources[i];
					//uniforms.resolution[]

					draw(shader, model, uniforms, frameBuffer, null, options);
					options.clear = false;
				}
			},
			*/
			inputs: {
				sizeMode: {
					type: 'enum',
					defaultValue: 'red',
					options: [
						'red',
						'green',
						'blue',
						'alpha',
						'union',
						'intersection'
					],
					update: function () {
						this.resize();
					}
				},
				source: {
					type: 'image',
					update: updateSources,
					shaderDirty: true
				},
				redSource: {
					type: 'image',
					update: updateSources,
					shaderDirty: true
				},
				greenSource: {
					type: 'image',
					update: updateSources,
					shaderDirty: true
				},
				blueSource: {
					type: 'image',
					update: updateSources,
					shaderDirty: true
				},
				alphaSource: {
					type: 'image',
					update: updateSources,
					shaderDirty: true
				},
				red: {
					type: 'enum',
					options: channelOptions,
					validate: validateChannel,
					update: updateChannels,
					defaultValue: 0
				},
				green: {
					type: 'enum',
					options: channelOptions,
					validate: validateChannel,
					update: updateChannels,
					defaultValue: 1
				},
				blue: {
					type: 'enum',
					options: channelOptions,
					validate: validateChannel,
					update: updateChannels,
					defaultValue: 2
				},
				alpha: {
					type: 'enum',
					options: channelOptions,
					validate: validateChannel,
					update: updateChannels,
					defaultValue: 3
				}
			}
		};
	},
	{
		inPlace: false,
		title: 'Channel Mapping'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.chroma.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*	experimental chroma key algorithm
		todo: see if we can minimize branching
		todo: calculate HSL of screen color outside shader
		todo: try allowing some color despill on opaque pixels
		todo: add different modes?
		todo: rename parameters
	*/
	Seriously.plugin('chroma', {
		shader: function (inputs, shaderSource) {
			shaderSource.vertex = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif ',

				'attribute vec4 position;',
				'attribute vec2 texCoord;',

				'uniform vec2 resolution;',
				'uniform mat4 transform;',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform vec4 screen;',
				'uniform float balance;',
				'varying float screenSat;',
				'varying vec3 screenPrimary;',

				'void main(void) {',
				'	float fmin = min(min(screen.r, screen.g), screen.b);    //Min. value of RGB',
				'	float fmax = max(max(screen.r, screen.g), screen.b);    //Max. value of RGB',
				'	float secondaryComponents;',

				//'	luminance = (fmax + fmin) / 2.0; // Luminance',
				//'	screenSat = fmax - fmin; // Saturation',
				'	screenPrimary = step(fmax, screen.rgb);',
				'	secondaryComponents = dot(1.0 - screenPrimary, screen.rgb);',
				'	screenSat = fmax - mix(secondaryComponents - fmin, secondaryComponents / 2.0, balance);',

				// first convert to screen space
				'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
				'	screenPosition = transform * screenPosition;',

				// convert back to OpenGL coords
				'	gl_Position = screenPosition;',
				'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
				'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
				'	vTexCoord = texCoord;',
				'	vPosition = gl_Position;',
				'}'
			].join('\n');
			shaderSource.fragment = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform vec4 screen;',
				'uniform float screenWeight;',
				'uniform float balance;',
				'uniform float clipBlack;',
				'uniform float clipWhite;',
				'uniform bool mask;',

				'varying float screenSat;',
				'varying vec3 screenPrimary;',

				'vec4 sourcePixel;',

				'const mat3 yuv = mat3(',
				'	54.213, 182.376, 18.411,',
				'	-54.213, -182.376, 236.589,',
				'	200.787, -182.376, -18.411',
				');',

				'float round(float n) {',
				'	return floor(n) + step(0.5, fract(n));',
				'}',

				'void main(void) {',
				'	float pixelSat, luminance, secondaryComponents;',
				'	vec3 pixelPrimary;',
				'	vec4 pixel = vec4(0.0);',
				'	sourcePixel = texture2D(source, vTexCoord);',

				'	float fmin = min(min(sourcePixel.r, sourcePixel.g), sourcePixel.b);    //Min. value of RGB',
				'	float fmax = max(max(sourcePixel.r, sourcePixel.g), sourcePixel.b);    //Max. value of RGB',
				//'	float delta = fmax - fmin;             //Delta RGB value',

				//'	luminance = (fmax + fmin) / 2.0; // Luminance',
				//'	luminance = dot(vec3(0.3, 0.59, 0.11), sourcePixel.rgb); // Luminance',
				'	luminance = fmax; // Luminance',
				'	pixelPrimary = step(fmax, sourcePixel.rgb);',
				//'	pixelSat = delta; // Saturation',
				'	secondaryComponents = dot(1.0 - pixelPrimary, sourcePixel.rgb);',
				'	pixelSat = fmax - mix(secondaryComponents - fmin, secondaryComponents / 2.0, balance);', // Saturation
				'	if (pixelSat < 0.1 || luminance < 0.1 || any(notEqual(pixelPrimary, screenPrimary))) {',
				'		pixel = sourcePixel;',
				//'		pixel = vec4(1.0);',

				'	} else if (pixelSat < screenSat) {',
				'		float alpha = 1.0 - pixelSat / screenSat;',
				'		alpha = smoothstep(clipBlack, clipWhite, alpha);',
				//'		float despill = alpha / screenWeight;',
				'		pixel = vec4((sourcePixel.rgb - (1.0 - alpha) * screen.rgb * screenWeight) / alpha, alpha);',
				//'		pixel = vec4(vec3(alpha), 1.0);',
				'	}',

				'	if (mask) {',
				'		gl_FragColor = vec4(vec3(pixel.a), 1.0);',
				'	} else {',
				'		gl_FragColor = pixel;',
				'	}',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			screen: {
				type: 'color',
				uniform: 'screen',
				defaultValue: [66 / 255, 195 / 255, 31 / 255, 1]
			},
			weight: {
				type: 'number',
				uniform: 'screenWeight',
				defaultValue: 1,
				min: 0
			},
			balance: {
				type: 'number',
				uniform: 'balance',
				defaultValue: 1,
				min: 0,
				max: 1
			},
			clipBlack: {
				type: 'number',
				uniform: 'clipBlack',
				defaultValue: 0,
				min: 0,
				max: 1
			},
			clipWhite: {
				type: 'number',
				uniform: 'clipWhite',
				defaultValue: 1,
				min: 0,
				max: 1
			},
			mask: {
				type: 'boolean',
				defaultValue: false,
				uniform: 'mask'
			}

		},
		title: 'Chroma Key',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.color.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('color', {
		shader: function(inputs, shaderSource, utilities) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform vec4 color;\n' +
				'\n' +
				'void main(void) {\n' +
				'	gl_FragColor = color;\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			color: {
				type: 'color',
				uniform: 'color',
				defaultValue: [0, 0, 0, 1]
			}
		},
		title: 'Color',
		description: 'Generate color'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.colorcomplements.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('colorcomplements', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif\n',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform vec4 guideColor;',
				'uniform float correlation;',
				'uniform float amount;',
				'uniform float concentration;',

				'float hueLerp(float h1, float h2, float v) {',
				'	float d = abs(h1 - h2);',
				'	if (d <= 0.5) {',
				'		return mix(h1, h2, v);',
				'	} else if (h1 < h2) {',
				'		return fract(mix((h1 + 1.0), h2, v));',
				'	} else {',
				'		return fract(mix(h1, (h2 + 1.0), v));',
				'	}',
				'}',

				//conversion functions borrowed from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl
				'vec3 rgbToHsv(vec3 c) {',
				'	vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);',
				'	vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);',
				'	vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);',

				'	float d = q.x - min(q.w, q.y);',
				'	float e = 1.0e-10;',
				'	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);',
				'}',

				'vec3 hsvToRgb(vec3 c) {',
				'	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);',
				'	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);',
				'	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);',
				'}',

				'vec3 hsvComplement(vec3 hsv) {',
				'	vec3 compl = hsv;',
				'	compl.x = mod(compl.x - 0.5, 1.0);',
				'	return compl;',
				'}',

				'void main(void) {',
				'	vec4 pixel = texture2D(source, vTexCoord);',
				'	vec3 hsv = rgbToHsv(pixel.rgb);',
				'	vec3 hsvPole1 = rgbToHsv(guideColor.rgb);',
				'	vec3 hsvPole2 = hsvPole1;',
				'	hsvPole2 = hsvComplement(hsvPole1);',
				'	float dist1 = abs(hsv.x - hsvPole1.x);',
				'	dist1 = dist1 > 0.5 ? 1.0 - dist1 : dist1;',
				'	float dist2 = abs(hsv.x - hsvPole2.x);',
				'	dist2 = dist2 > 0.5 ? 1.0 - dist2 : dist2;',

				'	float descent = smoothstep(0.0, correlation, hsv.y);',
				'	vec3 outputHsv = hsv;',
				'	vec3 pole = dist1 < dist2 ? hsvPole1 : hsvPole2;',
				'	float dist = min(dist1, dist2);',
				'	float c = descent * amount * (1.0 - pow((dist * 2.0), 1.0 / concentration));',
				'	outputHsv.x = hueLerp(hsv.x, pole.x, c);',
				'	outputHsv.y = mix(hsv.y, pole.y, c);',

				'	gl_FragColor = vec4(hsvToRgb(outputHsv), pixel.a);',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				min: 0,
				max: 1,
				defaultValue: 0.8
			},
			concentration: {
				type: 'number',
				uniform: 'concentration',
				min: 0.1,
				max: 4,
				defaultValue: 2
			},
			correlation: {
				type: 'number',
				uniform: 'correlation',
				min: 0,
				max: 1,
				defaultValue: 0.5
			},
			guideColor: {
				type: 'color',
				uniform: 'guideColor',
				defaultValue: [1, 0.5, 0, 1]
			}
		},
		title: 'Color Complements',
		categories: ['color'],
		description: 'http://theabyssgazes.blogspot.com/2010/03/teal-and-orange-hollywood-please-stop.html'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.colorcube.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//based on tutorial by to Gregg Tavares 
	//http://www.youtube.com/watch?v=rfQ8rKGTVlg&t=24m30s
	//todo: find a way to not invert every single texture

	Seriously.plugin('colorcube', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n' +
				'precision mediump float;\n' +
				'#endif\n' +
				'uniform sampler2D source;\n' +
				'uniform sampler2D colorCube;\n' +
				'varying vec2 vTexCoord;\n' +

				'vec3 sampleAs3DTexture(sampler2D tex, vec3 coord, float size) {\n' +
				'	float sliceSize = 1.0 / size;                         // space of 1 slice\n' +
				'	float slicePixelSize = sliceSize / size;              // space of 1 pixel\n' +
				'	float sliceInnerSize = slicePixelSize * (size - 1.0); // space of size pixels\n' +
				'	float zSlice0 = min(floor(coord.z * size), size - 1.0);\n' +
				'	float zSlice1 = min(zSlice0 + 1.0, size - 1.0);\n' +
				'	float xOffset = slicePixelSize * 0.5 + coord.x * sliceInnerSize;\n' +
				'	float s0 = xOffset + (zSlice0 * sliceSize);\n' +
				'	float s1 = xOffset + (zSlice1 * sliceSize);\n' +
				'	vec3 slice0Color = texture2D(tex, vec2(s0, 1.0 - coord.y)).rgb;\n' +
				'	vec3 slice1Color = texture2D(tex, vec2(s1, 1.0 - coord.y)).rgb;\n' +
				'	float zOffset = mod(coord.z * size, 1.0);\n' +
				'	return mix(slice0Color, slice1Color, zOffset);\n' +
				'}\n' +

				'void main(void) {\n' +
				'	vec4 originalColor = texture2D(source, vTexCoord);\n' +
				'	vec3 color = sampleAs3DTexture(colorCube, originalColor.rgb, 8.0);\n' +
				'	gl_FragColor = vec4(color, originalColor.a);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			cube: {
				type: 'image',
				uniform: 'colorCube'
			}
		},
		title: 'Color Cube',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.daltonize.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		var Seriously = root.Seriously;
		if (!Seriously) {
			Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

//todo: add Simulate mode http://mudcu.be/labs/Color/Vision/Javascript/Color.Vision.Simulate.js

/*
* Daltonization algorithm from:
* Digital Video Colourmaps for Checking the Legibility of Displays by Dichromats
* http://vision.psychol.cam.ac.uk/jdmollon/papers/colourmaps.pdf
*
* JavaScript implementation:
* http://mudcu.be/labs/Color/Vision/Javascript/Color.Vision.Daltonize.js
*
* Copyright (c) 2013 David Lewis, British Broadcasting Corporation
* (http://www.bbc.co.uk)
*
* MIT Licence:
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:

* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* 
	*/
	Seriously.plugin('daltonize', {
		shader: function (inputs, shaderSource) {
			//Vertex shader
			shaderSource.vertex = '#ifdef GL_ES\n' +
				'precision mediump float;\n' +
				'#endif \n' +
				'\n' +
				'attribute vec3 position;\n' +
				'attribute vec2 texCoord;\n' +
				'\n' +
				'uniform mat4 transform;\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'void main(void) {\n' +
				'	gl_Position = transform * vec4(position, 1.0);\n' +
				'	vTexCoord = vec2(texCoord.s, texCoord.t);\n' +
				'}\n';
			//Fragment shader
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float cbtype;\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec4 color = texture2D(source, vTexCoord);\n' +

				//No change, skip the rest
				'	if (cbtype == 0.0) {\n' +
				'		gl_FragColor = color;\n' +
				'		return;\n' +
				'	}\n' +

				// RGB to LMS matrix conversion
				'	const mat3 RGBLMS = mat3( ' +
				'		17.8824, 43.5161, 4.11935,' +
				'		3.45565, 27.1554, 3.86714,' +
				'		0.0299566, 0.184309, 1.46709' +
				'	);\n' +
				'	vec3 LMS = color.rgb * RGBLMS;\n' +

				'	vec3 lms = vec3(0.0,0.0,0.0);\n' +
				//Protanope
				'	if (cbtype < 0.33) {\n' +
				'		lms = vec3(	' +
				'			(2.02344 * LMS.g) + (-2.52581 * LMS.b),' +
				'			LMS.g,' +
				'			LMS.b' +
				'		);\n' +
				'	}\n' +
				//Deuteranope
				'	if (cbtype > 0.33 && cbtype < 0.66) {\n' +
				'		lms = vec3(	' +
				'			LMS.r,' +
				'			(0.494207 * LMS.r) + (1.24827 * LMS.b),' +
				'			LMS.b' +
				'		);\n' +
				'	}\n' +
				//Tritanope
				'	if (cbtype > 0.66) {\n' +
				'		lms = vec3(	' +
				'			LMS.r,' +
				'			LMS.g,' +
				'			(-0.395913 * LMS.r) + (0.801109 * LMS.g)' +
				'		);\n' +
				'	}\n' +

				// LMS to RGB matrix operation
				'	const mat3 LMSRGB = mat3(    ' +
				'		0.0809444479, -0.130504409, 0.116721066,' +
				'		-0.0102485335, 0.0540193266, -0.113614708,' +
				'		-0.000365296938, -0.00412161469, 0.693511405' +
				'	);\n' +

				'	vec3 RGB = lms * LMSRGB;\n' +

				// Colour shift
				// values may go over 1.0 but will get automatically clamped on output	
				'	RGB.rgb = color.rgb - RGB.rgb;\n' +
				'	RGB.g = 0.7*RGB.r + RGB.g;\n' +
				'	RGB.b = 0.7*RGB.r + RGB.b;\n' +
				'	color.rgb = color.rgb + RGB.rgb;\n' +

				//Output
				'	gl_FragColor = color;\n' +

				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			type: {
				title: 'Type',
				type: 'enum',
				uniform: 'cbtype',
				defaultValue: '0.2',
				options: [
					['0.0', 'Off'],
					['0.2', 'Protanope'],
					['0.6', 'Deuteranope'],
					['0.8', 'Tritanope']
				]
			}
		},
		title: 'Daltonize',
		description: 'Add contrast to colours to assist CVD (colour-blind) users.'
	});
}));
});
require.register("forresto-noflo-seriously/vendor/effects/seriously.directionblur.js", function(exports, require, module){
/* global define, require */
/*
Directional Motion Blur

Adapted from v002 by Anton Marini and Tom Butterworth
* Copyright vade - Anton Marini
* Creative Commons, Attribution - Non Commercial - Share Alike 3.0

http://v002.info/plugins/v002-blurs/
*/
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var passes = [0.2, 0.3, 0.5, 0.8],
		identity = new Float32Array([
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		]);

	Seriously.plugin('directionblur', function (options) {
		var fbs,
			baseShader,
			loopUniforms = {
				amount: 0,
				angle: 0,
				inputScale: 1,
				resolution: [this.width, this.height],
				transform: identity,
				projection: new Float32Array([
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
				])
			};

		return {
			initialize: function (parent) {
				var gl;

				parent();

				gl = this.gl;

				if (!gl) {
					return;
				}

				fbs = [
					new Seriously.util.FrameBuffer(gl, this.width, this.height),
					new Seriously.util.FrameBuffer(gl, this.width, this.height)
				];
			},
			shader: function (inputs, shaderSource) {
				var gl = this.gl,
					/*
					Some devices or browsers (e.g. IE11 preview) don't support enough
					varying vectors, so we need to fallback to a less efficient method
					*/
					maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS),
					defineVaryings = (maxVaryings >= 10 ? '#define USE_VARYINGS' : '');

				baseShader = new Seriously.util.ShaderProgram(gl, shaderSource.vertex, shaderSource.fragment);

				shaderSource.vertex = [
					defineVaryings,
					'precision mediump float;',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					'uniform mat4 projection;',
					'uniform mat4 transform;',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'uniform float angle;',
					'uniform float amount;',
					'uniform float inputScale;',

					'const vec2 zero = vec2(0.0, 0.0);',
					'#ifdef USE_VARYINGS',
					'vec2 one;',
					'vec2 amount1;',
					'varying vec2 vTexCoord1;',
					'varying vec2 vTexCoord2;',
					'varying vec2 vTexCoord3;',
					'varying vec2 vTexCoord4;',
					'varying vec2 vTexCoord5;',
					'varying vec2 vTexCoord6;',
					'varying vec2 vTexCoord7;',
					'varying vec2 vTexCoord8;',
					'#else',
					'varying vec2 one;',
					'varying vec2 amount1;',
					'#endif',

					'void main(void) {',
					// first convert to screen space
					'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
					'	screenPosition = transform * screenPosition;',

					// convert back to OpenGL coords
					'	gl_Position = screenPosition;',
					'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
					'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
					'	vTexCoord = texCoord;',
					'	vPosition = gl_Position;',

					'	one = vec2(1.0, 1.0) * inputScale;',
					'	if (inputScale < 1.0) {',
					'		one -= 1.0 / resolution;',
					'	}',
					'	vTexCoord = max(zero, min(one, texCoord.st * inputScale));',
					'	amount1 = vec2(cos(angle), sin(angle)) * amount * 5.0 / resolution;',

					'#ifdef USE_VARYINGS',
					'	vec2 amount2 = amount1 * 3.0;',
					'	vec2 amount3 = amount1 * 6.0;',
					'	vec2 amount4 = amount1 * 9.0;',
					'	vec2 amount5 = -amount1;',
					'	vec2 amount6 = amount5 * 3.0;',
					'	vec2 amount7 = amount5 * 6.0;',
					'	vec2 amount8 = amount5 * 9.0;',
					'	vTexCoord1 = max(zero, min(one, vTexCoord + amount1));',
					'	vTexCoord2 = max(zero, min(one, vTexCoord + amount2));',
					'	vTexCoord3 = max(zero, min(one, vTexCoord + amount3));',
					'	vTexCoord4 = max(zero, min(one, vTexCoord + amount4));',
					'	vTexCoord5 = max(zero, min(one, vTexCoord + amount5));',
					'	vTexCoord6 = max(zero, min(one, vTexCoord + amount6));',
					'	vTexCoord7 = max(zero, min(one, vTexCoord + amount7));',
					'	vTexCoord8 = max(zero, min(one, vTexCoord + amount8));',
					'#endif',
					'}'
				].join('\n');
				shaderSource.fragment = [
					defineVaryings,

					'precision mediump float;\n',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'uniform sampler2D source;',
					'uniform float angle;',
					'uniform float amount;',
					'uniform float inputScale;',

					'#ifdef USE_VARYINGS',
					'varying vec2 vTexCoord1;',
					'varying vec2 vTexCoord2;',
					'varying vec2 vTexCoord3;',
					'varying vec2 vTexCoord4;',
					'varying vec2 vTexCoord5;',
					'varying vec2 vTexCoord6;',
					'varying vec2 vTexCoord7;',
					'varying vec2 vTexCoord8;',
					'#else',
					'varying vec2 amount1;',
					'varying vec2 one;',
					'const vec2 zero = vec2(0.0, 0.0);',
					'#endif',

					'void main(void) {',
					'#ifndef USE_VARYINGS',
					'	vec2 vTexCoord1 = max(zero, min(one, vTexCoord + amount1));',
					'	vec2 vTexCoord2 = max(zero, min(one, vTexCoord + amount1 * 3.0));',
					'	vec2 vTexCoord3 = max(zero, min(one, vTexCoord + amount1 * 6.0));',
					'	vec2 vTexCoord4 = max(zero, min(one, vTexCoord + amount1 * 9.0));',
					'	vec2 vTexCoord5 = max(zero, min(one, vTexCoord - amount1));',
					'	vec2 vTexCoord6 = max(zero, min(one, vTexCoord - amount1 * 3.0));',
					'	vec2 vTexCoord7 = max(zero, min(one, vTexCoord - amount1 * 6.0));',
					'	vec2 vTexCoord8 = max(zero, min(one, vTexCoord - amount1 * 9.0));',
					'#endif',
					'	gl_FragColor = texture2D(source, vTexCoord) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord1) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord2) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord3) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord4) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord5) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord6) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord7) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord8) / 9.0;',
					'}'
				].join('\n');

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, parent) {
				var i,
					fb,
					pass,
					amount,
					width,
					height,
					opts = {
						width: 0,
						height: 0,
						blend: false
					},
					previousPass = 1;

				amount = this.inputs.amount;
				if (!amount) {
					parent(baseShader, model, uniforms, frameBuffer);
					return;
				}

				if (amount <= 0.01) {
					parent(shader, model, uniforms, frameBuffer);
					return;
				}

				loopUniforms.amount = amount;
				loopUniforms.angle = this.inputs.angle;
				loopUniforms.projection[0] = this.height / this.width;

				for (i = 0; i < passes.length; i++) {
					pass = Math.min(1, passes[i] / amount);
					width = Math.floor(pass * this.width);
					height = Math.floor(pass * this.height);

					loopUniforms.source = fb ? fb.texture : this.inputs.source.texture;

					fb = fbs[i % 2];
					loopUniforms.inputScale = previousPass;//pass;
					previousPass = pass;
					opts.width = width;
					opts.height = height;

					parent(shader, model, loopUniforms, fb.frameBuffer, null, opts);
				}

				loopUniforms.source = fb.texture;
				loopUniforms.inputScale = previousPass;
				parent(shader, model, loopUniforms, frameBuffer);
			},
			resize: function () {
				loopUniforms.resolution[0] = this.width;
				loopUniforms.resolution[1] = this.height;
				if (fbs) {
					fbs[0].resize(this.width, this.height);
					fbs[1].resize(this.width, this.height);
				}
			},
			destroy: function () {
				if (fbs) {
					fbs[0].destroy();
					fbs[1].destroy();
					fbs = null;
				}

				if (baseShader) {
					baseShader.destroy();
				}

				loopUniforms = null;
			}
		};
	},
	{
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 0.4,
				min: 0,
				max: 1
			},
			angle: {
				type: 'number',
				uniform: 'angle',
				defaultValue: 0
			}
		},
		title: 'Directional Motion Blur'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.dither.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	Shader code:
	Adapted from a blog post by Martin Upitis
	http://devlog-martinsh.blogspot.com.es/2011/03/glsl-dithering.html
	*/

	Seriously.plugin('dither', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES\n',
				'precision mediump float;\n',
				'#endif\n',

				'#define mod4(a) (a >= 4 ? a - 4 : a)',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform vec2 resolution;',

				'const mat4 dither = mat4(' +
					'1.0, 33.0, 9.0, 41.0,' +
					'49.0, 17.0, 57.0, 25.0,' +
					'13.0, 45.0, 5.0, 37.0,' +
					'61.0, 29.0, 53.0, 21.0' +
				');',

				'float find_closest(int x, int y, float c0) {',
				'	float limit = 0.0;',
				'	int x4 = mod4(x);',
				'	int y4 = mod4(y);',
				//annoying hack since GLSL ES doesn't support variable array index
				'	for (int i = 0; i < 4; i++) {',
				'		if (i == x4) {',
				'			for (int j = 0; j < 4; j++) {',
				'				if (j == y4) {',
				'					limit = dither[i][j];',
				'					break;',
				'				}',
				'			}',
				'		}',
				'	}',
				'	if (x < 4) {',
				'		if (y >= 4) {',
				'			limit += 3.0;',
				'		}',
				'	} else {',
				'		if (y >= 4) {',
				'			limit += 1.0;',
				'		} else {',
				'			limit += 2.0;',
				'		}',
				'	}',
				'	limit /= 65.0;',
				'	return c0 < limit ? 0.0 : 1.0;',
				'}',

				'void main (void)  {',
				'	vec4 pixel = texture2D(source, vTexCoord);',
				'	vec2 coord = vTexCoord * resolution;',
				'	int x = int(mod(coord.x, 8.0));',
				'	int y = int(mod(coord.y, 8.0));',
				'	pixel.r = find_closest(x, y, pixel.r);',
				'	pixel.g = find_closest(x, y, pixel.g);',
				'	pixel.b = find_closest(x, y, pixel.b);',
				'	gl_FragColor = pixel;',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			}
		},
		title: 'Dither'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.edge.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//	Adapted from http://rastergrid.com/blog/2011/01/frei-chen-edge-detector/
	var sqrt = Math.sqrt,
		i, j,
		flatMatrices = [],
		matrices,
		freiChenMatrixConstants,
		sobelMatrixConstants;

	//initialize shader matrix arrays
	function multiplyArray(factor, a) {
		var i;
		for (i = 0; i < a.length; i++) {
			a[i] *= factor;
		}
		return a;
	}

	matrices = [
		multiplyArray(1.0 / (2.0 * sqrt(2.0)), [ 1.0, sqrt(2.0), 1.0, 0.0, 0.0, 0.0, -1.0, -sqrt(2.0), -1.0 ]),
		multiplyArray(1.0 / (2.0 * sqrt(2.0)), [1.0, 0.0, -1.0, sqrt(2.0), 0.0, -sqrt(2.0), 1.0, 0.0, -1.0]),
		multiplyArray(1.0 / (2.0 * sqrt(2.0)), [0.0, -1.0, sqrt(2.0), 1.0, 0.0, -1.0, -sqrt(2.0), 1.0, 0.0]),
		multiplyArray(1.0 / (2.0 * sqrt(2.0)), [sqrt(2.0), -1.0, 0.0, -1.0, 0.0, 1.0, 0.0, 1.0, -sqrt(2.0)]),
		multiplyArray(1.0 / 2.0, [0.0, 1.0, 0.0, -1.0, 0.0, -1.0, 0.0, 1.0, 0.0]),
		multiplyArray(1.0 / 2.0, [-1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, -1.0]),
		multiplyArray(1.0 / 6.0, [1.0, -2.0, 1.0, -2.0, 4.0, -2.0, 1.0, -2.0, 1.0]),
		multiplyArray(1.0 / 6.0, [-2.0, 1.0, -2.0, 1.0, 4.0, 1.0, -2.0, 1.0, -2.0]),
		multiplyArray(1.0 / 3.0, [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])
	];

	for (i = 0; i < matrices.length; i++) {
		for (j = 0; j < matrices[i].length; j++) {
			flatMatrices.push(matrices[i][j]);
		}
	}

	freiChenMatrixConstants = new Float32Array(flatMatrices);

	sobelMatrixConstants = new Float32Array([
		1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0,
		1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0
	]);

	Seriously.plugin('edge', {
		shader: function (inputs, shaderSource) {
			var defines;

			if (inputs.mode === 'sobel') {
				defines = '#define N_MATRICES 2\n' +
				'#define SOBEL\n';
			} else {
				//frei-chen
				defines = '#define N_MATRICES 9\n';
			}

			shaderSource.fragment = defines +
				'#ifdef GL_ES\n' +
				'precision mediump float;\n' +
				'#endif\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float pixelWidth;\n' +
				'uniform float pixelHeight;\n' +
				'uniform mat3 G[9];\n' +
				'\n' +
				'void main(void) {\n' +
				'	mat3 I;\n' +
				'	float dp3, cnv[9];\n' +
				'	vec3 tc;\n' +

				// fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value
				'	float fi = 0.0, fj = 0.0;\n' +
				'	for (int i = 0; i < 3; i++) {\n' +
				'		fj = 0.0;\n' +
				'		for (int j = 0; j < 3; j++) {\n' +
				'			I[i][j] = length( ' +
							'texture2D(source, ' +
								'vTexCoord + vec2((fi - 1.0) * pixelWidth, (fj - 1.0) * pixelHeight)' +
							').rgb );\n' +
				'			fj += 1.0;\n' +
				'		};\n' +
				'		fi += 1.0;\n' +
				'	};\n' +

				// calculate the convolution values for all the masks

				'	for (int i = 0; i < N_MATRICES; i++) {\n' +
				'		dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\n' +
				'		cnv[i] = dp3 * dp3;\n' +
				'	};\n' +
				'\n' +

				//Sobel
				'#ifdef SOBEL\n' +
				'	tc = vec3(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));\n' +
				'#else\n' +

				//Frei-Chen
				// Line detector
				'	float M = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]);\n' +
				'	float S = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]) + (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + cnv[8];\n' +
				'	tc = vec3(sqrt(M/S));\n' +
				'#endif\n' +

				'	gl_FragColor = vec4(tc, 1.0);\n' +
				'}\n';

			return shaderSource;
		},
		draw: function (shader, model, uniforms, frameBuffer, parent) {

			uniforms.pixelWidth = 1 / this.width;
			uniforms.pixelHeight = 1 / this.height;

			if (this.inputs.mode === 'sobel') {
				uniforms['G[0]'] = sobelMatrixConstants;
			} else {
				uniforms['G[0]'] = freiChenMatrixConstants;
			}

			parent(shader, model, uniforms, frameBuffer);
		},
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			mode: {
				type: 'enum',
				shaderDirty: true,
				defaultValue: 'sobel',
				options: [
					['sobel', 'Sobel'],
					['frei-chen', 'Frei-Chen']
				]
			}
		},
		description: 'Edge Detect',
		title: 'Edge Detect'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.emboss.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('emboss', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float amount;\n' +
				'\n' +
				'uniform vec2 dim;\n' +
				'\n' +
				//'const vec4 weight = vec4(2.0, 2.0, 2.0, 0.5);\n' +
				'const vec3 average = vec3(1.0 / 3.0);\n' +
				'\n' +
				'void main (void)  {\n' +
				'	vec2 offset = 1.0 / dim;\n' +
				'	vec4 pixel = vec4(0.5, 0.5, 0.5, 1.0);\n' +
				'	pixel -= texture2D(source, vTexCoord - offset) * amount;\n' +
				'	pixel += texture2D(source, vTexCoord + offset) * amount;\n' +
				'	float val = dot(pixel.rgb, average);\n' +
				'	pixel.rgb = vec3(val);\n' +
				'	gl_FragColor = pixel;\n' +
				'\n' +
				'} \n';
			return shaderSource;
		},
		draw: function (shader, model, uniforms, frameBuffer, parent) {
			if (!uniforms.dim) {
				uniforms.dim = [];
			}
			uniforms.dim[0] = this.width;
			uniforms.dim[1] = this.height;
			parent(shader, model, uniforms, frameBuffer);
		},
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 1
			}
		},
		title: 'Emboss',
		categories: [],
		description: 'Emboss'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.exposure.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	Shader code:
	* Copyright vade - Anton Marini
	* Creative Commons, Attribution - Non Commercial - Share Alike 3.0

	http://v002.info/?page_id=34

	*/

	Seriously.plugin('exposure', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'\n' +
				'uniform float exposure;\n' +
				'\n' +
				'//constant variables.\n' +
				'const float sqrtoftwo = 1.41421356237;\n' +
				'\n' +
				'\n' +
				'void main (void)  {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	gl_FragColor = log2(vec4(pow(exposure + sqrtoftwo, 2.0))) * pixel;\n' +
				'\n' +
				'} \n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			exposure: {
				type: 'number',
				uniform: 'exposure',
				defaultValue: 0.6,
				min: 0,
				max: 1
			}
		},
		title: 'Exposure',
		categories: ['film'],
		description: 'Exposure control'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.fader.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('fader', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform vec4 color;\n' +
				'uniform float amount;\n' +
				'\n' +
				'void main(void) {\n' +
				'	gl_FragColor = texture2D(source, vTexCoord);\n' +
				'	gl_FragColor = mix(gl_FragColor, color, amount);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			color: {
				type: 'color',
				uniform: 'color',
				defaultValue: [0, 0, 0, 1]
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 0.5,
				min: 0,
				max: 1
			}
		},
		title: 'Fader',
		description: 'Fade image to a color'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.falsecolor.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('falsecolor', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float amount;\n' +
				'uniform vec4 dark;\n' +
				'uniform vec4 light;\n' +
				'const vec3 luma = vec3(0.2125, 0.7154, 0.0721);\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	float luminance = dot(pixel.rgb, luma);\n' +
				'	gl_FragColor = vec4( mix(dark.rgb, light.rgb, luminance), pixel.a);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			dark: {
				type: 'color',
				uniform: 'dark',
				defaultValue: [0, 0, 0.5, 1]
			},
			light: {
				type: 'color',
				uniform: 'light',
				defaultValue: [1, 0, 0, 1]
			}
		},
		title: 'False Color'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.filmgrain.js", function(exports, require, module){
/* global define, require */
/*
Film Grain

Shader:
* Copyright Martins Upitis (martinsh) devlog-martinsh.blogspot.com
* Creative Commons Attribution 3.0 Unported License
http://devlog-martinsh.blogspot.com/2013/05/image-imperfections-and-film-grain-post.html

Modified to preserve alpha

*/
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('filmgrain', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform vec2 resolution;',
				'uniform float time;',
				'uniform float amount;',
				'uniform bool colored;',

				'float timer;',

				// Perm texture texel-size
				'const float permTexUnit = 1.0/256.0;',

				// Half perm texture texel-size
				'const float permTexUnitHalf = 0.5/256.0;',

				'vec4 rnm(in vec2 tc) {',
				'	float noise = sin(dot(tc + vec2(timer,timer),vec2(12.9898,78.233))) * 43758.5453;',

				'	float noiseR = fract(noise)*2.0-1.0;',
				'	float noiseG = fract(noise*1.2154)*2.0-1.0; ',
				'	float noiseB = fract(noise*1.3453)*2.0-1.0;',
				'	float noiseA = fract(noise*1.3647)*2.0-1.0;',
				'	',
				'	return vec4(noiseR,noiseG,noiseB,noiseA);',
				'}',

				'float fade(in float t) {',
				'	return t*t*t*(t*(t*6.0-15.0)+10.0);',
				'}',

				'float pnoise3D(in vec3 p) {',
					// Integer part, scaled so +1 moves permTexUnit texel
				'	vec3 pi = permTexUnit*floor(p)+permTexUnitHalf;',

				// and offset 1/2 texel to sample texel centers
				// Fractional part for interpolation'
				'	vec3 pf = fract(p);',

				// Noise contributions from (x=0, y=0), z=0 and z=1
				'	float perm00 = rnm(pi.xy).a ;',
				'	vec3 grad000 = rnm(vec2(perm00, pi.z)).rgb * 4.0 - 1.0;',
				'	float n000 = dot(grad000, pf);',
				'	vec3 grad001 = rnm(vec2(perm00, pi.z + permTexUnit)).rgb * 4.0 - 1.0;',
				'	float n001 = dot(grad001, pf - vec3(0.0, 0.0, 1.0));',

				// Noise contributions from (x=0, y=1), z=0 and z=1
				'	float perm01 = rnm(pi.xy + vec2(0.0, permTexUnit)).a ;',
				'	vec3 grad010 = rnm(vec2(perm01, pi.z)).rgb * 4.0 - 1.0;',
				'	float n010 = dot(grad010, pf - vec3(0.0, 1.0, 0.0));',
				'	vec3 grad011 = rnm(vec2(perm01, pi.z + permTexUnit)).rgb * 4.0 - 1.0;',
				'	float n011 = dot(grad011, pf - vec3(0.0, 1.0, 1.0));',

				// Noise contributions from (x=1, y=0), z=0 and z=1
				'	float perm10 = rnm(pi.xy + vec2(permTexUnit, 0.0)).a ;',
				'	vec3 grad100 = rnm(vec2(perm10, pi.z)).rgb * 4.0 - 1.0;',
				'	float n100 = dot(grad100, pf - vec3(1.0, 0.0, 0.0));',
				'	vec3 grad101 = rnm(vec2(perm10, pi.z + permTexUnit)).rgb * 4.0 - 1.0;',
				'	float n101 = dot(grad101, pf - vec3(1.0, 0.0, 1.0));',

				// Noise contributions from (x=1, y=1), z=0 and z=1
				'	float perm11 = rnm(pi.xy + vec2(permTexUnit, permTexUnit)).a ;',
				'	vec3 grad110 = rnm(vec2(perm11, pi.z)).rgb * 4.0 - 1.0;',
				'	float n110 = dot(grad110, pf - vec3(1.0, 1.0, 0.0));',
				'	vec3 grad111 = rnm(vec2(perm11, pi.z + permTexUnit)).rgb * 4.0 - 1.0;',
				'	float n111 = dot(grad111, pf - vec3(1.0, 1.0, 1.0));',

				// Blend contributions along x
				'	vec4 n_x = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(pf.x));',

				// Blend contributions along y
				'	vec2 n_xy = mix(n_x.xy, n_x.zw, fade(pf.y));',

				//Blend contributions along z
				'	float n_xyz = mix(n_xy.x, n_xy.y, fade(pf.z));',

				'	return n_xyz;',
				'}',

				'void main(void) {',
				'	timer = mod(time, 10000.0) / 10000.0;',
				'	vec4 pixel = texture2D(source, vTexCoord);',
				'	vec3 noise = vec3(pnoise3D(vec3(vTexCoord * resolution, timer + 0.0)));',
				'	if (colored) {',
				'		noise.g = pnoise3D(vec3(vTexCoord * resolution, timer + 1.0));',
				'		noise.b = pnoise3D(vec3(vTexCoord * resolution, timer + 2.0));',
				'	}',
				'	gl_FragColor = vec4(pixel.rgb + noise * amount, pixel.a);',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			time: {
				type: 'number',
				uniform: 'time'
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				min: 0,
				max: 1,
				defaultValue: 0.03
			},
			colored: {
				type: 'boolean',
				uniform: 'colored',
				defaultValue: false
			}
		},
		title: 'Film Grain',
		description: 'Don\'t over-do it.'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.hex.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*

	Shader adapted from glfx.js by Evan Wallace
	License: https://github.com/evanw/glfx.js/blob/master/LICENSE
	*/

	Seriously.plugin('hex', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform vec2 resolution;\n' +
				'uniform vec2 center;\n' +
				'uniform float size;\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec2 aspect = normalize(resolution);\n' +
				'	vec2 tex = (vTexCoord * aspect - center) / size;\n' +
				'	tex.y /= 0.866025404;\n' +
				'	tex.x -= tex.y * 0.5;\n' +
				'	vec2 a;\n' +
				'	if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n' +
				'		a = vec2(floor(tex.x), floor(tex.y));\n' +
				'	} else {\n' +
				'		a = vec2(ceil(tex.x), ceil(tex.y));\n' +
				'	}\n' +
				'	vec2 b = vec2(ceil(tex.x), floor(tex.y));\n' +
				'	vec2 c = vec2(floor(tex.x), ceil(tex.y));\n' +
				'	vec3 tex3 = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n' +
				'	vec3 a3 = vec3(a.x, a.y, 1.0 - a.x - a.y);\n' +
				'	vec3 b3 = vec3(b.x, b.y, 1.0 - b.x - b.y);\n' +
				'	vec3 c3 = vec3(c.x, c.y, 1.0 - c.x - c.y);\n' +
				'	float alen =length(tex3 - a3);\n' +
				'	float blen =length(tex3 - b3);\n' +
				'	float clen =length(tex3 - c3);\n' +
				'	vec2 choice;\n' +
				'	if (alen < blen) {\n' +
				'		if (alen < clen) {\n' +
				'			choice = a;\n' +
				'		} else {\n' +
				'			choice = c;\n' +
				'		}\n' +
				'	} else {\n' +
				'		if (blen < clen) {\n' +
				'			choice = b;\n' +
				'		} else {\n' +
				'			choice = c;\n' +
				'		}\n' +
				'	}\n' +
				'	choice.x += choice.y * 0.5;\n' +
				'	choice.y *= 0.866025404;\n' +
				'	choice *= size / aspect;\n' +
				'	gl_FragColor = texture2D(source, choice + center / aspect);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			size: {
				type: 'number',
				uniform: 'size',
				min: 0,
				max: 0.4,
				defaultValue: 0.01
			},
			center: {
				type: 'vector',
				uniform: 'center',
				dimensions: 2,
				defaultValue: [0, 0]
			}
		},
		title: 'Hex',
		description: 'Hexagonal Pixelate'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.highlights-shadows.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('highlights-shadows', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float shadows;\n' +
				'uniform float highlights;\n' +
				'const vec3 luma = vec3(0.2125, 0.7154, 0.0721);\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	float luminance = dot(pixel.rgb, luma);\n' +
				'	float shadow = clamp((pow(luminance, 1.0 / (shadows + 1.0)) + (-0.76) * pow(luminance, 2.0 / (shadows + 1.0))) - luminance, 0.0, 1.0);\n' +
				'	float highlight = clamp((1.0 - (pow(1.0 - luminance, 1.0 / (2.0 - highlights)) + (-0.8) * pow(1.0 - luminance, 2.0 / (2.0 - highlights)))) - luminance, -1.0, 0.0);\n' +
				'	vec3 rgb = (luminance + shadow + highlight) * (pixel.rgb / vec3(luminance));\n' +
				//'	vec3 rgb = vec3(0.0, 0.0, 0.0) + ((luminance + shadow + highlight) - 0.0) * ((pixel.rgb - vec3(0.0, 0.0, 0.0))/(luminance - 0.0));\n' +
				'	gl_FragColor = vec4(rgb, pixel.a);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			highlights: {
				type: 'number',
				uniform: 'highlights',
				min: 0,
				max: 1,
				defaultValue: 1
			},
			shadows: {
				type: 'number',
				uniform: 'shadows',
				min: 0,
				max: 1,
				defaultValue: 0
			}
		},
		title: 'Highlights/Shadows',
		description: 'Darken highlights, lighten shadows'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.hue-saturation.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//inspired by Evan Wallace (https://github.com/evanw/glfx.js)

	Seriously.plugin('hue-saturation', {
		shader: function (inputs, shaderSource) {
			shaderSource.vertex = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif ',

				'attribute vec4 position;',
				'attribute vec2 texCoord;',

				'uniform vec2 resolution;',
				'uniform mat4 projection;',
				'uniform mat4 transform;',

				'uniform float hue;',
				'uniform float saturation;',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'varying vec3 weights;',

				'void main(void) {',
				'	float angle = hue * 3.14159265358979323846264;',
				'	float s = sin(angle);',
				'	float c = cos(angle);',
				'	weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;',

				// first convert to screen space
				'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
				'	screenPosition = transform * screenPosition;',

				// convert back to OpenGL coords
				'	gl_Position = screenPosition;',
				'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
				'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
				'	vTexCoord = texCoord;',
				'	vPosition = gl_Position;',
				'}'
			].join('\n');
			shaderSource.fragment = [
				'#ifdef GL_ES\n',
				'precision mediump float;\n',
				'#endif\n',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'varying vec3 weights;',

				'uniform sampler2D source;',
				'uniform float hue;',
				'uniform float saturation;',

				'void main(void) {',
				'	vec4 color = texture2D(source, vTexCoord);',

				//adjust hue
				'	float len = length(color.rgb);',
				'	color.rgb = vec3(' +
						'dot(color.rgb, weights.xyz), ' +
						'dot(color.rgb, weights.zxy), ' +
						'dot(color.rgb, weights.yzx) ' +
				');',

				//adjust saturation
				'	vec3 adjustment = (color.r + color.g + color.b) / 3.0 - color.rgb;',
				'	if (saturation > 0.0) {',
				'		adjustment *= (1.0 - 1.0 / (1.0 - saturation));',
				'	} else {',
				'		adjustment *= (-saturation);',
				'	}',
				'	color.rgb += adjustment;',

				'	gl_FragColor = color;',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			hue: {
				type: 'number',
				uniform: 'hue',
				defaultValue: 0.4,
				min: -1,
				max: 1
			},
			saturation: {
				type: 'number',
				uniform: 'saturation',
				defaultValue: 0,
				min: -1,
				max: 1
			}
		},
		title: 'Hue/Saturation',
		description: 'Rotate hue and multiply saturation.'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.invert.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('invert', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'\n' +
				'void main(void) {\n' +
				'	gl_FragColor = texture2D(source, vTexCoord);\n' +
				'	gl_FragColor = vec4(1.0 - gl_FragColor.rgb, gl_FragColor.a);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			}
		},
		title: 'Invert',
		description: 'Invert image color'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.kaleidoscope.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('kaleidoscope', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform float segments;',
				'uniform float offset;',

				'const float PI = ' + Math.PI + ';',
				'const float TAU = 2.0 * PI;',

				'void main(void) {',
				'	if (segments == 0.0) {',
				'		gl_FragColor = texture2D(source, vTexCoord);',
				'	} else {',
				'		vec2 centered = vTexCoord - 0.5;',
				//to polar
				'		float r = length(centered);',
				'		float theta = atan(centered.y, centered.x);',
				'		theta = mod(theta, TAU / segments);',
				'		theta = abs(theta - PI / segments);',
				//back to cartesian
				'		vec2 newCoords = r * vec2(cos(theta), sin(theta)) + 0.5;',
				'		gl_FragColor = texture2D(source, mod(newCoords - offset, 1.0));',
				'	}',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			segments: {
				type: 'number',
				uniform: 'segments',
				defaultValue: 6
			},
			offset: {
				type: 'number',
				uniform: 'offset',
				defaultValue: 0
			}
		},
		title: 'Kaleidoscope'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.layers.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var identity = new Float32Array([
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		]),
		intRegex = /\d+/;

	Seriously.plugin('layers', function (options) {
		var count,
			me = this,
			topOpts = {
				clear: false
			},
			i,
			inputs;

		function update() {
			me.resize();
		}

		if (typeof options === 'number' && options >= 2) {
			count = options;
		} else {
			count = options && options.count || 4;
			count = Math.max(2, count);
		}

		inputs = {
			sizeMode: {
				type: 'enum',
				defaultValue: '0',
				options: [
					'union',
					'intersection'
				],
				update: function () {
					this.resize();
				}
			}
		};

		for (i = 0; i < count; i++) {
			inputs.sizeMode.options.push(i.toString());
			inputs.sizeMode.options.push('source' + i);

			//source
			inputs['source' + i] = {
				type: 'image',
				update: update
			};

			//opacity
			inputs['opacity' + i] = {
				type: 'number',
				defaultValue: 1,
				min: 0,
				max: 1,
			};
		}

		this.uniforms.layerResolution = [1, 1];

		// custom resize method
		this.resize = function () {
			var width,
				height,
				mode = this.inputs.sizeMode,
				i,
				n,
				source,
				a;

			if (mode === 'union') {
				width = 0;
				height = 0;
				for (i = 0; i < count; i++) {
					source = this.inputs['source' + i];
					if (source) {
						width = Math.max(width, source.width);
						height = Math.max(height, source.height);
					}
				}
			} else if (mode === 'intersection') {
				width = Infinity;
				height = Infinity;
				for (i = 0; i < count; i++) {
					source = this.inputs['source' + i];
					if (source) {
						width = Math.min(width, source.width);
						height = Math.min(height, source.height);
					}
				}
			} else {
				width = 1;
				height = 1;
				n = count - 1;
				a = intRegex.exec(this.inputs.sizeMode);
				if (a) {
					n = Math.min(parseInt(a[0], 10), n);
				}

				for (i = 0; i <= n; i++) {
					source = this.inputs['source' + i];
					if (source) {
						width = source.width;
						height = source.height;
						break;
					}
				}
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.uniforms.resolution[0] = width;
				this.uniforms.resolution[1] = height;

				if (this.frameBuffer) {
					this.frameBuffer.resize(width, height);
				}

				this.setDirty();
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		return {
			shader: function (inputs, shaderSource) {
				shaderSource.vertex = [
					'precision mediump float;',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					'uniform vec2 layerResolution;',
					'uniform mat4 transform;',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'void main(void) {',
					// first convert to screen space
					'	vec4 screenPosition = vec4(position.xy * layerResolution / 2.0, position.z, position.w);',
					'	screenPosition = transform * screenPosition;',

					// convert back to OpenGL coords
					'	gl_Position.xy = screenPosition.xy * 2.0 / layerResolution;',
					'	gl_Position.z = screenPosition.z * 2.0 / (layerResolution.x / layerResolution.y);',
					'	gl_Position.xy *= layerResolution / resolution;',
					'	gl_Position.w = screenPosition.w;',
					'	vTexCoord = texCoord;',
					'	vPosition = gl_Position;',
					'}\n'
				].join('\n');

				shaderSource.fragment = [
					'precision mediump float;',
					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',
					'uniform sampler2D source;',
					'uniform float opacity;',
					'void main(void) {',
					'	if (any(lessThan(vTexCoord, vec2(0.0))) || any(greaterThanEqual(vTexCoord, vec2(1.0)))) {',
					'		gl_FragColor = vec4(0.0);',
					'	} else {',
					'		gl_FragColor = texture2D(source, vTexCoord);',
					'		gl_FragColor.a *= opacity;',
					'	}',
					'}'
				].join('\n');

				return shaderSource;
			},
			requires: function (sourceName, inputs) {
				var a, index = count;

				a = intRegex.exec(this.inputs.sizeMode);
				if (a) {
					index = parseInt(a[0], 10);
				}
				if (index >= count) {
					return false;
				}

				return !!(inputs[sourceName] && inputs['opacity' + index]);
			},
			draw: function (shader, model, uniforms, frameBuffer, draw) {
				var i,
					opacity,
					source,
					gl = this.gl;

				//clear in case we have no layers to draw
				gl.viewport(0, 0, this.width, this.height);
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				for (i = 0; i < count; i++) {
					source = this.inputs['source' + i];
					opacity = this.inputs['opacity' + i];

					//don't draw if layer is disconnected or opacity is 0
					if (source && opacity) {
						uniforms.opacity = opacity;
						uniforms.layerResolution[0] = source.width;
						uniforms.layerResolution[1] = source.height;
						uniforms.source = source;
						uniforms.transform = source.cumulativeMatrix || identity;

						draw(shader, model, uniforms, frameBuffer, null, topOpts);
					}
				}
			},
			inputs: inputs
		};
	},
	{
		inPlace: true,
		description: 'Multiple layers',
		title: 'Layers'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.linear-transfer.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('linear-transfer', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES\n',
				'precision mediump float;\n',
				'#endif\n',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform vec4 slope;',
				'uniform vec4 intercept;',

				'const vec3 half3 = vec3(0.5);',

				'void main(void) {',
				'	vec4 pixel = texture2D(source, vTexCoord);',
				'	gl_FragColor = pixel * slope + intercept;',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			slope: {
				type: 'vector',
				dimensions: 4,
				uniform: 'slope',
				defaultValue: [1, 1, 1, 1]
			},
			intercept: {
				type: 'vector',
				uniform: 'intercept',
				dimensions: 4,
				defaultValue: [0, 0, 0, 0]
			}
		},
		title: 'Linear Transfer',
		description: 'For each color channel: [slope] * [value] + [intercept]'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.lumakey.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('lumakey', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'\n' +
				'uniform float threshold;\n' +
				'uniform float clipBlack;\n' +
				'uniform float clipWhite;\n' +
				'uniform bool invert;\n' +
				'\n' +
				'const vec3 lumcoeff = vec3(0.2125,0.7154,0.0721);\n' +
				'\n' +
				'void main (void)  {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	float luma = dot(pixel.rgb,lumcoeff);\n' +
				'	float alpha = 1.0 - smoothstep(clipBlack, clipWhite, luma);\n' +
				'	if (invert) alpha = 1.0 - alpha;\n' +
				'	gl_FragColor = vec4(pixel.rgb, min(pixel.a, alpha) );\n' +
				'\n' +
				'} \n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			clipBlack: {
				type: 'number',
				uniform: 'clipBlack',
				defaultValue: 0.9,
				min: 0,
				max: 1
			},
			clipWhite: {
				type: 'number',
				uniform: 'clipWhite',
				defaultValue: 1,
				min: 0,
				max: 1
			},
			invert: {
				type: 'boolean',
				uniform: 'invert',
				defaultValue: false
			}
		},
		title: 'Luma Key',
		categories: ['key'],
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.nightvision.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//based on tutorial: http://www.geeks3d.com/20091009/shader-library-night-vision-post-processing-filter-glsl/
	//todo: make noise better?

	Seriously.plugin('nightvision', {
		shader: function (inputs, shaderSource, utilities) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'uniform float timer;\n' +
					'uniform float luminanceThreshold;\n' +
					'uniform float amplification;\n' +
					'uniform vec3 nightVisionColor;\n' +
					'\n' +
					utilities.shader.makeNoise +
					'\n' +
					'void main(void) {\n' +
					'	vec3 noise = vec3(' +
							'makeNoise(vTexCoord.x, vTexCoord.y, timer), ' +
							'makeNoise(vTexCoord.x, vTexCoord.y, timer * 200.0 + 1.0), ' +
							'makeNoise(vTexCoord.x, vTexCoord.y, timer * 100.0 + 3.0)' +
						');\n' +
					'	vec4 pixel = texture2D(source, vTexCoord + noise.xy * 0.0025);\n' +
					'	float luminance = dot(vec3(0.299, 0.587, 0.114), pixel.rgb);\n' +
					'	pixel.rgb *= step(luminanceThreshold, luminance) * amplification;\n' +
					'	gl_FragColor = vec4( (pixel.rgb + noise * 0.1) * nightVisionColor, pixel.a);\n' +
					'}\n';
			return shaderSource;
		},
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			timer: {
				type: 'number',
				uniform: 'timer',
				defaultValue: 0
			},
			luminanceThreshold: {
				type: 'number',
				uniform: 'luminanceThreshold',
				defaultValue: 0.1,
				min: 0,
				max: 1
			},
			amplification: {
				type: 'number',
				uniform: 'amplification',
				defaultValue: 1.4,
				min: 0
			},
			color: {
				type: 'color',
				uniform: 'nightVisionColor',
				defaultValue: [0.1, 0.95, 0.2]
			}
		},
		title: 'Night Vision',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.noise.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('noise', {
		shader: function (inputs, shaderSource, utilities) {
			var frag = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'#define Blend(base, blend, funcf)		vec3(funcf(base.r, blend.r), funcf(base.g, blend.g), funcf(base.b, blend.b))\n' +
				'#define BlendOverlayf(base, blend) (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\n' +
				'#define BlendOverlay(base, blend)		Blend(base, blend, BlendOverlayf)\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'\n' +
				'uniform vec2 resolution;\n' +
				'uniform float amount;\n' +
				'uniform float timer;\n' +

				utilities.shader.noiseHelpers +
				utilities.shader.snoise3d +
				utilities.shader.random +

				'void main(void) {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	float r = random(vec2(timer * vTexCoord.xy));\n' +
				'	float noise = snoise(vec3(vTexCoord * (1024.4 + r * 512.0), timer)) * 0.5;';

			if (inputs.overlay) {
				frag += '	vec3 overlay = BlendOverlay(pixel.rgb, vec3(noise));\n' +
						'	pixel.rgb = mix(pixel.rgb, overlay, amount);\n';
			} else {
				frag += '	pixel.rgb += noise * amount;\n';
			}
			frag += '	gl_FragColor = pixel;\n}';

			shaderSource.fragment = frag;
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			overlay: {
				type: 'boolean',
				shaderDirty: true,
				defaultValue: true
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				min: 0,
				max: 1,
				defaultValue: 1
			},
			timer: {
				type: 'number',
				uniform: 'timer',
				defaultValue: 0,
				step: 1
			}
		},
		title: 'Noise',
		description: 'Add noise'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.repeat.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var identity = new Float32Array([
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		]),
		mat4 = Seriously.util.mat4;

	Seriously.plugin('repeat', function () {
		var drawOpts = {
				clear: false
			},
			transform = new Float32Array(16),
			me = this;

		function resize() {
			me.resize();
		}

		// custom resize method
		this.resize = function () {
			var width = this.width,
				height = this.height,
				source = me.inputs.source,
				i;

			if (this.source) {
				width = this.source.width;
				height = this.source.height;
			} else if (this.sources && this.sources.source) {
				width = this.sources.source.width;
				height = this.sources.source.height;
			} else {
				width = 1;
				height = 1;
			}

			if (me.inputs.width) {
				width = me.inputs.width;
				if (me.inputs.height) {
					height = me.inputs.height;
				} else if (source) {
					//match source aspect ratio
					height = width * source.height / source.width;
				}
			} else if (me.inputs.height) {
				height = me.inputs.height;
				if (source) {
					//match source aspect ratio
					width = height * source.width / source.height;
				}
			}

			if (source) {
				this.uniforms.resolution[0] = source.width;
				this.uniforms.resolution[1] = source.height;
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.uniforms.targetRes[0] = this.width;
				this.uniforms.targetRes[1] = this.height;

				if (this.frameBuffer) {
					this.frameBuffer.resize(this.width, this.height);
				}

				this.setDirty();
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		this.uniforms.targetRes = [1, 1];

		return {
			initialize: function (initialize) {
				initialize();
				this.uniforms.transform = transform;
			},
			shader: function (inputs, shaderSource) {
				shaderSource.vertex = [
					'precision mediump float;',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					'uniform vec2 targetRes;',
					'uniform mat4 transform;',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'void main(void) {',
					// first convert to screen space
					'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
					'	screenPosition = transform * screenPosition;',

					// convert back to OpenGL coords
					'	gl_Position = screenPosition;',
					'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
					'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
					'	gl_Position.xy *= resolution / targetRes;',
					'	vTexCoord = texCoord;',
					'	vPosition = gl_Position;',
					'}\n'
				].join('\n');
				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, draw) {
				var i,
					source = this.inputs.source,
					transform = this.inputs.transform,
					transformMatrix = transform && transform.cumulativeMatrix,
					repeat = this.inputs.repeat,
					gl = this.gl;

				if (transformMatrix && transform.transformed) {
					mat4.copy(uniforms.transform, source && source.cumulativeMatrix || identity);
				} else {
					repeat = Math.min(repeat, 1);
				}

				// first, clear
				gl.viewport(0, 0, this.width, this.height);
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				for (i = repeat - 1; i >= 0; i--) {
					draw(shader, model, uniforms, frameBuffer, null, drawOpts);
					if (i) {
						mat4.multiply(uniforms.transform, transformMatrix, uniforms.transform);
					}
				}
			},
			inputs: {
				source: {
					type: 'image',
					uniform: 'source',
					update: function () {
						resize();
						this.uniforms.transform = transform;
					}
				},
				transform: {
					type: 'image'
				},
				repeat: {
					type: 'number',
					step: 1,
					min: 0,
					defaultValue: 8
				},
				width: {
					type: 'number',
					min: 0,
					step: 1,
					update: resize,
					defaultValue: 0
				},
				height: {
					type: 'number',
					min: 0,
					step: 1,
					update: resize,
					defaultValue: 0
				}
			}
		};
	},
	{
		inPlace: true,
		description: 'Draw image multiple times, transforming each time',
		title: 'Repeat'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.ripple.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//http://msdn.microsoft.com/en-us/library/bb313868(v=xnagamestudio.10).aspx
	Seriously.plugin('ripple', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float wave;\n' +
				'uniform float distortion;\n' +
				'uniform vec2 center;\n' +
				'\n' +
				'void main(void) {\n' +
				//todo: can at least move scalar into vertex shader
				'	float scalar = abs(1.0 - abs(distance(vTexCoord, center)));\n' +
				'	float sinOffset = sin(wave / scalar);\n' +
				'	sinOffset = clamp(sinOffset, 0.0, 1.0);\n' +
				'	float sinSign = cos(wave / scalar);\n' +
				'	sinOffset = sinOffset * distortion / 32.0;\n' +
				'	gl_FragColor = texture2D(source, vTexCoord + sinOffset * sinSign);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			wave: {
				type: 'number',
				uniform: 'wave',
				defaultValue: Math.PI / 0.75
			},
			distortion: {
				type: 'number',
				uniform: 'distortion',
				defaultValue: 1
			},
			center: {
				type: 'vector',
				uniform: 'center',
				dimensions: 2,
				defaultValue: [0.5, 0.5]
			}
		},
		title: 'Ripple Distortion',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.scanlines.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('scanlines', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'uniform float lines;\n' +
					'uniform float width;\n' +
					'uniform float intensity;\n' +
					//todo: add vertical offset for animating
					'\n' +
					'void main(void) {\n' +
					'	vec4 pixel = texture2D(source, vTexCoord);\n' +
					'	float darken = 2.0 * abs( fract(vPosition.y * lines / 2.0) - 0.5);\n' +
					'	darken = clamp(darken - width + 0.5, 0.0, 1.0);\n' +
					'	darken = 1.0 - ((1.0 - darken) * intensity);\n' +
					'	gl_FragColor = vec4(pixel.rgb * darken, 1.0);\n' +
					'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			lines: {
				type: 'number',
				uniform: 'lines',
				defaultValue: 60
			},
			size: {
				type: 'number',
				uniform: 'size',
				defaultValue: 0.2,
				min: 0,
				max: 1
			},
			intensity: {
				type: 'number',
				uniform: 'intensity',
				defaultValue: 0.1,
				min: 0,
				max: 1
			}
		},
		title: 'Scan Lines',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.sepia.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	// sepia coefficients borrowed from:
	// http://www.techrepublic.com/blog/howdoi/how-do-i-convert-images-to-grayscale-and-sepia-tone-using-c/120

	Seriously.plugin('sepia', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform vec4 light;\n' +
				'uniform vec4 dark;\n' +
				'uniform float desat;\n' +
				'uniform float toned;\n' +
				'\n' +
				'const mat4 coeff = mat4(' +
					'0.393, 0.349, 0.272, 1.0,' +
					'0.796, 0.686, 0.534, 1.0, ' +
					'0.189, 0.168, 0.131, 1.0, ' +
					'0.0, 0.0, 0.0, 1.0 ' +
				');\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec4 sourcePixel = texture2D(source, vTexCoord);\n' +
				'	gl_FragColor = coeff * sourcePixel;\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			}
		},
		title: 'Sepia',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.simplex.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('simplex', function () {
		var me = this;

		function resize() {
			me.resize();
		}

		return {
			shader: function (inputs, shaderSource, utilities) {
				var frequency = 1,
					amplitude = 1,
					i,
					adjust = 0;

				function fmtFloat(n) {
					if (n - Math.floor(n) === 0) {
						return n + '.0';
					}
					return n;
				}

				shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'\n' +
					'uniform float amount;\n' +
					'uniform vec2 noiseScale;\n' +
					'uniform vec2 noiseOffset;\n' +
					'uniform float time;\n' +

					utilities.shader.noiseHelpers +
					utilities.shader.snoise3d +
					//utilities.shader.random +

					'void main(void) {\n' +
					'	float total = 0.0;\n' +
					'	vec3 pos = vec3(vTexCoord.xy * noiseScale + noiseOffset, time);\n';

				for (i = 0; i < inputs.octaves; i++) {
					frequency = Math.pow(2, i);
					amplitude = Math.pow(inputs.persistence, i);
					adjust += amplitude;
					shaderSource.fragment += '\ttotal += snoise(pos * ' + fmtFloat(frequency) + ') * ' + fmtFloat(amplitude) + ';\n';
				}
				shaderSource.fragment += '\ttotal *= amount / ' + fmtFloat(adjust) + ';\n' +
				'	total = (total + 1.0)/ 2.0;\n' +
				'	gl_FragColor = vec4(total, total, total, 1.0);\n' +
				'}';

				return shaderSource;
			},
			inputs: {
				source: {
					type: 'image',
					uniform: 'source'
				},
				noiseScale: {
					type: 'vector',
					dimensions: 2,
					uniform: 'noiseScale',
					defaultValue: [1, 1]
				},
				noiseOffset: {
					type: 'vector',
					dimensions: 2,
					uniform: 'noiseOffset',
					defaultValue: [0, 0]
				},
				octaves: {
					type: 'number',
					shaderDirty: true,
					min: 1,
					max: 8,
					step: 1,
					defaultValue: 1
				},
				persistence: {
					type: 'number',
					defaultValue: 0.5,
					min: 0,
					max: 0.5
				},
				amount: {
					type: 'number',
					uniform: 'amount',
					min: 0,
					defaultValue: 1
				},
				time: {
					type: 'number',
					uniform: 'time',
					defaultValue: 0
				},
				width: {
					type: 'number',
					min: 0,
					step: 1,
					update: resize,
					defaultValue: 0
				},
				height: {
					type: 'number',
					min: 0,
					step: 1,
					update: resize,
					defaultValue: 0
				}
			}
		};
	}, {
		title: 'Simplex Noise',
		description: 'Generate Simplex Noise'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.sketch.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/* inspired by http://lab.adjazent.com/2009/01/09/more-pixel-bender/ */

	Seriously.plugin('sketch', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				//todo: make adjust adjustable
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform vec2 resolution;\n' +
				'\n' +
				'float res = resolution.x;\n' +
				'float n0 = 97.0 / res;\n' +
				'float n1 = 15.0 / res;\n' +
				'float n2 = 97.0 / res;\n' +
				'float n3 = 9.7 / res;\n' +
				'float total = n2 + ( 4.0 * n0 ) + ( 4.0 * n1 );\n' +
				'const vec3 div3 = vec3(1.0 / 3.0);\n' +
				'\n' +
				'void main(void) {\n' +
				'	float offset, temp1, temp2;\n' +
				'	vec4 m, p0, p1, p2, p3, p4, p5, p6, p7, p8;\n' +
				'	offset = n3;\n' +

				'	p0=texture2D(source,vTexCoord);\n' +
				'	p1=texture2D(source,vTexCoord+vec2(-offset,-offset));\n' +
				'	p2=texture2D(source,vTexCoord+vec2( offset,-offset));\n' +
				'	p3=texture2D(source,vTexCoord+vec2( offset, offset));\n' +
				'	p4=texture2D(source,vTexCoord+vec2(-offset, offset));\n' +

				'	offset=n3*2.0;\n' +

				'	p5=texture2D(source,vTexCoord+vec2(-offset,-offset));\n' +
				'	p6=texture2D(source,vTexCoord+vec2( offset,-offset));\n' +
				'	p7=texture2D(source,vTexCoord+vec2( offset, offset));\n' +
				'	p8=texture2D(source,vTexCoord+vec2(-offset, offset));\n' +
				'	m = (p0 * n2 + (p1 + p2 + p3 + p4) * n0 + (p5 + p6 + p7 + p8) * n1) / total;\n' +

					//convert to b/w
				'	temp1 = dot(p0.rgb, div3);\n' +
				'	temp2 = dot(m.rgb, div3);\n' +

					//color dodge blend mode
				'	if (temp2 <= 0.0005) {\n' +
				'		gl_FragColor = vec4( 1.0, 1.0, 1.0, p0.a);\n' +
				'	} else {\n' +
				'		gl_FragColor = vec4( vec3(min(temp1 / temp2, 1.0)), p0.a);\n' +
				'	}\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			}
		},
		title: 'Sketch',
		description: 'Pencil/charcoal sketch'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.split.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('split', function () {
		var baseShader,
			resolutionA = [1, 1],
			resolutionB = [1, 1];

		// custom resize method
		this.resize = function () {
			var width,
				height,
				mode = this.inputs.sizeMode,
				node,
				fn,
				i,
				sourceA = this.inputs.sourceA,
				sourceB = this.inputs.sourceB;

			if (mode === 'a' || mode === 'b') {
				node = mode === 'a' ? sourceA : sourceB;
				if (node) {
					width = node.width;
					height = node.height;
				} else {
					width = 1;
					height = 1;
				}
			} else {
				if (sourceA) {
					if (sourceB) {
						fn = (mode === 'union' ? Math.max : Math.min);
						width = fn(sourceA.width, sourceB.width);
						height = fn(sourceA.height, sourceB.height);
					} else {
						width = sourceA.width;
						height = sourceA.height;
					}
				} else if (sourceB) {
					width = sourceB.width;
					height = sourceB.height;
				} else {
					width = 1;
					height = 1;
				}
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.uniforms.resolution[0] = width;
				this.uniforms.resolution[1] = height;

				if (this.frameBuffer) {
					this.frameBuffer.resize(width, height);
				}

				this.setDirty();
			}

			if (sourceA) {
				resolutionA[0] = sourceA.width;
				resolutionA[1] = sourceA.height;
			}
			if (sourceB) {
				resolutionB[0] = sourceB.width;
				resolutionB[1] = sourceB.height;
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		return {
			initialize: function (initialize) {
				initialize();
				this.uniforms.resolutionA = resolutionA;
				this.uniforms.resolutionB = resolutionB;
			},
			shader: function (inputs, shaderSource) {
				baseShader = new Seriously.util.ShaderProgram(this.gl, shaderSource.vertex, shaderSource.fragment);

				shaderSource.vertex = [
					'#ifdef GL_ES',
					'precision mediump float;',
					'#endif ',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					'uniform vec2 resolutionA;',
					'uniform vec2 resolutionB;',
					'uniform mat4 projection;',
					//'uniform mat4 transform;',

					'varying vec2 vTexCoord;',
					'varying vec2 vTexCoordA;',
					'varying vec2 vTexCoordB;',
					'varying vec4 vPosition;',

					'uniform float angle;',
					'varying float c;',
					'varying float s;',
					'varying float t;',

					'void main(void) {',
					'   c = cos(angle);',
					'   s = sin(angle);',
					'	t = abs(c + s);',

					// first convert to screen space
					'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
					//'	screenPosition = transform * screenPosition;',

					// convert back to OpenGL coords
					'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
					'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
					'	gl_Position.w = screenPosition.w;',

					'	vec2 adjustedTexCoord = (texCoord - 0.5) * resolution;',
					'	vTexCoordA = adjustedTexCoord / resolutionA + 0.5;',
					'	vTexCoordB = adjustedTexCoord / resolutionB + 0.5;',
					'	vTexCoord = texCoord;',

					'	vPosition = gl_Position;',
					'}'
				].join('\n');
				shaderSource.fragment = [
					'#ifdef GL_ES\n',
					'precision mediump float;\n',
					'#endif\n',

					'varying vec2 vTexCoord;',
					'varying vec2 vTexCoordA;',
					'varying vec2 vTexCoordB;',
					'varying vec4 vPosition;',

					'varying float c;',
					'varying float s;',
					'varying float t;',

					'uniform sampler2D sourceA;',
					'uniform sampler2D sourceB;',
					'uniform float split;',
					'uniform float angle;',
					'uniform float fuzzy;',

					'vec4 textureLookup(sampler2D tex, vec2 texCoord) {',
					'	if (any(lessThan(texCoord, vec2(0.0))) || any(greaterThan(texCoord, vec2(1.0)))) {',
					'		return vec4(0.0);',
					'	} else {',
					'		return texture2D(tex, texCoord);',
					'	}',
					'}',

					'void main(void) {',
					'	float mn = (split - fuzzy * (1.0 - split));',
					'	float mx = (split + fuzzy * split);;',
					'	vec2 coords = vTexCoord - vec2(0.5);',
					'	coords = vec2(coords.x * c - coords.y * s, coords.x * s + coords.y * c);',
					'	float scale = max(abs(c - s), abs(s + c));',
					'	coords /= scale;',
					'	coords += vec2(0.5);',
					'	float x = coords.x;;',
					'	if (x <= mn) {',
					'		gl_FragColor = textureLookup(sourceB, vTexCoordB);',
					'		return;',
					'	}',
					'	if (x >= mx) {',
					'		gl_FragColor = textureLookup(sourceA, vTexCoordA);',
					'		return;',
					'	}',
					'	vec4 pixel1 = textureLookup(sourceA, vTexCoordA);',
					'	vec4 pixel2 = textureLookup(sourceB, vTexCoordB);',
					'	gl_FragColor = mix(pixel2, pixel1, smoothstep(mn, mx, x));',
					'}'
				].join('\n');

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, parent) {
				if (uniforms.split >= 1) {
					uniforms.source = uniforms.sourceB;
					parent(baseShader, model, uniforms, frameBuffer);
					return;
				}

				if (uniforms.split <= 0) {
					uniforms.source = uniforms.sourceA;
					parent(baseShader, model, uniforms, frameBuffer);
					return;
				}

				parent(shader, model, uniforms, frameBuffer);
			},
			inPlace: false,
			requires: function (sourceName, inputs) {
				if (sourceName === 'sourceA' && inputs.split >= 1) {
					return false;
				}

				if (sourceName === 'sourceB' && inputs.split <= 0) {
					return false;
				}

				return true;
			}
		};
	},
	{
		inputs: {
			sourceA: {
				type: 'image',
				uniform: 'sourceA',
				shaderDirty: false,
				update: function () {
					this.resize();
				}
			},
			sourceB: {
				type: 'image',
				uniform: 'sourceB',
				shaderDirty: false,
				update: function () {
					this.resize();
				}
			},
			sizeMode: {
				type: 'enum',
				defaultValue: 'a',
				options: [
					'a',
					'b',
					'union',
					'intersection'
				],
				update: function () {
					this.resize();
				}
			},
			split: {
				type: 'number',
				uniform: 'split',
				defaultValue: 0.5,
				min: 0,
				max: 1
			},
			angle: {
				type: 'number',
				uniform: 'angle',
				defaultValue: 0
			},
			fuzzy: {
				type: 'number',
				uniform: 'fuzzy',
				defaultValue: 0,
				min: 0,
				max: 1
			}
		},
		description: 'Split screen or wipe',
		title: 'Split'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.tone.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('tone', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform vec4 light;\n' +
				'uniform vec4 dark;\n' +
				'uniform float desat;\n' +
				'uniform float toned;\n' +
				'\n' +
				'const vec3 lumcoeff = vec3(0.2125,0.7154,0.0721);\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec4 sourcePixel = texture2D(source, vTexCoord);\n' +
				'	vec3 sceneColor = light.rgb * sourcePixel.rgb;\n' +
				'	vec3 gray = vec3(dot(lumcoeff, sceneColor));\n' +
				'	vec3 muted = mix(sceneColor, gray, desat);\n' +
				'	vec3 tonedColor = mix(dark.rgb, light.rgb, gray);\n' +
				'	gl_FragColor = vec4(mix(muted, tonedColor, toned), sourcePixel.a);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			light: {
				type: 'color',
				uniform: 'light',
				defaultValue: [1, 0.9, 0.5, 1]
			},
			dark: {
				type: 'color',
				uniform: 'dark',
				defaultValue: [0.2, 0.05, 0, 1]
			},
			toned: {
				type: 'number',
				uniform: 'toned',
				defaultValue: 1,
				minimumRange: 0,
				maximumRange: 1
			},
			desat: {
				type: 'number',
				uniform: 'desat',
				defaultValue: 0.5,
				minimumRange: 0,
				maximumRange: 1
			}
		},
		title: 'Tone',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.tvglitch.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//particle parameters
	var minVelocity = 0.2,
		maxVelocity = 0.8,
		minSize = 0.02,
		maxSize = 0.3,
		particleCount = 20;

	Seriously.plugin('tvglitch', function () {
		var lastHeight,
			lastTime,
			particleBuffer,
			particleShader,
			particleFrameBuffer,
			gl;

		return {
			initialize: function (parent) {
				var i,
					sizeRange,
					velocityRange,
					particleVertex,
					particleFragment,
					particles;

				gl = this.gl;

				lastHeight = this.height;

				//initialize particles
				particles = [];
				sizeRange = maxSize - minSize;
				velocityRange = maxVelocity - minVelocity;
				for (i = 0; i < particleCount; i++) {
					particles.push(Math.random() * 2 - 1); //position
					particles.push(Math.random() * velocityRange + minVelocity); //velocity
					particles.push(Math.random() * sizeRange + minSize); //size
					particles.push(Math.random() * 0.2); //intensity
				}

				particleBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particles), gl.STATIC_DRAW);
				particleBuffer.itemSize = 4;
				particleBuffer.numItems = particleCount;

				particleVertex = '#ifdef GL_ES\n' +
				'precision mediump float;\n' +
				'#endif \n' +
				'\n' +
				'attribute vec4 particle;\n' +
				'\n' +
				'uniform float time;\n' +
				'uniform float height;\n' +
				'\n' +
				'varying float intensity;\n' +
				'\n' +
				'void main(void) {\n' +
				'	float y = particle.x + time * particle.y;\n' +
				'	y = fract((y + 1.0) / 2.0) * 4.0 - 2.0;\n' +
				'	intensity = particle.w;\n' +
				'	gl_Position = vec4(0.0, -y , 1.0, 2.0);\n' +
				//'	gl_Position = vec4(0.0, 1.0 , 1.0, 1.0);\n' +
				'	gl_PointSize = height * particle.z;\n' +
				'}\n';

				particleFragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying float intensity;\n' +
				'\n' +
				'void main(void) {\n' +
				'	gl_FragColor = vec4(1.0);\n' +
				'	gl_FragColor.a = 2.0 * intensity * (1.0 - abs(gl_PointCoord.y - 0.5));\n' +
				'}\n';

				particleShader = new Seriously.util.ShaderProgram(gl, particleVertex, particleFragment);

				particleFrameBuffer = new Seriously.util.FrameBuffer(gl, 1, this.height / 2);
				parent();
			},
			shader: function (inputs, shaderSource) {
				//baseShader = new Seriously.util.ShaderProgram(this.gl, shaderSource.vertex, shaderSource.fragment);

				shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					//'#define HardLight(top, bottom) (top < 0.5 ? (2.0 * top * bottom) : (1.0 - 2.0 * (1.0 - top) * (1.0 - bottom)))\n' +
					'#define HardLight(top, bottom)  (1.0 - 2.0 * (1.0 - top) * (1.0 - bottom))\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'uniform sampler2D particles;\n' +
					'uniform float time;\n' +
					'uniform float scanlines;\n' +
					'uniform float lineSync;\n' +
					'uniform float lineHeight;\n' + //for scanlines and distortion
					'uniform float distortion;\n' +
					'uniform float vsync;\n' +
					'uniform float bars;\n' +
					'uniform float frameSharpness;\n' +
					'uniform float frameShape;\n' +
					'uniform float frameLimit;\n' +
					'uniform vec4 frameColor;\n' +
					'\n' +
					//todo: need much better pseudo-random number generator
					Seriously.util.shader.noiseHelpers +
					Seriously.util.shader.snoise2d +
					'\n' +
					'void main(void) {\n' +
					'	vec2 texCoord = vTexCoord;\n' +

						//distortion
					'	float drandom = snoise(vec2(time * 50.0, texCoord.y /lineHeight));\n' +
					'	float distortAmount = distortion * (drandom - 0.25) * 0.5;\n' +
						//line sync
					'	vec4 particleOffset = texture2D(particles, vec2(0.0, texCoord.y));\n' +
					'	distortAmount -= lineSync * (2.0 * particleOffset.a - 0.5);\n' +

					'	texCoord.x -= distortAmount;\n' +
					//'	texCoord.x = max(0.0, texCoord.x);\n' +
					//'	texCoord.x = min(1.0, texCoord.x);\n' +
					'	texCoord.x = mod(texCoord.x, 1.0);\n' +

						//vertical sync
					'	float roll;\n' +
					'	if (vsync != 0.0) {\n' +
					'		roll = fract(time / vsync);\n' +
					'		texCoord.y = mod(texCoord.y - roll, 1.0);\n' +
					'	}\n' +

					'	vec4 pixel = texture2D(source, texCoord);\n' +

						//horizontal bars
					'	float barsAmount = particleOffset.r;\n' +
					'	if (barsAmount > 0.0) {\n' +
					/*
					'		pixel = vec4(HardLight(pixel.r * bars, barsAmount),' +
								'HardLight(pixel.g * bars, barsAmount),' +
								'HardLight(pixel.b * bars, barsAmount),' +
								'pixel.a);\n' +
					*/
					'		pixel = vec4(pixel.r + bars * barsAmount,' +
								'pixel.g + bars * barsAmount,' +
								'pixel.b + bars * barsAmount,' +
								'pixel.a);\n' +
					'	}\n' +

					'	if (mod(texCoord.y / lineHeight, 2.0) < 1.0 ) {\n' +
					'		pixel.rgb *= (1.0 - scanlines);\n' +
					'	}\n' +

					'	float f = (1.0 - vPosition.x * vPosition.x) * (1.0 - vPosition.y * vPosition.y);\n' +
					'	float frame = clamp( frameSharpness * (pow(f, frameShape) - frameLimit), 0.0, 1.0);\n' +

					//'	gl_FragColor.r = vec4(1.0);\n' +

					'	gl_FragColor = mix(frameColor, pixel, frame); //vec4(vec3(particleOffset), 1.0);\n' +
					//'	gl_FragColor = vec4(particleOffset);\n' +
					//'	gl_FragColor.a = 1.0;\n' +
					'}\n';

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, parent) {
				var doParticles = (lastTime !== this.inputs.time),
					vsyncPeriod;

				if (lastHeight !== this.height) {
					lastHeight = this.height;
					//todo: adjust framebuffer height?
					doParticles = true;
				}

				//todo: make this configurable?
				uniforms.lineHeight = 1 / this.height;

				if (this.inputs.verticalSync) {
					vsyncPeriod = 0.2 / this.inputs.verticalSync;
					uniforms.vsync = vsyncPeriod;
				} else {
					vsyncPeriod = 1;
					uniforms.vsync = 0;
				}
				uniforms.time = (this.inputs.time % (10000 * vsyncPeriod)) / 1000;
				uniforms.distortion = Math.random() * this.inputs.distortion;

				//render particle canvas and attach uniform
				//todo: this is a good spot for parallel processing. ParallelArray maybe?
				if (doParticles && (this.inputs.lineSync || this.inputs.bars)) {
					particleShader.use();
					gl.viewport(0, 0, 1, this.height / 2);
					gl.bindFramebuffer(gl.FRAMEBUFFER, particleFrameBuffer.frameBuffer);
					gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
					gl.enableVertexAttribArray(particleShader.location.particle);
					gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
					gl.vertexAttribPointer(particleShader.location.particle, particleBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.enable(gl.BLEND);
					gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
					particleShader.time.set(uniforms.time);
					particleShader.height.set(this.height);
					gl.drawArrays(gl.POINTS, 0, particleCount);

					lastTime = this.inputs.time;
				}
				uniforms.particles = particleFrameBuffer.texture;

				parent(shader, model, uniforms, frameBuffer);
			},
			destroy: function () {
				particleBuffer = null;
				if (particleFrameBuffer) {
					particleFrameBuffer.destroy();
					particleFrameBuffer = null;
				}
			}
		};
	},
	{
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			time: {
				type: 'number',
				defaultValue: 0
			},
			distortion: {
				type: 'number',
				defaultValue: 0.1,
				min: 0,
				max: 1
			},
			verticalSync: {
				type: 'number',
				defaultValue: 0.1,
				min: 0,
				max: 1
			},
			lineSync: {
				type: 'number',
				uniform: 'lineSync',
				defaultValue: 0.2,
				min: 0,
				max: 1
			},
			scanlines: {
				type: 'number',
				uniform: 'scanlines',
				defaultValue: 0.3,
				min: 0,
				max: 1
			},
			bars: {
				type: 'number',
				uniform: 'bars',
				defaultValue: 0,
				min: 0,
				max: 1
			},
			frameShape: {
				type: 'number',
				uniform: 'frameShape',
				min: 0,
				max: 2,
				defaultValue: 0.27
			},
			frameLimit: {
				type: 'number',
				uniform: 'frameLimit',
				min: -1,
				max: 1,
				defaultValue: 0.34
			},
			frameSharpness: {
				type: 'number',
				uniform: 'frameSharpness',
				min: 0,
				max: 40,
				defaultValue: 8.4
			},
			frameColor: {
				type: 'color',
				uniform: 'frameColor',
				defaultValue: [0, 0, 0, 1]
			}
		},
		title: 'TV Glitch'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.vignette.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('vignette', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'uniform float amount;\n' +
					'\n' +
					'void main(void) {\n' +
					'	vec4 pixel = texture2D(source, vTexCoord);\n' +
					'	vec2 pos = vTexCoord.xy - 0.5;\n' +
					'	float vignette = 1.0 - (dot(pos, pos) * amount);\n' +
					'	gl_FragColor = vec4(pixel.rgb * vignette, pixel.a);\n' +
					'}\n';
			return shaderSource;
		},
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 1,
				min: 0
			}
		},
		title: 'Vignette',
		description: 'Vignette'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.whitebalance.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*

	Math references:
	en.wikipedia.org/wiki/Color_balance
	http://scien.stanford.edu/pages/labsite/2010/psych221/projects/2010/JasonSu/adaptation.html
	https://github.com/ikaros-project/ikaros/blob/master/Source/Modules/VisionModules/WhiteBalance/WhiteBalance.cc

	*/

	var identity = new Float32Array([
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	]);

	Seriously.plugin('whitebalance', function () {
		var pyramidShader,
			pyramidBuffers = [],
			width,
			height,
			pyramidSize,
			log2 = Math.log(2),
			me = this,
			//baseShader, //todo: share one with main object
			gl,

			MAX_TEXTURE_SIZE;

		/*
		todo: handle special case where node is square and power of two. save on one pyramid iteration
		*/

		function updateSize(w, h) {
			var size, numLevels, n,
				i;

			if (width === w && height === h) {
				return;
			}

			width = w;
			height = h;

			numLevels = Math.ceil(Math.log(Math.max(h, w)) / log2);
			size = Math.pow(2, numLevels);

			if (size > MAX_TEXTURE_SIZE) {
				numLevels = Math.ceil(Math.log(MAX_TEXTURE_SIZE) / log2);
				size = MAX_TEXTURE_SIZE;
			}

			numLevels++;
			if (pyramidSize === size) {
				return;
			}

			pyramidSize = size;

			while (pyramidBuffers.length > numLevels) {
				(pyramidBuffers.pop()).fb.destroy();
			}

			while (pyramidBuffers.length < numLevels) {
				i = pyramidBuffers.length;
				n = Math.pow(2, i);
				pyramidBuffers.push({
					fb: new Seriously.util.FrameBuffer(me.gl, n, n),//, true),
					opts: {
						width: n,
						height: n
					},
					uniforms: {
						level: pyramidBuffers.length,
						offset: 0.25 / n,
						transform: identity,
						projection: identity,
						resolution: [n, n]
					}
				});

				if (i) {
					pyramidBuffers[i - 1].uniforms.source = pyramidBuffers[i].fb.texture;
				}
			}
		}


		return {
			initialize: function (initialize) {
				gl = this.gl;

				MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);

				if (this.inputs.auto) {
					updateSize(this.width, this.height);
				}

				initialize();
			},
			shader: function (inputs, shaderSource) {
				var auto = inputs.auto;
				//baseShader = new Seriously.util.ShaderProgram(this.gl, shaderSource.vertex, shaderSource.fragment);
				//todo: gl.getExtension('OES_texture_float_linear')

				if (auto && !pyramidShader) {
					pyramidShader = new Seriously.util.ShaderProgram(this.gl, shaderSource.vertex, [
						'precision mediump float;',

						'varying vec2 vTexCoord;',
						'varying vec4 vPosition;',

						'uniform sampler2D source;',
						'uniform float offset;',
						'uniform int level;',

						'void main(void) {',
						//gl.getExtension("OES_texture_float"), gl.getExtension("OES_texture_float_linear")
						//'	vec4 pixel = texture2D(source, vTexCoord);',

						'	vec4 pixel = texture2D(source, vTexCoord - vec2(offset)) +',
						'		texture2D(source, vTexCoord + vec2(offset, -offset)) +',
						'		texture2D(source, vTexCoord + vec2(offset)) +',
						'		texture2D(source, vTexCoord + vec2(-offset, offset));',
						'	pixel /= 4.0;',
						'	gl_FragColor = pixel;',
						'}'
					].join('\n'));
				}

				shaderSource.fragment = [
					auto ? '#define AUTO' : '',
					'precision mediump float;',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'uniform sampler2D source;',
					'#ifdef AUTO',
					'uniform sampler2D whiteSource;',
					'#else',
					'uniform vec4 white;',
					'#endif',

					// matrices from: http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
					/*
					raw RGB just seems to work better so let's use that until we figure Bradford out
					'const mat3 rgbToBradford = mat3(',
					'	0.4360747, 0.2225045, 0.0139322,',
					'	0.3850649, 0.7168786, 0.0971045,',
					'	0.1430804, 0.0606169, 0.7141733',
					');',

					'const mat3 bradfordToRgb = mat3(',
					'	3.1338561, -0.9787684, 0.0719453,',
					'	-1.6168667, 1.9161415, -0.2289914,',
					'	-0.4906146, 0.033454, 1.4052427',
					');',
					*/

					'const vec3 luma = vec3(0.2125, 0.7154, 0.0721);',

					'void main(void) {',
					'	vec4 pixel = texture2D(source, vTexCoord);',
					'#ifdef AUTO',
					'	vec4 white = texture2D(whiteSource, vTexCoord);',
					'#endif',
					/*
					'	vec3 whiteBradford = rgbToBradford * white.rgb;',
					'	vec3 targetBradford = rgbToBradford * vec3(dot(white.rgb, luma));',
					'	vec3 colorBradford = rgbToBradford * pixel.rgb;',
					'	pixel.rgb = clamp(bradfordToRgb * (colorBradford * targetBradford / whiteBradford), 0.0, 1.0);',
					*/
					'	vec3 target = vec3(dot(white.rgb, luma));',
					'	pixel.rgb = pixel.rgb * target / white.rgb;',
					'	gl_FragColor = pixel;',
					'}'
				].join('\n');

				return shaderSource;
			},
			resize: function () {
				if (this.gl && this.inputs.auto) {
					updateSize(this.width, this.height);
				}
			},
			draw: function (shader, model, uniforms, frameBuffer, draw) {
				var i,
					buf;

				if (this.inputs.auto) {
					i = pyramidBuffers.length - 1;
					pyramidBuffers[i].uniforms.source = uniforms.source;
					while (i >= 0) {
						buf = pyramidBuffers[i];
						draw(pyramidShader, model, buf.uniforms, buf.fb.frameBuffer, null, buf.opts);
						i--;
					}

					uniforms.whiteSource = pyramidBuffers[0].fb.texture;
				}

				draw(shader, model, uniforms, frameBuffer);
			},
			destroy: function () {
				while (pyramidBuffers.length) {
					pyramidBuffers.pop().destroy();
				}
			},
			inPlace: false,
			inputs: {
				source: {
					type: 'image',
					uniform: 'source',
					shaderDirty: false
				},
				white: {
					type: 'color',
					uniform: 'white',
					defaultValue: [1, 1, 1]
				},
				auto: {
					type: 'boolean',
					shaderDirty: true,
					defaultValue: true
				}
			}
		};
	},
	{
		title: 'White Balance'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/transforms/seriously.camerashake.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	Camera Shake
	- amplitude (x/y)
	- center (x/y)
	- rotation (degrees)
	- frequency
	- octaves
	- autoScale (true/false)
	*/


	/*
	Simplex Noise
	adapted from https://github.com/jwagner/simplex-noise.js
	*/

	var mat4 = Seriously.util.mat4,

		f2 = 0.5 * (Math.sqrt(3.0) - 1.0),
		g2 = (3.0 - Math.sqrt(3.0)) / 6.0,

		random = Math.random,
		p,
		perm,
		permMod12,
		grad3,
		initialized = false;

	function initializeSimplex() {
		//initialize simplex lookup tables
		var i;
		if (!initialized) {
			p = new Uint8Array(256);
			perm = new Uint8Array(512);
			permMod12  = new Uint8Array(512);
			grad3 = new Float32Array([
				1, 1, 0,
				- 1, 1, 0,
				1, - 1, 0,

				- 1, - 1, 0,
				1, 0, 1,
				- 1, 0, 1,

				1, 0, - 1,
				- 1, 0, - 1,
				0, 1, 1,

				0, - 1, 1,
				0, 1, - 1,
				0, - 1, - 1
			]);

			for (i = 0; i < 256; i++) {
				p[i] = random() * 256;
			}
			for (i = 0; i < 512; i++) {
				perm[i] = p[i & 255];
				permMod12[i] = perm[i] % 12;
			}
			initialized = true;
		}
	}

	function noise2D(xin, yin) {
		var n0 = 0, // Noise contributions from the three corners
			n1 = 0, // Skew the input space to determine which simplex cell we're in
			n2 = 0,

			s = (xin + yin) * f2, // Hairy factor for 2D
			i = Math.floor(xin + s),
			j = Math.floor(yin + s),
			t = (i + j) * g2,

			xx0 = i - t, // Unskew the cell origin back to (x,y) space
			yy0 = j - t,

			x0 = xin - xx0,
			y0 = yin - yy0,

			/*
			For the 2D case, the simplex shape is an equilateral triangle.
			Determine which simplex we are in.

			Offsets for second (middle) corner of simplex in (i,j) coords
			*/
			i1 = x0 > y0 ? 1 : 0,
			j1 = (i1 + 1) % 2, //opposite of i1

			x1 = x0 - i1 + g2,
			y1 = y0 - j1 + g2,
			x2 = x0 - 1 + 2 * g2,
			y2 = y0 - 1 + 2 * g2,

			ii = i & 255,
			jj = j & 255,

			t0 = 0.5 - x0 * x0 - y0 * y0,

			t1,
			t2,

			gi;

		if (t0 >= 0) {
            gi = permMod12[ii + perm[jj]] * 3;
            t0 *= t0;
            n0 = t0 * t0 * (grad3[gi] * x0 + grad3[gi + 1] * y0); // (x,y) of grad3 used for 2D gradient
        }

        t1 = 0.5 - x1 * x1 - y1 * y1;
		if (t1 >= 0) {
			gi = permMod12[ii + i1 + perm[jj + j1]] * 3;
			t1 *= t1;
			n1 = t1 * t1 * (grad3[gi] * x1 + grad3[gi + 1] * y1);
		}

		t2 = 0.5 - x2 * x2 - y2 * y2;
		if (t2 >= 0) {
			gi = permMod12[ii + 1 + perm[jj + 1]] * 3;
			t2 *= t2;
			n2 = t2 * t2 * (grad3[gi] * x2 + grad3[gi + 1] * y2);
		}

		return 70.0 * (n0 + n1 + n2);
	}

	Seriously.transform('camerashake', function () {
		var me = this,
			octaves = 1,
			time = 0,
			amplitudeX = 0,
			amplitudeY = 0,
			centerX = 0,
			centerY = 0,
			frequency = 1,
			rotation = 0;

		function recompute() {
			var matrix = me.matrix,
				s, c,
				t,
				freq,
				amp,
				adjust = 0,
				i,
				translateX = 0,
				translateY = 0,
				rotationZ = 0,
				m00,
				m01,
				m02,
				m03,
				m10,
				m11,
				m12,
				m13;

			function translate(x, y) {
				matrix[12] = matrix[0] * x + matrix[4] * y + matrix[12];
				matrix[13] = matrix[1] * x + matrix[5] * y + matrix[13];
				matrix[14] = matrix[2] * x + matrix[6] * y + matrix[14];
				matrix[15] = matrix[3] * x + matrix[7] * y + matrix[15];
			}

			function rotateZ() {
				var angle;

				if (!rotationZ) {
					return;
				}

				angle = rotationZ * Math.PI / 180;

				s = Math.sin(angle);
				c = Math.cos(angle);

				m00 = matrix[0];
				m01 = matrix[1];
				m02 = matrix[2];
				m03 = matrix[3];
				m10 = matrix[4];
				m11 = matrix[5];
				m12 = matrix[6];
				m13 = matrix[7];

				matrix[0] = m00 * c + m10 * s;
				matrix[1] = m01 * c + m11 * s;
				matrix[2] = m02 * c + m12 * s;
				matrix[3] = m03 * c + m13 * s;
				matrix[4] = m10 * c - m00 * s;
				matrix[5] = m11 * c - m01 * s;
				matrix[6] = m12 * c - m02 * s;
				matrix[7] = m13 * c - m03 * s;
			}

			if (!amplitudeX &&
					!amplitudeY &&
					!rotation
					) {
				me.transformed = false;
				return;
			}

			t = time * frequency;

			for (i = 0; i < octaves; i++) {
				freq = Math.pow(2, i);
				amp = Math.pow(0.5, i);
				adjust += amp;
				if (rotation) {
					rotationZ += noise2D(t * freq, 7 * freq) * amp;
				}
				if (amplitudeX) {
					translateX += noise2D(t * freq, 11 * freq) * amp;
				}
				if (amplitudeY) {
					translateY += noise2D(t * freq, 13 * freq) * amp;
				}
			}
			rotationZ *= rotation / adjust;
			translateX *= amplitudeX / adjust;
			translateY *= amplitudeY / adjust;

			//calculate transformation matrix
			mat4.identity(matrix);

			translate(translateX + centerX, translateY + centerY);

			rotateZ();

			/*
			//scale
			if (scaleX !== 1) {
				matrix[0] *= scaleX;
				matrix[1] *= scaleX;
				matrix[2] *= scaleX;
				matrix[3] *= scaleX;
			}
			if (scaleY !== 1) {
				matrix[4] *= scaleY;
				matrix[5] *= scaleY;
				matrix[6] *= scaleY;
				matrix[7] *= scaleY;
			}
			*/

			translate(-centerX, -centerY);

			me.transformed = true;
		}

		initializeSimplex();

		return {
			inputs: {
				time: {
					get: function () {
						return time;
					},
					set: function (t) {
						if (t === time) {
							return false;
						}

						time = t;

						recompute();
						return true;
					},
					type: 'number'
				},
				frequency: {
					get: function () {
						return frequency;
					},
					set: function (f) {
						if (f === frequency) {
							return false;
						}

						frequency = f;

						recompute();
						return true;
					},
					type: 'number'
				},
				octaves: {
					get: function () {
						return octaves;
					},
					set: function (o) {
						o = Math.max(1, o);
						if (o === octaves) {
							return false;
						}

						octaves = o;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotation: {
					get: function () {
						return rotation;
					},
					set: function (r) {
						if (r === rotation) {
							return false;
						}

						rotation = r;

						recompute();
						return true;
					},
					type: 'number'
				},
				centerX: {
					get: function () {
						return centerX;
					},
					set: function (x) {
						if (x === centerX) {
							return false;
						}

						centerX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				centerY: {
					get: function () {
						return centerY;
					},
					set: function (y) {
						if (y === centerY) {
							return false;
						}

						centerY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				amplitudeX: {
					get: function () {
						return amplitudeX;
					},
					set: function (x) {
						x = Math.max(0, x);
						if (x === amplitudeX) {
							return false;
						}

						amplitudeX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				amplitudeY: {
					get: function () {
						return amplitudeY;
					},
					set: function (y) {
						y = Math.max(0, y);
						if (y === amplitudeY) {
							return false;
						}

						amplitudeY = y;

						recompute();
						return true;
					},
					type: 'number'
				}
			}
		};
	}, {
		title: 'Camera Shake'
	});
}));
});
require.register("forresto-noflo-seriously/vendor/transforms/seriously.transform3d.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var mat4 = Seriously.util.mat4;

	/*
	3D transform
	- translate
	- rotate (degrees)
	- scale
	*/
	Seriously.transform('3d', function (options) {
		var me = this,
			degrees = !(options && options.radians),
			centerX = 0,
			centerY = 0,
			centerZ = 0,
			scaleX = 1,
			scaleY = 1,
			scaleZ = 1,
			translateX = 0,
			translateY = 0,
			translateZ = 0,
			rotationX = 0,
			rotationY = 0,
			rotationZ = 0,
			rotationOrder = 'XYZ';

		function recompute() {
			var matrix = me.matrix,
				s, c,
				m00,
				m01,
				m02,
				m03,
				m10,
				m11,
				m12,
				m13,
				m20,
				m21,
				m22,
				m23;

			function translate(x, y, z) {
				matrix[12] = matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12];
				matrix[13] = matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13];
				matrix[14] = matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14];
				matrix[15] = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15];
			}

			function rotateX() {
				var angle;

				if (!rotationX) {
					return;
				}

				angle = -(degrees ? rotationX * Math.PI / 180 : rotationX);

				s = Math.sin(angle);
				c = Math.cos(angle);

				m10 = matrix[4];
				m11 = matrix[5];
				m12 = matrix[6];
				m13 = matrix[7];
				m20 = matrix[8];
				m21 = matrix[9];
				m22 = matrix[10];
				m23 = matrix[11];

				matrix[4] = m10 * c + m20 * s;
				matrix[5] = m11 * c + m21 * s;
				matrix[6] = m12 * c + m22 * s;
				matrix[7] = m13 * c + m23 * s;
				matrix[8] = m20 * c - m10 * s;
				matrix[9] = m21 * c - m11 * s;
				matrix[10] = m22 * c - m12 * s;
				matrix[11] = m23 * c - m13 * s;
			}

			function rotateY() {
				var angle;

				if (!rotationY) {
					return;
				}

				angle = -(degrees ? rotationY * Math.PI / 180 : rotationY);

				s = Math.sin(angle);
				c = Math.cos(angle);

				m00 = matrix[0];
				m01 = matrix[1];
				m02 = matrix[2];
				m03 = matrix[3];
				m20 = matrix[8];
				m21 = matrix[9];
				m22 = matrix[10];
				m23 = matrix[11];

				matrix[0] = m00 * c - m20 * s;
				matrix[1] = m01 * c - m21 * s;
				matrix[2] = m02 * c - m22 * s;
				matrix[3] = m03 * c - m23 * s;
				matrix[8] = m00 * s + m20 * c;
				matrix[9] = m01 * s + m21 * c;
				matrix[10] = m02 * s + m22 * c;
				matrix[11] = m03 * s + m23 * c;
			}

			function rotateZ() {
				var angle;

				if (!rotationZ) {
					return;
				}

				angle = -(degrees ? rotationZ * Math.PI / 180 : rotationZ);

				s = Math.sin(angle);
				c = Math.cos(angle);

				m00 = matrix[0];
				m01 = matrix[1];
				m02 = matrix[2];
				m03 = matrix[3];
				m10 = matrix[4];
				m11 = matrix[5];
				m12 = matrix[6];
				m13 = matrix[7];

				matrix[0] = m00 * c + m10 * s;
				matrix[1] = m01 * c + m11 * s;
				matrix[2] = m02 * c + m12 * s;
				matrix[3] = m03 * c + m13 * s;
				matrix[4] = m10 * c - m00 * s;
				matrix[5] = m11 * c - m01 * s;
				matrix[6] = m12 * c - m02 * s;
				matrix[7] = m13 * c - m03 * s;
			}

			if (!translateX &&
					!translateY &&
					!translateZ &&
					!rotationX &&
					!rotationY &&
					!rotationZ &&
					scaleX === 1 &&
					scaleY === 1 &&
					scaleZ === 1
					) {
				me.transformed = false;
				return;
			}

			//calculate transformation matrix
			mat4.identity(matrix);

			translate(translateX + centerX, translateY + centerY, translateZ + centerZ);

			if (rotationOrder === 'XYZ') {
				rotateX();
				rotateY();
				rotateZ();
			} else if (rotationOrder === 'XZY') {
				rotateX();
				rotateZ();
				rotateY();
			} else if (rotationOrder === 'YXZ') {
				rotateY();
				rotateX();
				rotateZ();
			} else if (rotationOrder === 'YZX') {
				rotateY();
				rotateZ();
				rotateX();
			} else if (rotationOrder === 'ZXY') {
				rotateZ();
				rotateX();
				rotateY();
			} else { //ZYX
				rotateZ();
				rotateY();
				rotateX();
			}

			//scale
			if (scaleX !== 1) {
				matrix[0] *= scaleX;
				matrix[1] *= scaleX;
				matrix[2] *= scaleX;
				matrix[3] *= scaleX;
			}
			if (scaleY !== 1) {
				matrix[4] *= scaleY;
				matrix[5] *= scaleY;
				matrix[6] *= scaleY;
				matrix[7] *= scaleY;
			}
			if (scaleZ !== 1) {
				matrix[8] *= scaleZ;
				matrix[9] *= scaleZ;
				matrix[10] *= scaleZ;
				matrix[11] *= scaleZ;
			}

			translate(-centerX, -centerY, -centerZ);

			me.transformed = true;
		}

		return {
			inputs: {
				reset: {
					method: function () {
						centerX = 0;
						centerY = 0;
						centerZ = 0;
						scaleX = 1;
						scaleY = 1;
						scaleZ = 1;
						translateX = 0;
						translateY = 0;
						translateZ = 0;
						rotationX = 0;
						rotationY = 0;
						rotationZ = 0;

						if (me.transformed) {
							me.transformed = false;
							return true;
						}

						return false;
					}
				},
				translate: {
					method: function (x, y, z) {
						if (isNaN(x)) {
							x = translateX;
						}

						if (isNaN(y)) {
							y = translateY;
						}

						if (isNaN(z)) {
							z = translateZ;
						}

						if (x === translateX && y === translateY && z === translateZ) {
							return false;
						}

						translateX = x;
						translateY = y;
						translateZ = z;

						recompute();
						return true;
					},
					type: [
						'number',
						'number',
						'number'
					]
				},
				translateX: {
					get: function () {
						return translateX;
					},
					set: function (x) {
						if (x === translateX) {
							return false;
						}

						translateX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				translateY: {
					get: function () {
						return translateY;
					},
					set: function (y) {
						if (y === translateY) {
							return false;
						}

						translateY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				translateZ: {
					get: function () {
						return translateZ;
					},
					set: function (z) {
						if (z === translateZ) {
							return false;
						}

						translateZ = z;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotationOrder: {
					get: function () {
						return rotationOrder;
					},
					set: function (order) {
						if (order === rotationOrder) {
							return false;
						}

						rotationOrder = order;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotationX: {
					get: function () {
						return rotationX;
					},
					set: function (angle) {
						if (angle === rotationX) {
							return false;
						}

						//todo: fmod 360deg or Math.PI * 2 radians
						rotationX = angle;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotationY: {
					get: function () {
						return rotationY;
					},
					set: function (angle) {
						if (angle === rotationY) {
							return false;
						}

						//todo: fmod 360deg or Math.PI * 2 radians
						rotationY = angle;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotationZ: {
					get: function () {
						return rotationZ;
					},
					set: function (angle) {
						if (angle === rotationZ) {
							return false;
						}

						//todo: fmod 360deg or Math.PI * 2 radians
						rotationZ = angle;

						recompute();
						return true;
					},
					type: 'number'
				},
				center: {
					method: function (x, y, z) {
						if (isNaN(x)) {
							x = centerX;
						}

						if (isNaN(y)) {
							y = centerY;
						}

						if (isNaN(z)) {
							z = centerZ;
						}

						if (x === centerX && y === centerY && z === centerZ) {
							return false;
						}

						centerX = x;
						centerY = y;
						centerZ = z;

						recompute();
						return true;
					},
					type: [
						'number',
						'number',
						'number'
					]
				},
				centerX: {
					get: function () {
						return centerX;
					},
					set: function (x) {
						if (x === centerX) {
							return false;
						}

						centerX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				centerY: {
					get: function () {
						return centerY;
					},
					set: function (y) {
						if (y === centerY) {
							return false;
						}

						centerY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				centerZ: {
					get: function () {
						return centerZ;
					},
					set: function (z) {
						if (z === centerZ) {
							return false;
						}

						centerZ = z;

						recompute();
						return true;
					},
					type: 'number'
				},
				scale: {
					method: function (x, y, z) {
						var newX, newY, newZ;

						if (isNaN(x)) {
							newX = scaleX;
						} else {
							newX = x;
						}

						/*
						if only one value is specified, set all to the same scale
						*/
						if (isNaN(y)) {
							if (!isNaN(x) && isNaN(z)) {
								newY = newX;
								newZ = newX;
							} else {
								newY = scaleY;
							}
						} else {
							newY = y;
						}

						if (isNaN(z)) {
							if (newZ === undefined) {
								newZ = scaleZ;
							}
						} else {
							newZ = z;
						}

						if (newX === scaleX && newY === scaleY && newZ === scaleZ) {
							return false;
						}

						scaleX = newX;
						scaleY = newY;
						scaleZ = newZ;

						recompute();
						return true;
					},
					type: [
						'number',
						'number',
						'number'
					]
				},
				scaleX: {
					get: function () {
						return scaleX;
					},
					set: function (x) {
						if (x === scaleX) {
							return false;
						}

						scaleX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				scaleY: {
					get: function () {
						return scaleY;
					},
					set: function (y) {
						if (y === scaleY) {
							return false;
						}

						scaleY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				scaleZ: {
					get: function () {
						return scaleZ;
					},
					set: function (z) {
						if (z === scaleZ) {
							return false;
						}

						scaleZ = z;

						recompute();
						return true;
					},
					type: 'number'
				}
			}
		};
	}, {
		title: '3D Transform',
		description: 'Translate, Rotate, Scale'
	});
}));
});
require.register("forresto-noflo-seriously/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-seriously","description":"Seriously.js WebGL shader image effects for NoFlo.","author":"Forrest Oliphant and Brian Chirls <forrest@sembiki.com>","repo":"forresto/noflo-seriously","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["index.js","vendor/seriously.js","vendor/effects/seriously.ascii.js","vendor/effects/seriously.bleach-bypass.js","vendor/effects/seriously.blend.js","vendor/effects/seriously.blur.js","vendor/effects/seriously.brightness-contrast.js","vendor/effects/seriously.channels.js","vendor/effects/seriously.chroma.js","vendor/effects/seriously.color.js","vendor/effects/seriously.colorcomplements.js","vendor/effects/seriously.colorcube.js","vendor/effects/seriously.daltonize.js","vendor/effects/seriously.directionblur.js","vendor/effects/seriously.dither.js","vendor/effects/seriously.edge.js","vendor/effects/seriously.emboss.js","vendor/effects/seriously.exposure.js","vendor/effects/seriously.fader.js","vendor/effects/seriously.falsecolor.js","vendor/effects/seriously.filmgrain.js","vendor/effects/seriously.hex.js","vendor/effects/seriously.highlights-shadows.js","vendor/effects/seriously.hue-saturation.js","vendor/effects/seriously.invert.js","vendor/effects/seriously.kaleidoscope.js","vendor/effects/seriously.layers.js","vendor/effects/seriously.linear-transfer.js","vendor/effects/seriously.lumakey.js","vendor/effects/seriously.nightvision.js","vendor/effects/seriously.noise.js","vendor/effects/seriously.repeat.js","vendor/effects/seriously.ripple.js","vendor/effects/seriously.scanlines.js","vendor/effects/seriously.sepia.js","vendor/effects/seriously.simplex.js","vendor/effects/seriously.sketch.js","vendor/effects/seriously.split.js","vendor/effects/seriously.tone.js","vendor/effects/seriously.tvglitch.js","vendor/effects/seriously.vignette.js","vendor/effects/seriously.whitebalance.js","vendor/transforms/seriously.camerashake.js","vendor/transforms/seriously.transform3d.js","components/SetFilterSource.coffee","components/SetFilterTarget.coffee","lib/SeriouslyEffect.coffee","components/FilterAscii.coffee","components/FilterBleachBypass.coffee","components/FilterBlend.coffee","components/FilterChannels.coffee","components/FilterChroma.coffee","components/FilterColor.coffee","components/FilterColorCube.coffee","components/FilterDaltonize.coffee","components/FilterEdge.coffee","components/FilterEmboss.coffee","components/FilterExposure.coffee","components/FilterFader.coffee","components/FilterHex.coffee","components/FilterHueSaturation.coffee","components/FilterInvert.coffee","components/FilterLumakey.coffee","components/FilterNightVision.coffee","components/FilterNoise.coffee","components/FilterRipple.coffee","components/FilterScanLines.coffee","components/FilterSepia.coffee","components/FilterSketch.coffee","components/FilterSplit.coffee","components/FilterTone.coffee","components/FilterTVGlitch.coffee","components/FilterVignette.coffee"],"json":["component.json"],"noflo":{"icon":"film","components":{"SetSource":"components/SetFilterSource.coffee","SetTarget":"components/SetFilterTarget.coffee","Ascii":"components/FilterAscii.coffee","BleachBypass":"components/FilterBleachBypass.coffee","Blend":"components/FilterBlend.coffee","Channels":"components/FilterChannels.coffee","Chroma":"components/FilterChroma.coffee","Color":"components/FilterColor.coffee","ColorCube":"components/FilterColorCube.coffee","Daltonize":"components/FilterDaltonize.coffee","Edge":"components/FilterEdge.coffee","Emboss":"components/FilterEmboss.coffee","Exposure":"components/FilterExposure.coffee","Fader":"components/FilterFader.coffee","Hex":"components/FilterHex.coffee","HueSaturation":"components/FilterHueSaturation.coffee","Invert":"components/FilterInvert.coffee","Lumakey":"components/FilterLumakey.coffee","NightVision":"components/FilterNightVision.coffee","Noise":"components/FilterNoise.coffee","Ripple":"components/FilterRipple.coffee","ScanLines":"components/FilterScanLines.coffee","Sepia":"components/FilterSepia.coffee","Sketch":"components/FilterSketch.coffee","Split":"components/FilterSplit.coffee","Tone":"components/FilterTone.coffee","TVGlitch":"components/FilterTVGlitch.coffee","Vignette":"components/FilterVignette.coffee"}}}');
});
require.register("forresto-noflo-seriously/components/SetFilterSource.js", function(exports, require, module){
var Seriously, SetFilterSource, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

SetFilterSource = (function(_super) {
  __extends(SetFilterSource, _super);

  function SetFilterSource() {
    this.setSource = __bind(this.setSource, this);
    if (!window.nofloSeriously) {
      window.nofloSeriously = new Seriously();
    }
    this.seriously = window.nofloSeriously;
    this.inPorts = {
      source: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('object')
    };
    this.inPorts.source.on('data', this.setSource);
  }

  SetFilterSource.prototype.setSource = function(data) {
    if (this.outPorts.out.isAttached()) {
      return this.outPorts.out.send(this.seriously.source(data));
    }
  };

  return SetFilterSource;

})(noflo.Component);

exports.getComponent = function() {
  return new SetFilterSource;
};

});
require.register("forresto-noflo-seriously/components/SetFilterTarget.js", function(exports, require, module){
var Seriously, SetFilterTarget, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

SetFilterTarget = (function(_super) {
  __extends(SetFilterTarget, _super);

  function SetFilterTarget() {
    this.seriouslyGo = __bind(this.seriouslyGo, this);
    this.setTarget = __bind(this.setTarget, this);
    this.unsyncSource = __bind(this.unsyncSource, this);
    this.syncSource = __bind(this.syncSource, this);
    if (!window.nofloSeriously) {
      window.nofloSeriously = new Seriously();
    }
    this.seriously = window.nofloSeriously;
    this.inPorts = {
      source: new noflo.ArrayPort('object'),
      target: new noflo.Port('object')
    };
    this.inPorts.source.on('data', this.syncSource);
    this.inPorts.source.on('disconnect', this.unsyncSource);
    this.inPorts.target.on('data', this.setTarget);
  }

  SetFilterTarget.prototype.syncSource = function(upstream) {
    if (!upstream) {
      return;
    }
    if (this.seriouslyNode) {
      this.seriouslyNode.source = upstream;
      return this.seriouslyGo();
    } else {
      return this.upstream = upstream;
    }
  };

  SetFilterTarget.prototype.unsyncSource = function(event) {
    if (this.seriouslyStarted) {
      this.seriously.stop();
      return this.seriouslyStarted = false;
    }
  };

  SetFilterTarget.prototype.setTarget = function(data) {
    this.seriouslyNode = this.seriously.target(data);
    if (this.upstream) {
      this.seriouslyNode.source = this.upstream;
      this.seriouslyGo();
      return this.upstream = null;
    }
  };

  SetFilterTarget.prototype.seriouslyGo = function() {
    if (!this.seriouslyStarted) {
      this.seriously.go();
      return this.seriouslyStarted = true;
    }
  };

  return SetFilterTarget;

})(noflo.Component);

exports.getComponent = function() {
  return new SetFilterTarget;
};

});
require.register("forresto-noflo-seriously/lib/SeriouslyEffect.js", function(exports, require, module){
var Seriously, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

exports.SeriouslyEffect = (function(_super) {
  __extends(SeriouslyEffect, _super);

  function SeriouslyEffect(filterName, imageInCount) {
    var effectInfo, input, key, nofloPort, seriouslyPort, type, _ref, _ref1;
    if (!window.nofloSeriously) {
      window.nofloSeriously = new Seriously();
    }
    this.seriously = window.nofloSeriously;
    this.sources = {};
    this.seriouslyNode = this.seriously.effect(filterName);
    effectInfo = this.seriously.effects()[filterName];
    if ((_ref = effectInfo.description) != null ? _ref.length : void 0) {
      this.description = effectInfo.description;
    }
    this.inPorts = {};
    this.outPorts = {
      out: new noflo.ArrayPort('object')
    };
    _ref1 = effectInfo.inputs;
    for (key in _ref1) {
      if (!__hasProp.call(_ref1, key)) continue;
      input = _ref1[key];
      seriouslyPort = key;
      nofloPort = seriouslyPort.toLowerCase();
      type = input.type;
      if (type === 'image') {
        this.inPorts[nofloPort] = new noflo.Port('object');
        this.inPorts[nofloPort].on('data', this.syncGraph.bind(this, nofloPort, seriouslyPort));
        this.inPorts[nofloPort].on('disconnect', this.unsyncGraph.bind(this, nofloPort, seriouslyPort));
      } else {
        this.inPorts[nofloPort] = new noflo.Port(type);
        this.inPorts[nofloPort].on('data', this.setParam.bind(this, nofloPort, seriouslyPort));
      }
    }
  }

  SeriouslyEffect.prototype.syncGraph = function(nofloPort, seriouslyPort, upstream) {
    if (!upstream) {
      return;
    }
    this.sources[nofloPort] = upstream;
    this.seriouslyNode[seriouslyPort] = upstream;
    if (this.outPorts.out.isAttached()) {
      return this.outPorts.out.send(this.seriouslyNode);
    }
  };

  SeriouslyEffect.prototype.unsyncGraph = function(nofloPort, seriouslyPort) {
    this.seriouslyNode[seriouslyPort] = null;
    delete this.sources[nofloPort];
    if (this.outPorts.out.isAttached()) {
      return this.outPorts.out.disconnect();
    }
  };

  SeriouslyEffect.prototype.setParam = function(nofloPort, seriouslyPort, data) {
    return this.seriouslyNode[seriouslyPort] = data;
  };

  SeriouslyEffect.prototype.shutdown = function() {
    var key, val, _ref, _results;
    _ref = this.sources;
    _results = [];
    for (key in _ref) {
      val = _ref[key];
      _results.push(this.unsyncGraph(key));
    }
    return _results;
  };

  return SeriouslyEffect;

})(noflo.Component);

});
require.register("forresto-noflo-seriously/components/FilterAscii.js", function(exports, require, module){
var Effect, FilterAscii, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.ascii.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterAscii = (function(_super) {
  __extends(FilterAscii, _super);

  function FilterAscii() {
    FilterAscii.__super__.constructor.call(this, "ascii", 1);
  }

  return FilterAscii;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterAscii;
};

});
require.register("forresto-noflo-seriously/components/FilterBleachBypass.js", function(exports, require, module){
var Effect, FilterBleachBypass, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.bleach-bypass.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterBleachBypass = (function(_super) {
  __extends(FilterBleachBypass, _super);

  function FilterBleachBypass() {
    FilterBleachBypass.__super__.constructor.call(this, "bleach-bypass", 1);
  }

  return FilterBleachBypass;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterBleachBypass;
};

});
require.register("forresto-noflo-seriously/components/FilterBlend.js", function(exports, require, module){
var Effect, FilterBlend, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.blend.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterBlend = (function(_super) {
  __extends(FilterBlend, _super);

  function FilterBlend() {
    FilterBlend.__super__.constructor.call(this, "blend", 2);
  }

  return FilterBlend;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterBlend;
};

});
require.register("forresto-noflo-seriously/components/FilterChannels.js", function(exports, require, module){
var Effect, FilterChannels, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.channels.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterChannels = (function(_super) {
  __extends(FilterChannels, _super);

  function FilterChannels() {
    FilterChannels.__super__.constructor.call(this, "channels", 1);
  }

  return FilterChannels;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterChannels;
};

});
require.register("forresto-noflo-seriously/components/FilterChroma.js", function(exports, require, module){
var Effect, FilterChroma, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.chroma.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterChroma = (function(_super) {
  __extends(FilterChroma, _super);

  function FilterChroma() {
    FilterChroma.__super__.constructor.call(this, "chroma", 1);
  }

  return FilterChroma;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterChroma;
};

});
require.register("forresto-noflo-seriously/components/FilterColor.js", function(exports, require, module){
var Effect, FilterColor, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.color.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterColor = (function(_super) {
  __extends(FilterColor, _super);

  function FilterColor() {
    FilterColor.__super__.constructor.call(this, "color", 1);
  }

  return FilterColor;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterColor;
};

});
require.register("forresto-noflo-seriously/components/FilterColorCube.js", function(exports, require, module){
var Effect, FilterColorCube, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.colorcube.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterColorCube = (function(_super) {
  __extends(FilterColorCube, _super);

  function FilterColorCube() {
    FilterColorCube.__super__.constructor.call(this, "colorcube", 1);
  }

  return FilterColorCube;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterColorCube;
};

});
require.register("forresto-noflo-seriously/components/FilterDaltonize.js", function(exports, require, module){
var Effect, FilterDaltonize, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.daltonize.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterDaltonize = (function(_super) {
  __extends(FilterDaltonize, _super);

  function FilterDaltonize() {
    FilterDaltonize.__super__.constructor.call(this, "daltonize", 1);
  }

  return FilterDaltonize;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterDaltonize;
};

});
require.register("forresto-noflo-seriously/components/FilterEdge.js", function(exports, require, module){
var Effect, FilterEdge, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.edge.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterEdge = (function(_super) {
  __extends(FilterEdge, _super);

  function FilterEdge() {
    FilterEdge.__super__.constructor.call(this, "edge", 1);
  }

  return FilterEdge;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterEdge;
};

});
require.register("forresto-noflo-seriously/components/FilterEmboss.js", function(exports, require, module){
var Effect, FilterEmboss, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.emboss.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterEmboss = (function(_super) {
  __extends(FilterEmboss, _super);

  function FilterEmboss() {
    FilterEmboss.__super__.constructor.call(this, "emboss", 1);
  }

  return FilterEmboss;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterEmboss;
};

});
require.register("forresto-noflo-seriously/components/FilterExposure.js", function(exports, require, module){
var Effect, FilterExposure, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.exposure.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterExposure = (function(_super) {
  __extends(FilterExposure, _super);

  function FilterExposure() {
    FilterExposure.__super__.constructor.call(this, "exposure", 1);
  }

  return FilterExposure;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterExposure;
};

});
require.register("forresto-noflo-seriously/components/FilterFader.js", function(exports, require, module){
var Effect, FilterFader, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.fader.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterFader = (function(_super) {
  __extends(FilterFader, _super);

  function FilterFader() {
    FilterFader.__super__.constructor.call(this, "fader", 1);
  }

  return FilterFader;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterFader;
};

});
require.register("forresto-noflo-seriously/components/FilterHex.js", function(exports, require, module){
var Effect, FilterHex, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.hex.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterHex = (function(_super) {
  __extends(FilterHex, _super);

  function FilterHex() {
    FilterHex.__super__.constructor.call(this, "hex", 1);
  }

  return FilterHex;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterHex;
};

});
require.register("forresto-noflo-seriously/components/FilterHueSaturation.js", function(exports, require, module){
var Effect, FilterHueSaturation, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.hue-saturation.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterHueSaturation = (function(_super) {
  __extends(FilterHueSaturation, _super);

  function FilterHueSaturation() {
    FilterHueSaturation.__super__.constructor.call(this, "hue-saturation", 1);
  }

  return FilterHueSaturation;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterHueSaturation;
};

});
require.register("forresto-noflo-seriously/components/FilterInvert.js", function(exports, require, module){
var Effect, FilterInvert, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.invert.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterInvert = (function(_super) {
  __extends(FilterInvert, _super);

  function FilterInvert() {
    FilterInvert.__super__.constructor.call(this, "invert", 1);
  }

  return FilterInvert;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterInvert;
};

});
require.register("forresto-noflo-seriously/components/FilterLumakey.js", function(exports, require, module){
var Effect, FilterLumakey, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.lumakey.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterLumakey = (function(_super) {
  __extends(FilterLumakey, _super);

  function FilterLumakey() {
    FilterLumakey.__super__.constructor.call(this, "lumakey", 1);
  }

  return FilterLumakey;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterLumakey;
};

});
require.register("forresto-noflo-seriously/components/FilterNightVision.js", function(exports, require, module){
var Effect, FilterNightVision, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.nightvision.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterNightVision = (function(_super) {
  __extends(FilterNightVision, _super);

  function FilterNightVision() {
    FilterNightVision.__super__.constructor.call(this, "nightvision", 1);
  }

  return FilterNightVision;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterNightVision;
};

});
require.register("forresto-noflo-seriously/components/FilterNoise.js", function(exports, require, module){
var Effect, FilterNoise, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.noise.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterNoise = (function(_super) {
  __extends(FilterNoise, _super);

  function FilterNoise() {
    FilterNoise.__super__.constructor.call(this, "noise", 1);
  }

  return FilterNoise;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterNoise;
};

});
require.register("forresto-noflo-seriously/components/FilterRipple.js", function(exports, require, module){
var Effect, FilterScanlines, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.scanlines.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterScanlines = (function(_super) {
  __extends(FilterScanlines, _super);

  function FilterScanlines() {
    FilterScanlines.__super__.constructor.call(this, "scanlines", 1);
  }

  return FilterScanlines;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterScanlines;
};

});
require.register("forresto-noflo-seriously/components/FilterScanLines.js", function(exports, require, module){
var Effect, FilterScanLines, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.scanlines.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterScanLines = (function(_super) {
  __extends(FilterScanLines, _super);

  function FilterScanLines() {
    FilterScanLines.__super__.constructor.call(this, "scanlines", 1);
  }

  return FilterScanLines;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterScanLines;
};

});
require.register("forresto-noflo-seriously/components/FilterSepia.js", function(exports, require, module){
var Effect, FilterSepia, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.sepia.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterSepia = (function(_super) {
  __extends(FilterSepia, _super);

  function FilterSepia() {
    FilterSepia.__super__.constructor.call(this, "sepia", 1);
  }

  return FilterSepia;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterSepia;
};

});
require.register("forresto-noflo-seriously/components/FilterSketch.js", function(exports, require, module){
var Effect, FilterSketch, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.sketch.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterSketch = (function(_super) {
  __extends(FilterSketch, _super);

  function FilterSketch() {
    FilterSketch.__super__.constructor.call(this, "sketch", 1);
  }

  return FilterSketch;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterSketch;
};

});
require.register("forresto-noflo-seriously/components/FilterSplit.js", function(exports, require, module){
var Effect, FilterSplit, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.split.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterSplit = (function(_super) {
  __extends(FilterSplit, _super);

  function FilterSplit() {
    FilterSplit.__super__.constructor.call(this, "split", 1);
  }

  return FilterSplit;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterSplit;
};

});
require.register("forresto-noflo-seriously/components/FilterTone.js", function(exports, require, module){
var Effect, FilterTone, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.tone.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterTone = (function(_super) {
  __extends(FilterTone, _super);

  function FilterTone() {
    FilterTone.__super__.constructor.call(this, "tone", 1);
  }

  return FilterTone;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterTone;
};

});
require.register("forresto-noflo-seriously/components/FilterTVGlitch.js", function(exports, require, module){
var Effect, FilterTVGlitch, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.tvglitch.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterTVGlitch = (function(_super) {
  __extends(FilterTVGlitch, _super);

  function FilterTVGlitch() {
    FilterTVGlitch.__super__.constructor.call(this, "tvglitch", 1);
  }

  return FilterTVGlitch;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterTVGlitch;
};

});
require.register("forresto-noflo-seriously/components/FilterVignette.js", function(exports, require, module){
var Effect, FilterVignette, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.vignette.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterVignette = (function(_super) {
  __extends(FilterVignette, _super);

  function FilterVignette() {
    FilterVignette.__super__.constructor.call(this, "vignette", 1);
  }

  return FilterVignette;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterVignette;
};

});
require.register("noflo-ui-preview/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-ui-preview","description":"NoFlo runtime environment for client-side previews","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-ui","keywords":[],"dependencies":{"noflo/noflo":"*","noflo/noflo-runtime-iframe":"*","noflo/noflo-ajax":"*","noflo/noflo-core":"*","noflo/noflo-css":"*","noflo/noflo-dom":"*","noflo/noflo-flow":"*","noflo/noflo-gestures":"*","noflo/noflo-groups":"*","noflo/noflo-interaction":"*","noflo/noflo-localstorage":"*","noflo/noflo-math":"*","noflo/noflo-objects":"*","noflo/noflo-packets":"*","noflo/noflo-physics":"*","noflo/noflo-routers":"*","noflo/noflo-strings":"*","noflo/noflo-websocket":"*","noflo/noflo-indexeddb":"*","noflo/noflo-github":"*","d4tocchini/noflo-draggabilly":"*","forresto/noflo-gum":"*","forresto/noflo-seriously":"*"},"json":["component.json"],"files":["iframe.html"]}');
});

























require.alias("noflo-noflo/component.json", "noflo-ui-preview/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-ui-preview/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-ui-preview/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-ui-preview/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-ui-preview/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-ui-preview/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-ui-preview/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-ui-preview/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-ui-preview/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-ui-preview/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-ui-preview/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-ui-preview/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-ui-preview/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-ui-preview/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-ui-preview/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-ui-preview/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-ui-preview/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-ui-preview/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-ui-preview/deps/noflo/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-runtime-iframe/index.js", "noflo-ui-preview/deps/noflo-runtime-iframe/index.js");
require.alias("noflo-noflo-runtime-iframe/component.json", "noflo-ui-preview/deps/noflo-runtime-iframe/component.json");
require.alias("noflo-noflo-runtime-iframe/index.js", "noflo-runtime-iframe/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-runtime-iframe/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-runtime-iframe/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-runtime-iframe/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-runtime-base/src/Base.js", "noflo-noflo-runtime-iframe/deps/noflo-runtime-base/src/Base.js");
require.alias("noflo-noflo-runtime-base/src/protocol/Graph.js", "noflo-noflo-runtime-iframe/deps/noflo-runtime-base/src/protocol/Graph.js");
require.alias("noflo-noflo-runtime-base/src/protocol/Network.js", "noflo-noflo-runtime-iframe/deps/noflo-runtime-base/src/protocol/Network.js");
require.alias("noflo-noflo-runtime-base/src/protocol/Component.js", "noflo-noflo-runtime-iframe/deps/noflo-runtime-base/src/protocol/Component.js");
require.alias("noflo-noflo-runtime-base/src/Base.js", "noflo-noflo-runtime-iframe/deps/noflo-runtime-base/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-runtime-base/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-runtime-base/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-runtime-base/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-runtime-base/src/Base.js", "noflo-noflo-runtime-base/index.js");
require.alias("noflo-noflo-core/index.js", "noflo-noflo-runtime-iframe/deps/noflo-core/index.js");
require.alias("noflo-noflo-core/component.json", "noflo-noflo-runtime-iframe/deps/noflo-core/component.json");
require.alias("noflo-noflo-core/components/Callback.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Callback.js");
require.alias("noflo-noflo-core/components/DisconnectAfterPacket.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/DisconnectAfterPacket.js");
require.alias("noflo-noflo-core/components/Drop.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Drop.js");
require.alias("noflo-noflo-core/components/Group.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Group.js");
require.alias("noflo-noflo-core/components/Kick.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Kick.js");
require.alias("noflo-noflo-core/components/Merge.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Merge.js");
require.alias("noflo-noflo-core/components/Output.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Output.js");
require.alias("noflo-noflo-core/components/Repeat.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Repeat.js");
require.alias("noflo-noflo-core/components/RepeatAsync.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/RepeatAsync.js");
require.alias("noflo-noflo-core/components/Split.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Split.js");
require.alias("noflo-noflo-core/components/RunInterval.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/RunInterval.js");
require.alias("noflo-noflo-core/components/RunTimeout.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/RunTimeout.js");
require.alias("noflo-noflo-core/components/MakeFunction.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/MakeFunction.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-core/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-core/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-core/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-core/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-core/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-core/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-core/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-core/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-core/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-core/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-core/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-core/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-core/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-core/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-core/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-core/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-core/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-core/deps/underscore/index.js");

require.alias("noflo-noflo-flow/index.js", "noflo-noflo-runtime-iframe/deps/noflo-flow/index.js");
require.alias("noflo-noflo-flow/component.json", "noflo-noflo-runtime-iframe/deps/noflo-flow/component.json");
require.alias("noflo-noflo-flow/components/Concat.js", "noflo-noflo-runtime-iframe/deps/noflo-flow/components/Concat.js");
require.alias("noflo-noflo-flow/components/Gate.js", "noflo-noflo-runtime-iframe/deps/noflo-flow/components/Gate.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-flow/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-flow/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-flow/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-flow/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-flow/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-flow/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-flow/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-flow/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-flow/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-flow/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-flow/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-flow/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-flow/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-flow/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-flow/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-ajax/index.js", "noflo-ui-preview/deps/noflo-ajax/index.js");
require.alias("noflo-noflo-ajax/component.json", "noflo-ui-preview/deps/noflo-ajax/component.json");
require.alias("noflo-noflo-ajax/components/Get.js", "noflo-ui-preview/deps/noflo-ajax/components/Get.js");
require.alias("noflo-noflo-ajax/components/GetJsonP.js", "noflo-ui-preview/deps/noflo-ajax/components/GetJsonP.js");
require.alias("noflo-noflo-ajax/index.js", "noflo-ajax/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-ajax/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-ajax/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-ajax/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-ajax/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-ajax/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-ajax/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-ajax/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-ajax/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-ajax/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-ajax/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-ajax/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-ajax/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-ajax/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-ajax/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-ajax/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-ajax/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-ajax/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-ajax/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-ajax/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-core/index.js", "noflo-ui-preview/deps/noflo-core/index.js");
require.alias("noflo-noflo-core/component.json", "noflo-ui-preview/deps/noflo-core/component.json");
require.alias("noflo-noflo-core/components/Callback.js", "noflo-ui-preview/deps/noflo-core/components/Callback.js");
require.alias("noflo-noflo-core/components/DisconnectAfterPacket.js", "noflo-ui-preview/deps/noflo-core/components/DisconnectAfterPacket.js");
require.alias("noflo-noflo-core/components/Drop.js", "noflo-ui-preview/deps/noflo-core/components/Drop.js");
require.alias("noflo-noflo-core/components/Group.js", "noflo-ui-preview/deps/noflo-core/components/Group.js");
require.alias("noflo-noflo-core/components/Kick.js", "noflo-ui-preview/deps/noflo-core/components/Kick.js");
require.alias("noflo-noflo-core/components/Merge.js", "noflo-ui-preview/deps/noflo-core/components/Merge.js");
require.alias("noflo-noflo-core/components/Output.js", "noflo-ui-preview/deps/noflo-core/components/Output.js");
require.alias("noflo-noflo-core/components/Repeat.js", "noflo-ui-preview/deps/noflo-core/components/Repeat.js");
require.alias("noflo-noflo-core/components/RepeatAsync.js", "noflo-ui-preview/deps/noflo-core/components/RepeatAsync.js");
require.alias("noflo-noflo-core/components/Split.js", "noflo-ui-preview/deps/noflo-core/components/Split.js");
require.alias("noflo-noflo-core/components/RunInterval.js", "noflo-ui-preview/deps/noflo-core/components/RunInterval.js");
require.alias("noflo-noflo-core/components/RunTimeout.js", "noflo-ui-preview/deps/noflo-core/components/RunTimeout.js");
require.alias("noflo-noflo-core/components/MakeFunction.js", "noflo-ui-preview/deps/noflo-core/components/MakeFunction.js");
require.alias("noflo-noflo-core/index.js", "noflo-core/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-core/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-core/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-core/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-core/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-core/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-core/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-core/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-core/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-core/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-core/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-core/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-core/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-core/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-core/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-core/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-core/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-core/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-core/deps/underscore/index.js");

require.alias("noflo-noflo-css/index.js", "noflo-ui-preview/deps/noflo-css/index.js");
require.alias("noflo-noflo-css/component.json", "noflo-ui-preview/deps/noflo-css/component.json");
require.alias("noflo-noflo-css/components/MoveElement.js", "noflo-ui-preview/deps/noflo-css/components/MoveElement.js");
require.alias("noflo-noflo-css/components/RotateElement.js", "noflo-ui-preview/deps/noflo-css/components/RotateElement.js");
require.alias("noflo-noflo-css/components/SetElementTop.js", "noflo-ui-preview/deps/noflo-css/components/SetElementTop.js");
require.alias("noflo-noflo-css/index.js", "noflo-css/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-css/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-css/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-css/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-css/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-css/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-css/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-css/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-css/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-css/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-css/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-css/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-css/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-css/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-css/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-css/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-css/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-css/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-css/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-css/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-dom/index.js", "noflo-ui-preview/deps/noflo-dom/index.js");
require.alias("noflo-noflo-dom/component.json", "noflo-ui-preview/deps/noflo-dom/component.json");
require.alias("noflo-noflo-dom/components/AddClass.js", "noflo-ui-preview/deps/noflo-dom/components/AddClass.js");
require.alias("noflo-noflo-dom/components/AppendChild.js", "noflo-ui-preview/deps/noflo-dom/components/AppendChild.js");
require.alias("noflo-noflo-dom/components/CreateElement.js", "noflo-ui-preview/deps/noflo-dom/components/CreateElement.js");
require.alias("noflo-noflo-dom/components/CreateFragment.js", "noflo-ui-preview/deps/noflo-dom/components/CreateFragment.js");
require.alias("noflo-noflo-dom/components/GetAttribute.js", "noflo-ui-preview/deps/noflo-dom/components/GetAttribute.js");
require.alias("noflo-noflo-dom/components/GetElement.js", "noflo-ui-preview/deps/noflo-dom/components/GetElement.js");
require.alias("noflo-noflo-dom/components/HasClass.js", "noflo-ui-preview/deps/noflo-dom/components/HasClass.js");
require.alias("noflo-noflo-dom/components/ReadHtml.js", "noflo-ui-preview/deps/noflo-dom/components/ReadHtml.js");
require.alias("noflo-noflo-dom/components/RemoveElement.js", "noflo-ui-preview/deps/noflo-dom/components/RemoveElement.js");
require.alias("noflo-noflo-dom/components/SetAttribute.js", "noflo-ui-preview/deps/noflo-dom/components/SetAttribute.js");
require.alias("noflo-noflo-dom/components/WriteHtml.js", "noflo-ui-preview/deps/noflo-dom/components/WriteHtml.js");
require.alias("noflo-noflo-dom/components/RemoveClass.js", "noflo-ui-preview/deps/noflo-dom/components/RemoveClass.js");
require.alias("noflo-noflo-dom/components/RequestAnimationFrame.js", "noflo-ui-preview/deps/noflo-dom/components/RequestAnimationFrame.js");
require.alias("noflo-noflo-dom/index.js", "noflo-dom/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-dom/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-dom/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-dom/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-dom/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-dom/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-dom/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-dom/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-dom/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-dom/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-dom/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-dom/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-dom/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-dom/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-dom/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-dom/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-dom/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-dom/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-dom/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-dom/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-flow/index.js", "noflo-ui-preview/deps/noflo-flow/index.js");
require.alias("noflo-noflo-flow/component.json", "noflo-ui-preview/deps/noflo-flow/component.json");
require.alias("noflo-noflo-flow/components/Concat.js", "noflo-ui-preview/deps/noflo-flow/components/Concat.js");
require.alias("noflo-noflo-flow/components/Gate.js", "noflo-ui-preview/deps/noflo-flow/components/Gate.js");
require.alias("noflo-noflo-flow/index.js", "noflo-flow/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-flow/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-flow/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-flow/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-flow/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-flow/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-flow/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-flow/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-flow/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-flow/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-flow/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-flow/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-flow/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-flow/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-flow/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-flow/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-gestures/graphs/DetectDrag.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectDrag.json");
require.alias("noflo-noflo-gestures/graphs/DetectSwipe.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectSwipe.json");
require.alias("noflo-noflo-gestures/graphs/DetectPinch.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectPinch.json");
require.alias("noflo-noflo-gestures/graphs/FilterByTarget.json", "noflo-ui-preview/deps/noflo-gestures/graphs/FilterByTarget.json");
require.alias("noflo-noflo-gestures/graphs/GestureToObject.json", "noflo-ui-preview/deps/noflo-gestures/graphs/GestureToObject.json");
require.alias("noflo-noflo-gestures/graphs/ListenGestures.json", "noflo-ui-preview/deps/noflo-gestures/graphs/ListenGestures.json");
require.alias("noflo-noflo-gestures/graphs/ListenPointer.json", "noflo-ui-preview/deps/noflo-gestures/graphs/ListenPointer.json");
require.alias("noflo-noflo-gestures/graphs/DetectCardinalDirection.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectCardinalDirection.json");
require.alias("noflo-noflo-gestures/index.js", "noflo-ui-preview/deps/noflo-gestures/index.js");
require.alias("noflo-noflo-gestures/graphs/DetectDrag.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectDrag.json");
require.alias("noflo-noflo-gestures/graphs/DetectSwipe.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectSwipe.json");
require.alias("noflo-noflo-gestures/graphs/DetectPinch.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectPinch.json");
require.alias("noflo-noflo-gestures/graphs/FilterByTarget.json", "noflo-ui-preview/deps/noflo-gestures/graphs/FilterByTarget.json");
require.alias("noflo-noflo-gestures/graphs/GestureToObject.json", "noflo-ui-preview/deps/noflo-gestures/graphs/GestureToObject.json");
require.alias("noflo-noflo-gestures/graphs/ListenGestures.json", "noflo-ui-preview/deps/noflo-gestures/graphs/ListenGestures.json");
require.alias("noflo-noflo-gestures/graphs/ListenPointer.json", "noflo-ui-preview/deps/noflo-gestures/graphs/ListenPointer.json");
require.alias("noflo-noflo-gestures/graphs/DetectCardinalDirection.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectCardinalDirection.json");
require.alias("noflo-noflo-gestures/component.json", "noflo-ui-preview/deps/noflo-gestures/component.json");
require.alias("noflo-noflo-gestures/components/CalculateCenter.js", "noflo-ui-preview/deps/noflo-gestures/components/CalculateCenter.js");
require.alias("noflo-noflo-gestures/components/CalculateScale.js", "noflo-ui-preview/deps/noflo-gestures/components/CalculateScale.js");
require.alias("noflo-noflo-gestures/components/CardinalRouter.js", "noflo-ui-preview/deps/noflo-gestures/components/CardinalRouter.js");
require.alias("noflo-noflo-gestures/components/DegreesToCardinal.js", "noflo-ui-preview/deps/noflo-gestures/components/DegreesToCardinal.js");
require.alias("noflo-noflo-gestures/components/DegreesToCompass.js", "noflo-ui-preview/deps/noflo-gestures/components/DegreesToCompass.js");
require.alias("noflo-noflo-gestures/components/DetectScratch.js", "noflo-ui-preview/deps/noflo-gestures/components/DetectScratch.js");
require.alias("noflo-noflo-gestures/components/DetectTarget.js", "noflo-ui-preview/deps/noflo-gestures/components/DetectTarget.js");
require.alias("noflo-noflo-gestures/index.js", "noflo-gestures/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-gestures/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-gestures/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-gestures/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-gestures/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-gestures/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-gestures/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-gestures/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-gestures/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-gestures/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-gestures/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-gestures/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-gestures/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-gestures/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-gestures/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-gestures/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-gestures/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-gestures/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-gestures/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-gestures/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-interaction/index.js", "noflo-noflo-gestures/deps/noflo-interaction/index.js");
require.alias("noflo-noflo-interaction/component.json", "noflo-noflo-gestures/deps/noflo-interaction/component.json");
require.alias("noflo-noflo-interaction/components/ListenChange.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenChange.js");
require.alias("noflo-noflo-interaction/components/ListenDrag.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenDrag.js");
require.alias("noflo-noflo-interaction/components/ListenHash.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenHash.js");
require.alias("noflo-noflo-interaction/components/ListenKeyboard.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenKeyboard.js");
require.alias("noflo-noflo-interaction/components/ListenMouse.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenMouse.js");
require.alias("noflo-noflo-interaction/components/ListenPointer.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenPointer.js");
require.alias("noflo-noflo-interaction/components/ListenResize.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenResize.js");
require.alias("noflo-noflo-interaction/components/ListenScroll.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenScroll.js");
require.alias("noflo-noflo-interaction/components/ListenSpeech.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenSpeech.js");
require.alias("noflo-noflo-interaction/components/ListenTouch.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenTouch.js");
require.alias("noflo-noflo-interaction/components/SetHash.js", "noflo-noflo-gestures/deps/noflo-interaction/components/SetHash.js");
require.alias("noflo-noflo-interaction/components/ReadCoordinates.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ReadCoordinates.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-interaction/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-interaction/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-interaction/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-interaction/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-interaction/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-interaction/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-interaction/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-interaction/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-interaction/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-interaction/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-interaction/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-interaction/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-interaction/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-interaction/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-interaction/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-interaction/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-math/index.js", "noflo-noflo-gestures/deps/noflo-math/index.js");
require.alias("noflo-noflo-math/component.json", "noflo-noflo-gestures/deps/noflo-math/component.json");
require.alias("noflo-noflo-math/components/Add.js", "noflo-noflo-gestures/deps/noflo-math/components/Add.js");
require.alias("noflo-noflo-math/components/Subtract.js", "noflo-noflo-gestures/deps/noflo-math/components/Subtract.js");
require.alias("noflo-noflo-math/components/Multiply.js", "noflo-noflo-gestures/deps/noflo-math/components/Multiply.js");
require.alias("noflo-noflo-math/components/Divide.js", "noflo-noflo-gestures/deps/noflo-math/components/Divide.js");
require.alias("noflo-noflo-math/components/Floor.js", "noflo-noflo-gestures/deps/noflo-math/components/Floor.js");
require.alias("noflo-noflo-math/components/CalculateAngle.js", "noflo-noflo-gestures/deps/noflo-math/components/CalculateAngle.js");
require.alias("noflo-noflo-math/components/CalculateDistance.js", "noflo-noflo-gestures/deps/noflo-math/components/CalculateDistance.js");
require.alias("noflo-noflo-math/components/Compare.js", "noflo-noflo-gestures/deps/noflo-math/components/Compare.js");
require.alias("noflo-noflo-math/components/CountSum.js", "noflo-noflo-gestures/deps/noflo-math/components/CountSum.js");
require.alias("noflo-noflo-math/lib/MathComponent.js", "noflo-noflo-gestures/deps/noflo-math/lib/MathComponent.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-math/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-math/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-math/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-math/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-math/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-math/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-math/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-math/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-math/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-math/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-math/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-math/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-math/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-math/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-math/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-math/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-math/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-math/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-math/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-flow/index.js", "noflo-noflo-gestures/deps/noflo-flow/index.js");
require.alias("noflo-noflo-flow/component.json", "noflo-noflo-gestures/deps/noflo-flow/component.json");
require.alias("noflo-noflo-flow/components/Concat.js", "noflo-noflo-gestures/deps/noflo-flow/components/Concat.js");
require.alias("noflo-noflo-flow/components/Gate.js", "noflo-noflo-gestures/deps/noflo-flow/components/Gate.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-flow/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-flow/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-flow/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-flow/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-flow/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-flow/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-flow/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-flow/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-flow/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-flow/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-flow/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-flow/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-flow/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-flow/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-flow/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-groups/index.js", "noflo-noflo-gestures/deps/noflo-groups/index.js");
require.alias("noflo-noflo-groups/component.json", "noflo-noflo-gestures/deps/noflo-groups/component.json");
require.alias("noflo-noflo-groups/components/ReadGroups.js", "noflo-noflo-gestures/deps/noflo-groups/components/ReadGroups.js");
require.alias("noflo-noflo-groups/components/RemoveGroups.js", "noflo-noflo-gestures/deps/noflo-groups/components/RemoveGroups.js");
require.alias("noflo-noflo-groups/components/Regroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/Regroup.js");
require.alias("noflo-noflo-groups/components/Group.js", "noflo-noflo-gestures/deps/noflo-groups/components/Group.js");
require.alias("noflo-noflo-groups/components/GroupZip.js", "noflo-noflo-gestures/deps/noflo-groups/components/GroupZip.js");
require.alias("noflo-noflo-groups/components/FilterByGroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/FilterByGroup.js");
require.alias("noflo-noflo-groups/components/Objectify.js", "noflo-noflo-gestures/deps/noflo-groups/components/Objectify.js");
require.alias("noflo-noflo-groups/components/ReadGroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/ReadGroup.js");
require.alias("noflo-noflo-groups/components/SendByGroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/SendByGroup.js");
require.alias("noflo-noflo-groups/components/CollectGroups.js", "noflo-noflo-gestures/deps/noflo-groups/components/CollectGroups.js");
require.alias("noflo-noflo-groups/components/CollectObject.js", "noflo-noflo-gestures/deps/noflo-groups/components/CollectObject.js");
require.alias("noflo-noflo-groups/components/FirstGroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/FirstGroup.js");
require.alias("noflo-noflo-groups/components/MapGroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/MapGroup.js");
require.alias("noflo-noflo-groups/components/MergeGroups.js", "noflo-noflo-gestures/deps/noflo-groups/components/MergeGroups.js");
require.alias("noflo-noflo-groups/components/GroupByObjectKey.js", "noflo-noflo-gestures/deps/noflo-groups/components/GroupByObjectKey.js");
require.alias("component-underscore/index.js", "noflo-noflo-groups/deps/underscore/index.js");

require.alias("noflo-noflo/component.json", "noflo-noflo-groups/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-groups/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-groups/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-groups/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-groups/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-groups/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-groups/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-groups/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-groups/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-groups/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-groups/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-groups/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-groups/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-groups/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-groups/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-groups/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-groups/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-groups/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-groups/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-packets/index.js", "noflo-noflo-gestures/deps/noflo-packets/index.js");
require.alias("noflo-noflo-packets/component.json", "noflo-noflo-gestures/deps/noflo-packets/component.json");
require.alias("noflo-noflo-packets/components/CountPackets.js", "noflo-noflo-gestures/deps/noflo-packets/components/CountPackets.js");
require.alias("noflo-noflo-packets/components/Unzip.js", "noflo-noflo-gestures/deps/noflo-packets/components/Unzip.js");
require.alias("noflo-noflo-packets/components/Defaults.js", "noflo-noflo-gestures/deps/noflo-packets/components/Defaults.js");
require.alias("noflo-noflo-packets/components/DoNotDisconnect.js", "noflo-noflo-gestures/deps/noflo-packets/components/DoNotDisconnect.js");
require.alias("noflo-noflo-packets/components/OnlyDisconnect.js", "noflo-noflo-gestures/deps/noflo-packets/components/OnlyDisconnect.js");
require.alias("noflo-noflo-packets/components/SplitPacket.js", "noflo-noflo-gestures/deps/noflo-packets/components/SplitPacket.js");
require.alias("noflo-noflo-packets/components/Range.js", "noflo-noflo-gestures/deps/noflo-packets/components/Range.js");
require.alias("noflo-noflo-packets/components/Flatten.js", "noflo-noflo-gestures/deps/noflo-packets/components/Flatten.js");
require.alias("noflo-noflo-packets/components/Compact.js", "noflo-noflo-gestures/deps/noflo-packets/components/Compact.js");
require.alias("noflo-noflo-packets/components/Zip.js", "noflo-noflo-gestures/deps/noflo-packets/components/Zip.js");
require.alias("noflo-noflo-packets/components/SendWith.js", "noflo-noflo-gestures/deps/noflo-packets/components/SendWith.js");
require.alias("noflo-noflo-packets/components/FilterPackets.js", "noflo-noflo-gestures/deps/noflo-packets/components/FilterPackets.js");
require.alias("noflo-noflo-packets/components/FilterByValue.js", "noflo-noflo-gestures/deps/noflo-packets/components/FilterByValue.js");
require.alias("noflo-noflo-packets/components/FilterByPosition.js", "noflo-noflo-gestures/deps/noflo-packets/components/FilterByPosition.js");
require.alias("noflo-noflo-packets/components/FilterPacket.js", "noflo-noflo-gestures/deps/noflo-packets/components/FilterPacket.js");
require.alias("noflo-noflo-packets/components/UniquePacket.js", "noflo-noflo-gestures/deps/noflo-packets/components/UniquePacket.js");
require.alias("noflo-noflo-packets/components/GroupByPacket.js", "noflo-noflo-gestures/deps/noflo-packets/components/GroupByPacket.js");
require.alias("noflo-noflo-packets/components/LastPacket.js", "noflo-noflo-gestures/deps/noflo-packets/components/LastPacket.js");
require.alias("noflo-noflo-packets/components/Counter.js", "noflo-noflo-gestures/deps/noflo-packets/components/Counter.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-packets/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-packets/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-packets/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-packets/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-packets/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-packets/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-packets/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-packets/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-packets/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-packets/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-packets/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-packets/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-packets/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-packets/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-packets/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-packets/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-packets/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-packets/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-packets/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-packets/deps/underscore/index.js");

require.alias("noflo-noflo-objects/index.js", "noflo-noflo-gestures/deps/noflo-objects/index.js");
require.alias("noflo-noflo-objects/component.json", "noflo-noflo-gestures/deps/noflo-objects/component.json");
require.alias("noflo-noflo-objects/components/Extend.js", "noflo-noflo-gestures/deps/noflo-objects/components/Extend.js");
require.alias("noflo-noflo-objects/components/MergeObjects.js", "noflo-noflo-gestures/deps/noflo-objects/components/MergeObjects.js");
require.alias("noflo-noflo-objects/components/SplitObject.js", "noflo-noflo-gestures/deps/noflo-objects/components/SplitObject.js");
require.alias("noflo-noflo-objects/components/ReplaceKey.js", "noflo-noflo-gestures/deps/noflo-objects/components/ReplaceKey.js");
require.alias("noflo-noflo-objects/components/Keys.js", "noflo-noflo-gestures/deps/noflo-objects/components/Keys.js");
require.alias("noflo-noflo-objects/components/Size.js", "noflo-noflo-gestures/deps/noflo-objects/components/Size.js");
require.alias("noflo-noflo-objects/components/Values.js", "noflo-noflo-gestures/deps/noflo-objects/components/Values.js");
require.alias("noflo-noflo-objects/components/Join.js", "noflo-noflo-gestures/deps/noflo-objects/components/Join.js");
require.alias("noflo-noflo-objects/components/ExtractProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/ExtractProperty.js");
require.alias("noflo-noflo-objects/components/InsertProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/InsertProperty.js");
require.alias("noflo-noflo-objects/components/SliceArray.js", "noflo-noflo-gestures/deps/noflo-objects/components/SliceArray.js");
require.alias("noflo-noflo-objects/components/SplitArray.js", "noflo-noflo-gestures/deps/noflo-objects/components/SplitArray.js");
require.alias("noflo-noflo-objects/components/FilterPropertyValue.js", "noflo-noflo-gestures/deps/noflo-objects/components/FilterPropertyValue.js");
require.alias("noflo-noflo-objects/components/FlattenObject.js", "noflo-noflo-gestures/deps/noflo-objects/components/FlattenObject.js");
require.alias("noflo-noflo-objects/components/MapProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/MapProperty.js");
require.alias("noflo-noflo-objects/components/RemoveProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/RemoveProperty.js");
require.alias("noflo-noflo-objects/components/MapPropertyValue.js", "noflo-noflo-gestures/deps/noflo-objects/components/MapPropertyValue.js");
require.alias("noflo-noflo-objects/components/GetObjectKey.js", "noflo-noflo-gestures/deps/noflo-objects/components/GetObjectKey.js");
require.alias("noflo-noflo-objects/components/UniqueArray.js", "noflo-noflo-gestures/deps/noflo-objects/components/UniqueArray.js");
require.alias("noflo-noflo-objects/components/SetProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/SetProperty.js");
require.alias("noflo-noflo-objects/components/SimplifyObject.js", "noflo-noflo-gestures/deps/noflo-objects/components/SimplifyObject.js");
require.alias("noflo-noflo-objects/components/DuplicateProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/DuplicateProperty.js");
require.alias("noflo-noflo-objects/components/CreateObject.js", "noflo-noflo-gestures/deps/noflo-objects/components/CreateObject.js");
require.alias("noflo-noflo-objects/components/CreateDate.js", "noflo-noflo-gestures/deps/noflo-objects/components/CreateDate.js");
require.alias("noflo-noflo-objects/components/SetPropertyValue.js", "noflo-noflo-gestures/deps/noflo-objects/components/SetPropertyValue.js");
require.alias("noflo-noflo-objects/components/CallMethod.js", "noflo-noflo-gestures/deps/noflo-objects/components/CallMethod.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-objects/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-objects/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-objects/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-objects/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-objects/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-objects/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-objects/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-objects/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-objects/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-objects/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-objects/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-objects/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-objects/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-objects/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-objects/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-objects/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-objects/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-objects/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-objects/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-objects/deps/underscore/index.js");

require.alias("noflo-noflo-dom/index.js", "noflo-noflo-gestures/deps/noflo-dom/index.js");
require.alias("noflo-noflo-dom/component.json", "noflo-noflo-gestures/deps/noflo-dom/component.json");
require.alias("noflo-noflo-dom/components/AddClass.js", "noflo-noflo-gestures/deps/noflo-dom/components/AddClass.js");
require.alias("noflo-noflo-dom/components/AppendChild.js", "noflo-noflo-gestures/deps/noflo-dom/components/AppendChild.js");
require.alias("noflo-noflo-dom/components/CreateElement.js", "noflo-noflo-gestures/deps/noflo-dom/components/CreateElement.js");
require.alias("noflo-noflo-dom/components/CreateFragment.js", "noflo-noflo-gestures/deps/noflo-dom/components/CreateFragment.js");
require.alias("noflo-noflo-dom/components/GetAttribute.js", "noflo-noflo-gestures/deps/noflo-dom/components/GetAttribute.js");
require.alias("noflo-noflo-dom/components/GetElement.js", "noflo-noflo-gestures/deps/noflo-dom/components/GetElement.js");
require.alias("noflo-noflo-dom/components/HasClass.js", "noflo-noflo-gestures/deps/noflo-dom/components/HasClass.js");
require.alias("noflo-noflo-dom/components/ReadHtml.js", "noflo-noflo-gestures/deps/noflo-dom/components/ReadHtml.js");
require.alias("noflo-noflo-dom/components/RemoveElement.js", "noflo-noflo-gestures/deps/noflo-dom/components/RemoveElement.js");
require.alias("noflo-noflo-dom/components/SetAttribute.js", "noflo-noflo-gestures/deps/noflo-dom/components/SetAttribute.js");
require.alias("noflo-noflo-dom/components/WriteHtml.js", "noflo-noflo-gestures/deps/noflo-dom/components/WriteHtml.js");
require.alias("noflo-noflo-dom/components/RemoveClass.js", "noflo-noflo-gestures/deps/noflo-dom/components/RemoveClass.js");
require.alias("noflo-noflo-dom/components/RequestAnimationFrame.js", "noflo-noflo-gestures/deps/noflo-dom/components/RequestAnimationFrame.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-dom/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-dom/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-dom/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-dom/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-dom/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-dom/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-dom/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-dom/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-dom/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-dom/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-dom/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-dom/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-dom/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-dom/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-dom/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-dom/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-dom/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-dom/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-dom/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-strings/index.js", "noflo-noflo-gestures/deps/noflo-strings/index.js");
require.alias("noflo-noflo-strings/component.json", "noflo-noflo-gestures/deps/noflo-strings/component.json");
require.alias("noflo-noflo-strings/components/CompileString.js", "noflo-noflo-gestures/deps/noflo-strings/components/CompileString.js");
require.alias("noflo-noflo-strings/components/Filter.js", "noflo-noflo-gestures/deps/noflo-strings/components/Filter.js");
require.alias("noflo-noflo-strings/components/SendString.js", "noflo-noflo-gestures/deps/noflo-strings/components/SendString.js");
require.alias("noflo-noflo-strings/components/SplitStr.js", "noflo-noflo-gestures/deps/noflo-strings/components/SplitStr.js");
require.alias("noflo-noflo-strings/components/StringTemplate.js", "noflo-noflo-gestures/deps/noflo-strings/components/StringTemplate.js");
require.alias("noflo-noflo-strings/components/Replace.js", "noflo-noflo-gestures/deps/noflo-strings/components/Replace.js");
require.alias("noflo-noflo-strings/components/Jsonify.js", "noflo-noflo-gestures/deps/noflo-strings/components/Jsonify.js");
require.alias("noflo-noflo-strings/components/ParseJson.js", "noflo-noflo-gestures/deps/noflo-strings/components/ParseJson.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-strings/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-strings/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-strings/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-strings/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-strings/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-strings/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-strings/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-strings/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-strings/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-strings/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-strings/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-strings/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-strings/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-strings/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-strings/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-strings/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-strings/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-strings/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-strings/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-strings/deps/underscore/index.js");

require.alias("noflo-noflo-core/index.js", "noflo-noflo-gestures/deps/noflo-core/index.js");
require.alias("noflo-noflo-core/component.json", "noflo-noflo-gestures/deps/noflo-core/component.json");
require.alias("noflo-noflo-core/components/Callback.js", "noflo-noflo-gestures/deps/noflo-core/components/Callback.js");
require.alias("noflo-noflo-core/components/DisconnectAfterPacket.js", "noflo-noflo-gestures/deps/noflo-core/components/DisconnectAfterPacket.js");
require.alias("noflo-noflo-core/components/Drop.js", "noflo-noflo-gestures/deps/noflo-core/components/Drop.js");
require.alias("noflo-noflo-core/components/Group.js", "noflo-noflo-gestures/deps/noflo-core/components/Group.js");
require.alias("noflo-noflo-core/components/Kick.js", "noflo-noflo-gestures/deps/noflo-core/components/Kick.js");
require.alias("noflo-noflo-core/components/Merge.js", "noflo-noflo-gestures/deps/noflo-core/components/Merge.js");
require.alias("noflo-noflo-core/components/Output.js", "noflo-noflo-gestures/deps/noflo-core/components/Output.js");
require.alias("noflo-noflo-core/components/Repeat.js", "noflo-noflo-gestures/deps/noflo-core/components/Repeat.js");
require.alias("noflo-noflo-core/components/RepeatAsync.js", "noflo-noflo-gestures/deps/noflo-core/components/RepeatAsync.js");
require.alias("noflo-noflo-core/components/Split.js", "noflo-noflo-gestures/deps/noflo-core/components/Split.js");
require.alias("noflo-noflo-core/components/RunInterval.js", "noflo-noflo-gestures/deps/noflo-core/components/RunInterval.js");
require.alias("noflo-noflo-core/components/RunTimeout.js", "noflo-noflo-gestures/deps/noflo-core/components/RunTimeout.js");
require.alias("noflo-noflo-core/components/MakeFunction.js", "noflo-noflo-gestures/deps/noflo-core/components/MakeFunction.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-core/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-core/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-core/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-core/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-core/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-core/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-core/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-core/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-core/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-core/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-core/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-core/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-core/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-core/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-core/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-core/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-core/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-core/deps/underscore/index.js");

require.alias("noflo-noflo-groups/index.js", "noflo-ui-preview/deps/noflo-groups/index.js");
require.alias("noflo-noflo-groups/component.json", "noflo-ui-preview/deps/noflo-groups/component.json");
require.alias("noflo-noflo-groups/components/ReadGroups.js", "noflo-ui-preview/deps/noflo-groups/components/ReadGroups.js");
require.alias("noflo-noflo-groups/components/RemoveGroups.js", "noflo-ui-preview/deps/noflo-groups/components/RemoveGroups.js");
require.alias("noflo-noflo-groups/components/Regroup.js", "noflo-ui-preview/deps/noflo-groups/components/Regroup.js");
require.alias("noflo-noflo-groups/components/Group.js", "noflo-ui-preview/deps/noflo-groups/components/Group.js");
require.alias("noflo-noflo-groups/components/GroupZip.js", "noflo-ui-preview/deps/noflo-groups/components/GroupZip.js");
require.alias("noflo-noflo-groups/components/FilterByGroup.js", "noflo-ui-preview/deps/noflo-groups/components/FilterByGroup.js");
require.alias("noflo-noflo-groups/components/Objectify.js", "noflo-ui-preview/deps/noflo-groups/components/Objectify.js");
require.alias("noflo-noflo-groups/components/ReadGroup.js", "noflo-ui-preview/deps/noflo-groups/components/ReadGroup.js");
require.alias("noflo-noflo-groups/components/SendByGroup.js", "noflo-ui-preview/deps/noflo-groups/components/SendByGroup.js");
require.alias("noflo-noflo-groups/components/CollectGroups.js", "noflo-ui-preview/deps/noflo-groups/components/CollectGroups.js");
require.alias("noflo-noflo-groups/components/CollectObject.js", "noflo-ui-preview/deps/noflo-groups/components/CollectObject.js");
require.alias("noflo-noflo-groups/components/FirstGroup.js", "noflo-ui-preview/deps/noflo-groups/components/FirstGroup.js");
require.alias("noflo-noflo-groups/components/MapGroup.js", "noflo-ui-preview/deps/noflo-groups/components/MapGroup.js");
require.alias("noflo-noflo-groups/components/MergeGroups.js", "noflo-ui-preview/deps/noflo-groups/components/MergeGroups.js");
require.alias("noflo-noflo-groups/components/GroupByObjectKey.js", "noflo-ui-preview/deps/noflo-groups/components/GroupByObjectKey.js");
require.alias("noflo-noflo-groups/index.js", "noflo-groups/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-groups/deps/underscore/index.js");

require.alias("noflo-noflo/component.json", "noflo-noflo-groups/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-groups/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-groups/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-groups/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-groups/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-groups/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-groups/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-groups/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-groups/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-groups/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-groups/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-groups/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-groups/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-groups/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-groups/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-groups/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-groups/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-groups/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-groups/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-interaction/index.js", "noflo-ui-preview/deps/noflo-interaction/index.js");
require.alias("noflo-noflo-interaction/component.json", "noflo-ui-preview/deps/noflo-interaction/component.json");
require.alias("noflo-noflo-interaction/components/ListenChange.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenChange.js");
require.alias("noflo-noflo-interaction/components/ListenDrag.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenDrag.js");
require.alias("noflo-noflo-interaction/components/ListenHash.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenHash.js");
require.alias("noflo-noflo-interaction/components/ListenKeyboard.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenKeyboard.js");
require.alias("noflo-noflo-interaction/components/ListenMouse.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenMouse.js");
require.alias("noflo-noflo-interaction/components/ListenPointer.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenPointer.js");
require.alias("noflo-noflo-interaction/components/ListenResize.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenResize.js");
require.alias("noflo-noflo-interaction/components/ListenScroll.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenScroll.js");
require.alias("noflo-noflo-interaction/components/ListenSpeech.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenSpeech.js");
require.alias("noflo-noflo-interaction/components/ListenTouch.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenTouch.js");
require.alias("noflo-noflo-interaction/components/SetHash.js", "noflo-ui-preview/deps/noflo-interaction/components/SetHash.js");
require.alias("noflo-noflo-interaction/components/ReadCoordinates.js", "noflo-ui-preview/deps/noflo-interaction/components/ReadCoordinates.js");
require.alias("noflo-noflo-interaction/index.js", "noflo-interaction/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-interaction/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-interaction/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-interaction/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-interaction/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-interaction/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-interaction/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-interaction/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-interaction/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-interaction/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-interaction/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-interaction/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-interaction/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-interaction/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-interaction/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-interaction/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-interaction/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-localstorage/index.js", "noflo-ui-preview/deps/noflo-localstorage/index.js");
require.alias("noflo-noflo-localstorage/component.json", "noflo-ui-preview/deps/noflo-localstorage/component.json");
require.alias("noflo-noflo-localstorage/components/GetItem.js", "noflo-ui-preview/deps/noflo-localstorage/components/GetItem.js");
require.alias("noflo-noflo-localstorage/components/ListenRemoteChanges.js", "noflo-ui-preview/deps/noflo-localstorage/components/ListenRemoteChanges.js");
require.alias("noflo-noflo-localstorage/components/ListAdd.js", "noflo-ui-preview/deps/noflo-localstorage/components/ListAdd.js");
require.alias("noflo-noflo-localstorage/components/ListGet.js", "noflo-ui-preview/deps/noflo-localstorage/components/ListGet.js");
require.alias("noflo-noflo-localstorage/components/ListRemove.js", "noflo-ui-preview/deps/noflo-localstorage/components/ListRemove.js");
require.alias("noflo-noflo-localstorage/components/RemoveItem.js", "noflo-ui-preview/deps/noflo-localstorage/components/RemoveItem.js");
require.alias("noflo-noflo-localstorage/components/SetItem.js", "noflo-ui-preview/deps/noflo-localstorage/components/SetItem.js");
require.alias("noflo-noflo-localstorage/index.js", "noflo-localstorage/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-localstorage/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-localstorage/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-localstorage/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-localstorage/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-localstorage/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-localstorage/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-localstorage/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-localstorage/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-localstorage/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-localstorage/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-localstorage/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-localstorage/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-math/index.js", "noflo-ui-preview/deps/noflo-math/index.js");
require.alias("noflo-noflo-math/component.json", "noflo-ui-preview/deps/noflo-math/component.json");
require.alias("noflo-noflo-math/components/Add.js", "noflo-ui-preview/deps/noflo-math/components/Add.js");
require.alias("noflo-noflo-math/components/Subtract.js", "noflo-ui-preview/deps/noflo-math/components/Subtract.js");
require.alias("noflo-noflo-math/components/Multiply.js", "noflo-ui-preview/deps/noflo-math/components/Multiply.js");
require.alias("noflo-noflo-math/components/Divide.js", "noflo-ui-preview/deps/noflo-math/components/Divide.js");
require.alias("noflo-noflo-math/components/Floor.js", "noflo-ui-preview/deps/noflo-math/components/Floor.js");
require.alias("noflo-noflo-math/components/CalculateAngle.js", "noflo-ui-preview/deps/noflo-math/components/CalculateAngle.js");
require.alias("noflo-noflo-math/components/CalculateDistance.js", "noflo-ui-preview/deps/noflo-math/components/CalculateDistance.js");
require.alias("noflo-noflo-math/components/Compare.js", "noflo-ui-preview/deps/noflo-math/components/Compare.js");
require.alias("noflo-noflo-math/components/CountSum.js", "noflo-ui-preview/deps/noflo-math/components/CountSum.js");
require.alias("noflo-noflo-math/lib/MathComponent.js", "noflo-ui-preview/deps/noflo-math/lib/MathComponent.js");
require.alias("noflo-noflo-math/index.js", "noflo-math/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-math/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-math/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-math/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-math/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-math/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-math/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-math/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-math/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-math/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-math/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-math/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-math/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-math/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-math/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-math/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-math/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-math/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-math/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-math/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-objects/index.js", "noflo-ui-preview/deps/noflo-objects/index.js");
require.alias("noflo-noflo-objects/component.json", "noflo-ui-preview/deps/noflo-objects/component.json");
require.alias("noflo-noflo-objects/components/Extend.js", "noflo-ui-preview/deps/noflo-objects/components/Extend.js");
require.alias("noflo-noflo-objects/components/MergeObjects.js", "noflo-ui-preview/deps/noflo-objects/components/MergeObjects.js");
require.alias("noflo-noflo-objects/components/SplitObject.js", "noflo-ui-preview/deps/noflo-objects/components/SplitObject.js");
require.alias("noflo-noflo-objects/components/ReplaceKey.js", "noflo-ui-preview/deps/noflo-objects/components/ReplaceKey.js");
require.alias("noflo-noflo-objects/components/Keys.js", "noflo-ui-preview/deps/noflo-objects/components/Keys.js");
require.alias("noflo-noflo-objects/components/Size.js", "noflo-ui-preview/deps/noflo-objects/components/Size.js");
require.alias("noflo-noflo-objects/components/Values.js", "noflo-ui-preview/deps/noflo-objects/components/Values.js");
require.alias("noflo-noflo-objects/components/Join.js", "noflo-ui-preview/deps/noflo-objects/components/Join.js");
require.alias("noflo-noflo-objects/components/ExtractProperty.js", "noflo-ui-preview/deps/noflo-objects/components/ExtractProperty.js");
require.alias("noflo-noflo-objects/components/InsertProperty.js", "noflo-ui-preview/deps/noflo-objects/components/InsertProperty.js");
require.alias("noflo-noflo-objects/components/SliceArray.js", "noflo-ui-preview/deps/noflo-objects/components/SliceArray.js");
require.alias("noflo-noflo-objects/components/SplitArray.js", "noflo-ui-preview/deps/noflo-objects/components/SplitArray.js");
require.alias("noflo-noflo-objects/components/FilterPropertyValue.js", "noflo-ui-preview/deps/noflo-objects/components/FilterPropertyValue.js");
require.alias("noflo-noflo-objects/components/FlattenObject.js", "noflo-ui-preview/deps/noflo-objects/components/FlattenObject.js");
require.alias("noflo-noflo-objects/components/MapProperty.js", "noflo-ui-preview/deps/noflo-objects/components/MapProperty.js");
require.alias("noflo-noflo-objects/components/RemoveProperty.js", "noflo-ui-preview/deps/noflo-objects/components/RemoveProperty.js");
require.alias("noflo-noflo-objects/components/MapPropertyValue.js", "noflo-ui-preview/deps/noflo-objects/components/MapPropertyValue.js");
require.alias("noflo-noflo-objects/components/GetObjectKey.js", "noflo-ui-preview/deps/noflo-objects/components/GetObjectKey.js");
require.alias("noflo-noflo-objects/components/UniqueArray.js", "noflo-ui-preview/deps/noflo-objects/components/UniqueArray.js");
require.alias("noflo-noflo-objects/components/SetProperty.js", "noflo-ui-preview/deps/noflo-objects/components/SetProperty.js");
require.alias("noflo-noflo-objects/components/SimplifyObject.js", "noflo-ui-preview/deps/noflo-objects/components/SimplifyObject.js");
require.alias("noflo-noflo-objects/components/DuplicateProperty.js", "noflo-ui-preview/deps/noflo-objects/components/DuplicateProperty.js");
require.alias("noflo-noflo-objects/components/CreateObject.js", "noflo-ui-preview/deps/noflo-objects/components/CreateObject.js");
require.alias("noflo-noflo-objects/components/CreateDate.js", "noflo-ui-preview/deps/noflo-objects/components/CreateDate.js");
require.alias("noflo-noflo-objects/components/SetPropertyValue.js", "noflo-ui-preview/deps/noflo-objects/components/SetPropertyValue.js");
require.alias("noflo-noflo-objects/components/CallMethod.js", "noflo-ui-preview/deps/noflo-objects/components/CallMethod.js");
require.alias("noflo-noflo-objects/index.js", "noflo-objects/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-objects/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-objects/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-objects/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-objects/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-objects/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-objects/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-objects/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-objects/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-objects/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-objects/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-objects/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-objects/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-objects/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-objects/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-objects/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-objects/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-objects/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-objects/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-objects/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-objects/deps/underscore/index.js");

require.alias("noflo-noflo-packets/index.js", "noflo-ui-preview/deps/noflo-packets/index.js");
require.alias("noflo-noflo-packets/component.json", "noflo-ui-preview/deps/noflo-packets/component.json");
require.alias("noflo-noflo-packets/components/CountPackets.js", "noflo-ui-preview/deps/noflo-packets/components/CountPackets.js");
require.alias("noflo-noflo-packets/components/Unzip.js", "noflo-ui-preview/deps/noflo-packets/components/Unzip.js");
require.alias("noflo-noflo-packets/components/Defaults.js", "noflo-ui-preview/deps/noflo-packets/components/Defaults.js");
require.alias("noflo-noflo-packets/components/DoNotDisconnect.js", "noflo-ui-preview/deps/noflo-packets/components/DoNotDisconnect.js");
require.alias("noflo-noflo-packets/components/OnlyDisconnect.js", "noflo-ui-preview/deps/noflo-packets/components/OnlyDisconnect.js");
require.alias("noflo-noflo-packets/components/SplitPacket.js", "noflo-ui-preview/deps/noflo-packets/components/SplitPacket.js");
require.alias("noflo-noflo-packets/components/Range.js", "noflo-ui-preview/deps/noflo-packets/components/Range.js");
require.alias("noflo-noflo-packets/components/Flatten.js", "noflo-ui-preview/deps/noflo-packets/components/Flatten.js");
require.alias("noflo-noflo-packets/components/Compact.js", "noflo-ui-preview/deps/noflo-packets/components/Compact.js");
require.alias("noflo-noflo-packets/components/Zip.js", "noflo-ui-preview/deps/noflo-packets/components/Zip.js");
require.alias("noflo-noflo-packets/components/SendWith.js", "noflo-ui-preview/deps/noflo-packets/components/SendWith.js");
require.alias("noflo-noflo-packets/components/FilterPackets.js", "noflo-ui-preview/deps/noflo-packets/components/FilterPackets.js");
require.alias("noflo-noflo-packets/components/FilterByValue.js", "noflo-ui-preview/deps/noflo-packets/components/FilterByValue.js");
require.alias("noflo-noflo-packets/components/FilterByPosition.js", "noflo-ui-preview/deps/noflo-packets/components/FilterByPosition.js");
require.alias("noflo-noflo-packets/components/FilterPacket.js", "noflo-ui-preview/deps/noflo-packets/components/FilterPacket.js");
require.alias("noflo-noflo-packets/components/UniquePacket.js", "noflo-ui-preview/deps/noflo-packets/components/UniquePacket.js");
require.alias("noflo-noflo-packets/components/GroupByPacket.js", "noflo-ui-preview/deps/noflo-packets/components/GroupByPacket.js");
require.alias("noflo-noflo-packets/components/LastPacket.js", "noflo-ui-preview/deps/noflo-packets/components/LastPacket.js");
require.alias("noflo-noflo-packets/components/Counter.js", "noflo-ui-preview/deps/noflo-packets/components/Counter.js");
require.alias("noflo-noflo-packets/index.js", "noflo-packets/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-packets/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-packets/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-packets/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-packets/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-packets/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-packets/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-packets/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-packets/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-packets/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-packets/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-packets/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-packets/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-packets/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-packets/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-packets/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-packets/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-packets/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-packets/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-packets/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-packets/deps/underscore/index.js");

require.alias("noflo-noflo-physics/index.js", "noflo-ui-preview/deps/noflo-physics/index.js");
require.alias("noflo-noflo-physics/component.json", "noflo-ui-preview/deps/noflo-physics/component.json");
require.alias("noflo-noflo-physics/components/Spring.js", "noflo-ui-preview/deps/noflo-physics/components/Spring.js");
require.alias("noflo-noflo-physics/index.js", "noflo-physics/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-physics/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-physics/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-physics/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-physics/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-physics/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-physics/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-physics/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-physics/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-physics/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-physics/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-physics/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-physics/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-physics/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-physics/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-physics/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-physics/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-physics/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-physics/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-physics/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-routers/index.js", "noflo-ui-preview/deps/noflo-routers/index.js");
require.alias("noflo-noflo-routers/component.json", "noflo-ui-preview/deps/noflo-routers/component.json");
require.alias("noflo-noflo-routers/components/ControlledSequence.js", "noflo-ui-preview/deps/noflo-routers/components/ControlledSequence.js");
require.alias("noflo-noflo-routers/components/KickRouter.js", "noflo-ui-preview/deps/noflo-routers/components/KickRouter.js");
require.alias("noflo-noflo-routers/components/PacketRouter.js", "noflo-ui-preview/deps/noflo-routers/components/PacketRouter.js");
require.alias("noflo-noflo-routers/components/RegexpRouter.js", "noflo-ui-preview/deps/noflo-routers/components/RegexpRouter.js");
require.alias("noflo-noflo-routers/components/SplitInSequence.js", "noflo-ui-preview/deps/noflo-routers/components/SplitInSequence.js");
require.alias("noflo-noflo-routers/index.js", "noflo-routers/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-routers/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-routers/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-routers/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-routers/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-routers/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-routers/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-routers/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-routers/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-routers/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-routers/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-routers/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-routers/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-routers/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-routers/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-routers/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-routers/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-routers/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-routers/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-routers/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-routers/deps/underscore/index.js");

require.alias("noflo-noflo-strings/index.js", "noflo-ui-preview/deps/noflo-strings/index.js");
require.alias("noflo-noflo-strings/component.json", "noflo-ui-preview/deps/noflo-strings/component.json");
require.alias("noflo-noflo-strings/components/CompileString.js", "noflo-ui-preview/deps/noflo-strings/components/CompileString.js");
require.alias("noflo-noflo-strings/components/Filter.js", "noflo-ui-preview/deps/noflo-strings/components/Filter.js");
require.alias("noflo-noflo-strings/components/SendString.js", "noflo-ui-preview/deps/noflo-strings/components/SendString.js");
require.alias("noflo-noflo-strings/components/SplitStr.js", "noflo-ui-preview/deps/noflo-strings/components/SplitStr.js");
require.alias("noflo-noflo-strings/components/StringTemplate.js", "noflo-ui-preview/deps/noflo-strings/components/StringTemplate.js");
require.alias("noflo-noflo-strings/components/Replace.js", "noflo-ui-preview/deps/noflo-strings/components/Replace.js");
require.alias("noflo-noflo-strings/components/Jsonify.js", "noflo-ui-preview/deps/noflo-strings/components/Jsonify.js");
require.alias("noflo-noflo-strings/components/ParseJson.js", "noflo-ui-preview/deps/noflo-strings/components/ParseJson.js");
require.alias("noflo-noflo-strings/index.js", "noflo-strings/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-strings/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-strings/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-strings/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-strings/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-strings/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-strings/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-strings/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-strings/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-strings/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-strings/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-strings/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-strings/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-strings/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-strings/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-strings/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-strings/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-strings/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-strings/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-strings/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-strings/deps/underscore/index.js");

require.alias("noflo-noflo-websocket/index.js", "noflo-ui-preview/deps/noflo-websocket/index.js");
require.alias("noflo-noflo-websocket/component.json", "noflo-ui-preview/deps/noflo-websocket/component.json");
require.alias("noflo-noflo-websocket/components/Connect.js", "noflo-ui-preview/deps/noflo-websocket/components/Connect.js");
require.alias("noflo-noflo-websocket/components/SendMessage.js", "noflo-ui-preview/deps/noflo-websocket/components/SendMessage.js");
require.alias("noflo-noflo-websocket/components/ListenMessages.js", "noflo-ui-preview/deps/noflo-websocket/components/ListenMessages.js");
require.alias("noflo-noflo-websocket/index.js", "noflo-websocket/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-websocket/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-websocket/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-websocket/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-websocket/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-websocket/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-websocket/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-websocket/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-websocket/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-websocket/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-websocket/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-websocket/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-websocket/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-websocket/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-websocket/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-websocket/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-websocket/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-websocket/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-websocket/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-websocket/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-indexeddb/index.js", "noflo-ui-preview/deps/noflo-indexeddb/index.js");
require.alias("noflo-noflo-indexeddb/component.json", "noflo-ui-preview/deps/noflo-indexeddb/component.json");
require.alias("noflo-noflo-indexeddb/components/Open.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Open.js");
require.alias("noflo-noflo-indexeddb/components/Close.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Close.js");
require.alias("noflo-noflo-indexeddb/components/DeleteDatabase.js", "noflo-ui-preview/deps/noflo-indexeddb/components/DeleteDatabase.js");
require.alias("noflo-noflo-indexeddb/components/CreateStore.js", "noflo-ui-preview/deps/noflo-indexeddb/components/CreateStore.js");
require.alias("noflo-noflo-indexeddb/components/CreateIndex.js", "noflo-ui-preview/deps/noflo-indexeddb/components/CreateIndex.js");
require.alias("noflo-noflo-indexeddb/components/DeleteStore.js", "noflo-ui-preview/deps/noflo-indexeddb/components/DeleteStore.js");
require.alias("noflo-noflo-indexeddb/components/UpgradeRouter.js", "noflo-ui-preview/deps/noflo-indexeddb/components/UpgradeRouter.js");
require.alias("noflo-noflo-indexeddb/components/BeginTransaction.js", "noflo-ui-preview/deps/noflo-indexeddb/components/BeginTransaction.js");
require.alias("noflo-noflo-indexeddb/components/AbortTransaction.js", "noflo-ui-preview/deps/noflo-indexeddb/components/AbortTransaction.js");
require.alias("noflo-noflo-indexeddb/components/GetStore.js", "noflo-ui-preview/deps/noflo-indexeddb/components/GetStore.js");
require.alias("noflo-noflo-indexeddb/components/GetIndex.js", "noflo-ui-preview/deps/noflo-indexeddb/components/GetIndex.js");
require.alias("noflo-noflo-indexeddb/components/Query.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Query.js");
require.alias("noflo-noflo-indexeddb/components/QueryOnly.js", "noflo-ui-preview/deps/noflo-indexeddb/components/QueryOnly.js");
require.alias("noflo-noflo-indexeddb/components/QueryFrom.js", "noflo-ui-preview/deps/noflo-indexeddb/components/QueryFrom.js");
require.alias("noflo-noflo-indexeddb/components/QueryTo.js", "noflo-ui-preview/deps/noflo-indexeddb/components/QueryTo.js");
require.alias("noflo-noflo-indexeddb/components/Put.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Put.js");
require.alias("noflo-noflo-indexeddb/components/Get.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Get.js");
require.alias("noflo-noflo-indexeddb/components/Delete.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Delete.js");
require.alias("noflo-noflo-indexeddb/index.js", "noflo-indexeddb/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-indexeddb/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-indexeddb/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-indexeddb/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-github/index.js", "noflo-ui-preview/deps/noflo-github/index.js");
require.alias("noflo-noflo-github/component.json", "noflo-ui-preview/deps/noflo-github/component.json");
require.alias("noflo-noflo-github/components/CreateRepository.js", "noflo-ui-preview/deps/noflo-github/components/CreateRepository.js");
require.alias("noflo-noflo-github/components/CreateOrgRepository.js", "noflo-ui-preview/deps/noflo-github/components/CreateOrgRepository.js");
require.alias("noflo-noflo-github/components/GetRepository.js", "noflo-ui-preview/deps/noflo-github/components/GetRepository.js");
require.alias("noflo-noflo-github/components/GetContents.js", "noflo-ui-preview/deps/noflo-github/components/GetContents.js");
require.alias("noflo-noflo-github/components/GetCurrentUser.js", "noflo-ui-preview/deps/noflo-github/components/GetCurrentUser.js");
require.alias("noflo-noflo-github/components/GetUser.js", "noflo-ui-preview/deps/noflo-github/components/GetUser.js");
require.alias("noflo-noflo-github/components/GetStargazers.js", "noflo-ui-preview/deps/noflo-github/components/GetStargazers.js");
require.alias("noflo-noflo-github/components/SetContents.js", "noflo-ui-preview/deps/noflo-github/components/SetContents.js");
require.alias("noflo-noflo-github/index.js", "noflo-github/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-github/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-github/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-github/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-github/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-github/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-github/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-github/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-github/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-github/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-github/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-github/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-github/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-github/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-github/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-github/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-github/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-github/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-github/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-github/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("bergie-octo/octo.js", "noflo-noflo-github/deps/octo/octo.js");
require.alias("bergie-octo/octo.js", "noflo-noflo-github/deps/octo/index.js");
require.alias("visionmedia-superagent/lib/client.js", "bergie-octo/deps/superagent/lib/client.js");
require.alias("visionmedia-superagent/lib/client.js", "bergie-octo/deps/superagent/index.js");
require.alias("component-emitter/index.js", "visionmedia-superagent/deps/emitter/index.js");

require.alias("component-reduce/index.js", "visionmedia-superagent/deps/reduce/index.js");

require.alias("visionmedia-superagent/lib/client.js", "visionmedia-superagent/index.js");
require.alias("bergie-octo/octo.js", "bergie-octo/index.js");
require.alias("d4tocchini-noflo-draggabilly/index.js", "noflo-ui-preview/deps/noflo-draggabilly/index.js");
require.alias("d4tocchini-noflo-draggabilly/component.json", "noflo-ui-preview/deps/noflo-draggabilly/component.json");
require.alias("d4tocchini-noflo-draggabilly/components/Draggabilly.js", "noflo-ui-preview/deps/noflo-draggabilly/components/Draggabilly.js");
require.alias("d4tocchini-noflo-draggabilly/index.js", "noflo-draggabilly/index.js");
require.alias("noflo-noflo/component.json", "d4tocchini-noflo-draggabilly/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "d4tocchini-noflo-draggabilly/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("forresto-noflo-gum/index.js", "noflo-ui-preview/deps/noflo-gum/index.js");
require.alias("forresto-noflo-gum/component.json", "noflo-ui-preview/deps/noflo-gum/component.json");
require.alias("forresto-noflo-gum/components/GetUserMedia.js", "noflo-ui-preview/deps/noflo-gum/components/GetUserMedia.js");
require.alias("forresto-noflo-gum/index.js", "noflo-gum/index.js");
require.alias("noflo-noflo/component.json", "forresto-noflo-gum/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "forresto-noflo-gum/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "forresto-noflo-gum/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "forresto-noflo-gum/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "forresto-noflo-gum/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "forresto-noflo-gum/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "forresto-noflo-gum/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "forresto-noflo-gum/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "forresto-noflo-gum/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "forresto-noflo-gum/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "forresto-noflo-gum/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "forresto-noflo-gum/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "forresto-noflo-gum/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "forresto-noflo-gum/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "forresto-noflo-gum/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "forresto-noflo-gum/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "forresto-noflo-gum/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "forresto-noflo-gum/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "forresto-noflo-gum/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("forresto-noflo-seriously/index.js", "noflo-ui-preview/deps/noflo-seriously/index.js");
require.alias("forresto-noflo-seriously/vendor/seriously.js", "noflo-ui-preview/deps/noflo-seriously/vendor/seriously.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.ascii.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.ascii.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.bleach-bypass.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.bleach-bypass.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.blend.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.blend.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.blur.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.blur.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.brightness-contrast.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.brightness-contrast.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.channels.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.channels.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.chroma.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.chroma.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.color.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.color.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.colorcomplements.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.colorcomplements.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.colorcube.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.colorcube.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.daltonize.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.daltonize.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.directionblur.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.directionblur.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.dither.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.dither.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.edge.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.edge.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.emboss.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.emboss.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.exposure.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.exposure.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.fader.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.fader.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.falsecolor.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.falsecolor.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.filmgrain.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.filmgrain.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.hex.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.hex.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.highlights-shadows.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.highlights-shadows.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.hue-saturation.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.hue-saturation.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.invert.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.invert.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.kaleidoscope.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.kaleidoscope.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.layers.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.layers.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.linear-transfer.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.linear-transfer.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.lumakey.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.lumakey.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.nightvision.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.nightvision.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.noise.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.noise.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.repeat.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.repeat.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.ripple.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.ripple.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.scanlines.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.scanlines.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.sepia.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.sepia.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.simplex.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.simplex.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.sketch.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.sketch.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.split.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.split.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.tone.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.tone.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.tvglitch.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.tvglitch.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.vignette.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.vignette.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.whitebalance.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.whitebalance.js");
require.alias("forresto-noflo-seriously/vendor/transforms/seriously.camerashake.js", "noflo-ui-preview/deps/noflo-seriously/vendor/transforms/seriously.camerashake.js");
require.alias("forresto-noflo-seriously/vendor/transforms/seriously.transform3d.js", "noflo-ui-preview/deps/noflo-seriously/vendor/transforms/seriously.transform3d.js");
require.alias("forresto-noflo-seriously/component.json", "noflo-ui-preview/deps/noflo-seriously/component.json");
require.alias("forresto-noflo-seriously/components/SetFilterSource.js", "noflo-ui-preview/deps/noflo-seriously/components/SetFilterSource.js");
require.alias("forresto-noflo-seriously/components/SetFilterTarget.js", "noflo-ui-preview/deps/noflo-seriously/components/SetFilterTarget.js");
require.alias("forresto-noflo-seriously/lib/SeriouslyEffect.js", "noflo-ui-preview/deps/noflo-seriously/lib/SeriouslyEffect.js");
require.alias("forresto-noflo-seriously/components/FilterAscii.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterAscii.js");
require.alias("forresto-noflo-seriously/components/FilterBleachBypass.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterBleachBypass.js");
require.alias("forresto-noflo-seriously/components/FilterBlend.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterBlend.js");
require.alias("forresto-noflo-seriously/components/FilterChannels.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterChannels.js");
require.alias("forresto-noflo-seriously/components/FilterChroma.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterChroma.js");
require.alias("forresto-noflo-seriously/components/FilterColor.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterColor.js");
require.alias("forresto-noflo-seriously/components/FilterColorCube.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterColorCube.js");
require.alias("forresto-noflo-seriously/components/FilterDaltonize.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterDaltonize.js");
require.alias("forresto-noflo-seriously/components/FilterEdge.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterEdge.js");
require.alias("forresto-noflo-seriously/components/FilterEmboss.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterEmboss.js");
require.alias("forresto-noflo-seriously/components/FilterExposure.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterExposure.js");
require.alias("forresto-noflo-seriously/components/FilterFader.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterFader.js");
require.alias("forresto-noflo-seriously/components/FilterHex.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterHex.js");
require.alias("forresto-noflo-seriously/components/FilterHueSaturation.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterHueSaturation.js");
require.alias("forresto-noflo-seriously/components/FilterInvert.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterInvert.js");
require.alias("forresto-noflo-seriously/components/FilterLumakey.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterLumakey.js");
require.alias("forresto-noflo-seriously/components/FilterNightVision.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterNightVision.js");
require.alias("forresto-noflo-seriously/components/FilterNoise.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterNoise.js");
require.alias("forresto-noflo-seriously/components/FilterRipple.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterRipple.js");
require.alias("forresto-noflo-seriously/components/FilterScanLines.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterScanLines.js");
require.alias("forresto-noflo-seriously/components/FilterSepia.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterSepia.js");
require.alias("forresto-noflo-seriously/components/FilterSketch.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterSketch.js");
require.alias("forresto-noflo-seriously/components/FilterSplit.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterSplit.js");
require.alias("forresto-noflo-seriously/components/FilterTone.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterTone.js");
require.alias("forresto-noflo-seriously/components/FilterTVGlitch.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterTVGlitch.js");
require.alias("forresto-noflo-seriously/components/FilterVignette.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterVignette.js");
require.alias("forresto-noflo-seriously/index.js", "noflo-seriously/index.js");
require.alias("noflo-noflo/component.json", "forresto-noflo-seriously/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "forresto-noflo-seriously/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "forresto-noflo-seriously/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "forresto-noflo-seriously/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "forresto-noflo-seriously/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "forresto-noflo-seriously/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "forresto-noflo-seriously/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "forresto-noflo-seriously/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "forresto-noflo-seriously/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "forresto-noflo-seriously/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "forresto-noflo-seriously/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "forresto-noflo-seriously/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "forresto-noflo-seriously/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "forresto-noflo-seriously/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "forresto-noflo-seriously/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "forresto-noflo-seriously/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "forresto-noflo-seriously/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/components/Graph.js", "forresto-noflo-seriously/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "forresto-noflo-seriously/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");